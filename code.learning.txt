[tt.js 10-05-2022]:
----------------------------------
[mc.js 10-06-2022]:
let __viewTransform = true
var magicVuePrintDocumentHeight = 1122
----------------------------------
[mc.js 10-11-2022]:
function vueComputedValueFactory(key) {

    function mapPercentage(percent, f) {
        return function lambda(item, i, a) {
            
        }
    }

    function blankIt(item) {
        if (isObject(item)) {
            return transformObject(item, 'question', '')
        }
        return ''
    }

    function computedValue() {
        if (!this[key]) return 
        let value = this.value || this.items
        switch (key) {
            case 'smartexample':
                return value.map(mapPercentage(15, blankIt))
            default:
                return value
        }
    }
    return {
        computedValue
    }
}
----------------------------------
[app2.js 10-19-2022]:
function cwtEmailCoursework(data) {
    const html = new HTMLWriter()
    const online = []
    const attachmentIds = []
    const body = []
    let official
    if (isObject(data)) {
        data = data.data
        official = true
    }
    //if (!isA)

    data.forEach(({ name, id, link, inPersonOnly }, i) => {
        name = removeExtension(name)
        attachmentIds.push(id)
        body.push(parseBody(name, i))

        if (!link) inPersonOnly = true
        if (!inPersonOnly) {
            online.push(parseOnline(name, link))
        }
    })

    function parseOnline(name, link) {
        return `<li><div><a href="${link}">${name} link</a></div></li>`
        //return html.create().bold(name).colon().url(link).wrap('ul')
    }
    function parseBody(name, i) {
        if (/report/i.test(name)) {
            name += ' (for office)'
        }
        if (/all|combine/i.test(name)) {
            name +=
                ' (1 copy. Staple for every 3 pages. Each student has a different quiz.)'
        }
        if (/extra/i.test(name)) {
            name += ' (only need 1 copy | no staples)'
        }
        return html.create().ol(name, i)
    }

    const onlineStatement = html.bold(
        'Google Classroom Links:',
        'mb5'
    )
    const onlineStuff = exists(online) ? 
        onlineStatement + '\n\n' + join(online) : ''

    const bodyPayload = html
        .create()
        .combine(
            '<br/>',
            body,
            '<br/>',
            onlineStuff,
        )
    const date = upcomingDate('saturday')
    const title = `Grade 4/5 Math Materials [${date}]`
    let to = official ? citiwideemail : 'kdog3682@gmail.com'
    to = 'kdog3682@gmail.com'
    //to = citiwideemail

    email5({
        attachments: attachmentIds,
        subject: title,
        body: bodyPayload,
        to: to,
    })

    return {
        value: bodyPayload,
    }
}
----------------------------------
[class.js 10-28-2022]:
const DataAnalysisModule = (data) => {

    const constructor = () => {
        console.log('initializing data analysis')
    }

    const getNames = (regex) => {
        return sorted(magicMapFilter(data, {name: regex}))
        /* internal state is not maintained */
    }

    constructor()

    return {
        getNames
    }
}
----------------------------------
[class.js 11-07-2022]:
var VNumberedList = {
    name: 'VNumberedList',
    props: ['value'],
    template: `
    <div class="v-numbered-list">
        <div v-for="item, i in computedValue">
            <v-numbered :value="i" template="1.">
                <div  
                    <slot :item="item">
                        <app-math-item :value="item"/>
                    </slot>
                </div>
            </v-numbered>
        </div>
    </div>
    `,
}
----------------------------------
[class.js 11-07-2022]:
var xxAppHomework = {
    transform: true,
    name: 'AppHomework',
    props: ['value'],
    template: `
        <h2 class="title">{{title}}</h2>
        <v-numbered-list :value="value">
            <slot :item="item">
                <app-homework-item :value="item"/>
            </slot>
        </v-numbered-list>
    `,
}
----------------------------------
[class.js 11-07-2022]:
var xxAppHomeworkItem = {
    transform: true,
    name: 'AppHomeworkItem',
    props: ['value'],
    template: `
        
        <div class="items-container">
            <div v-for="item in items" class="">
                <v-number :value="i" template="1.">
                    <slot :item="item">
                        <div>{{item}}</div>
                    </slot>
                </v-number>
            </div>
        </div>
    `,
}
----------------------------------
[class.js 11-07-2022]:
var AppMathItem = {
    transform: true,
    name: 'AppMathItem',
    props: ['value'],
    template: `
        <v-math-text v-color="value.color" :value="value.value"/>
    `,
}
----------------------------------
[class.js 11-08-2022]:
class VueRenderDialogue {
    constructor(vueState) {
        this.state = vueState
        if (!isNode()) this.h = vueState.$createElement
    }

    renderWrapper(wrapperClass, children) {
        return simpleWrapper(this.h, wrapperClass, children)
    }
    renderDialogueObject({speaker, value}) {
        const [speakerOpts, dialogueRightOpts, dialogueRowOpts] = doSpeakerStyles(this.speakers)
        const Speaker = this.renderWrapper(speakerOpts, speaker)
        const Items = value.map((item, i) => {
            console.log(item, 'hii')
            let value = item.arg ? eval(item.arg) : item.value
            let options = {
                ...buildStyleObject(item.name),
                props: {value}
            }
            return renderIt(this.h, item.component, options)
        })
        const WrappedItems = this.renderWrapper(dialogueRightOpts, Items)
        const kids = [Speaker, WrappedItems]
        return this.renderWrapper(dialogueRowOpts, kids)
    }
    render(items) {
        let arg = isPuppeteer() ? puppetArg : getGlobalString()
        if (!items) {
            items = tokenizer1106(arg)
        }
        if (isNode()) return items
        const speakers = ['Sam', 'Stephanie Nguyen']
        this.speakers = speakers
        const pairings = PairSpeakers(speakers)
        let dialogue = pairings(items)
        let obj = dialogue.map((dialogueObject, i) => {
            return this.renderDialogueObject(dialogueObject)
        })
        return this.renderWrapper('parent', obj)
        /** vrd **/
    }
}
----------------------------------
[class.js 11-08-2022]:
const PairSpeakers = (speakers) => {

    const simplePairing = (items) => {
        return items.map((item, i) => {
            let speaker = speakers[i % 2]
            //console.log(item)
            return {
                speaker,
                value: item,
            }
        })
    }


    if (speakers.length == 2) {
        return simplePairing
    }
}
----------------------------------
[class.js 11-08-2022]:
function go(overrideKey) {
    let key

    const ref = {
        sg: [
            () => sentenceGetter(s),
            () => renderApp(VText, s)
        ],

        vrd: [
            () => sentenceGetter(s),
            () => vuetify(VueRenderDialogue),
        ],

        vrd: [
            () => (new VueRenderDialogue).render(),
            () => vuetify(VueRenderDialogue),
        ],
    }

    key = 'vrd'
    let [a,b] = ref[overrideKey || key]

    if (isNode()) {
        return console.log(JSON.stringify(a(), null, 2))
        return console.log(a())
    } else {
        if (overrideKey) {
            return 
        }
        var vuetify = makeRunner(vuetifyItems)
        legoLoader()
        vuetify(katexDirective)
        let val = b()
        return val
    }
}
----------------------------------
[class.js 11-08-2022]:
function renderApp(c, props) {
    return {render: (h) => h(c, propIt(props))}
}
----------------------------------
[vimrc 11-08-2022]:
function OldAnythingHandler(s)
    
    " depppppppppp
    let line = CurrentLine()

    if key == 'js'
        call MarkPosition()
        call OpenBuffer('/home/kdog3682/CWF/public/utils.js')
        call AppendBottom(ConsoleLog(arg))
        return 

    elseif has_key(g:vuenavdict, s)
        return Navigator(g:vuenavdict[s])

    elseif key == 'i' && Test(line, '\(\d+\)')
        call IncrementLine(line('.'))
        "foo(4)

    elseif key == '.'
        call MagicVueHandler(line('.'), getline('.'))


    elseif key == '1'
        let g:A = GetCurrentWord()
        let g:posA = GetPos()
    elseif key == '2'
        let g:B = GetCurrentWord()
        let g:posB = GetPos()
        call ExecuteReplaceOnce(g:B, g:A)
        call SetPos(g:posA)
        call ExecuteReplaceOnce(g:A, g:B)
    elseif key == '3'
        call SetPos(g:posA)
        call ExecuteReplaceOnce(g:B, g:A)
        call ExecuteReplaceOnce(g:A, g:B)
        call SetPos(g:posB)
    endif
endfunction
----------------------------------
[vimrc 11-08-2022]:
function FilePicker()
    let files = ['1', '2']
    let a = Choose(files)
    return a
endfunction
----------------------------------
[jsbin 11-09-2022]:
 <!DOCTYPE html>
<html>
<head>
  <meta charset=utf-8 />
  <title>JS Bin</title>
  <style type="text/css">
    body {
      font-family: helvetica, sans-serif;
      font-size: 10px;
    }
    .sprite {
      background: url(http://vxresource.files.wordpress.com/2010/02/char113.png);
      height: 32px;
      width: 30px;
      background-position: 128px 0px;
      position: relative;
      top: 50px;
      left: 50px;
    }
    .sprite::after {
      content: attr(data-score);
      position: absolute;
      top: -10px;
      width: 100px;
      background: red;
      opacity:0;
      /* transition: 2s; */
    }
    .sprite:hover::after {
      opacity: 1;
    }
    .sprite[data-score="10"]::after {
      /* color: #c00; */
      background: blue;
    }
  </style>
  </head>
<body>
  <div class="sprite" data-score="101"></div>
  <script>
    var character = document.querySelector('.sprite');
    character.dataset.score = 10;
  </script>
</body>
</html>

-------------------------------------
[vimrc 11-09-2022 StateContext]
    get root() {
        if (this.parentContext) {
            return this.parentContext.root
        } else {
            return this
        }
    }
    set root(value) {
        this._root = value
    }

It is a gimicky construction and gimicky constructs rarely work.
-------------------------------------
[class.js 11-09-2022]:
//s = new StyleObject()
//s.minWidth(203)
//console.log(s.toJSON())
//go()
console.log(buildStyleObject('fs1 mb15 pt4 my5')) // needs setup

//console.log(appjsbin2())
----------------------------------
[class.js 11-09-2022]:
function appjsbin2() {
    s = `
        list items
            fo
            bo
            go

        fruits
            apples
            grapes
            favorites
                peaches
                watermelon
    `
    const h = new HTMLTextBuilder
    const value = h.render(s)
    console.log(value)
}
----------------------------------
[class.js 11-09-2022]:
function transformHTML(s) {
    const h = new HTMLTextBuilder
    const value = h.render(s).toString()
    return value
}
----------------------------------
[class.js 11-09-2022]:
function go() {
    return {
        render(h) {
            let r = new VueRenderer(this)
            /* why are we rendering a demo ... it is to see the arrangehtml in action */
            ----------------

----------------

            return r.renderDemo()
        },
        mounted() {
            console.log('hello from go')
            
        },
    }
}
----------------------------------
[class.js 11-09-2022]:
function htmlDemo() {

    s = `
        a
        b
        c
            d
            e
                f
            g
        
    `
    const builder = new HTMLStringBuilder()
    const html = builder.render(s)
    console.log(html)
    //html.iterate((element, enter) => {
    //const css = new CSSObject()
        //css.
    //})
    return html
}
----------------------------------
//console.log(splitKatexNew('multiply 3 and 4 by 5/6'))

//clip(FractionEquality3('4/5', 5, true))

//console.log(latex._dfrac('a', 'b'))


//item = "bold 60/70 is the exact same as 6/7."
//console.log(mconfig(item, /^bold/))

[class.js 11-09-2022]:
function splitKatex1106(s) {
    let runners = [
        {regex: newlineRE, fn: latex.newline},
        {regex: simpleFractionRE, fn: latex.dfrac},
    ]
    let store = []
    s = s.trim()
    while (true) {
        let m
        let f = identity
        for (let {regex, fn} of runners) {
            m = s.match(regex)	
            if (m) {
                f = fn
                break
            }
        }

        if (!m) {
            push(store, proseIt(s))
            break
        }
        let match = m[0]
        let before = s.slice(0, m.index)
        push(store, proseIt(before))
        push(store, mathIt(f(match)))
        let length = match.length + m.index
        s = s.slice(length)
    }
    //console.log(store); throw '';
    return store
}
----------------------------------
[class.js]
//to treat them as equals ... is not exactly correct.
//fn.foohomework is a big deal. it is what is responsible for generating the homework.
//clip(ufa(/^[^\w\s]\S+/gm, '/home/kdog3682/CWF/public/user'), 'sdf.txt')
//cssCreateClass('a/b/c')
/* if it is too easy ..., there will not be engagement */
//bugprint('g.gridlayout is used to create cssClasses which will only happen once. csscreateclass relies on setup of styleobject.')
//go()
/* bold ... */
/* drawing the fractions in */
/* okay */
/* needs to go into the structure ... somehow */
/** B **/
//go()
//go()
//parser = makeConfigParser(HtmlLineParserConfigItems)
//setup({ legos: true, styles: true, lorem: true, })
// setup({ legos: false, styles: true, lorem: false, })
// console.log(parser('for = itemsgg :bx s(fs30 fs30 p4) :bbbb   :hhh .dfg .gg'))
/* first parse, and then, tokenize, and then, build  */
//parse2(stringBreaker(svgstr1110))
// console.log(htmlTransform(svgstr1110))
----------------
polygon points pathLength
polyline  points pathLength
rect width height rx ry x y
foreignObject width height x y
path d pathLength
text x y dx dy
use x y width height href 
line x1 x2 y1 y2 pathLength
circle r cx cy pathLength
ellipse rx ry cx cy pathLength

the pattern is called via [fill] or [stroke]
the pattern is placed under [defs]
use is like pattern ... [use href = #id] [requires viewbox]
svg is an amazing system.
[run-node.js 11-11-2022]:
const NodeController = () => {
    const process = require('process')
    const app = require('./app.js')
    const [key, ...args] = process.argv.slice(2)
    const stop = () => {
        return `[fnkey]:${key || 'null'} not present in app.js`
    }
    const fn = app[key] || stop
    const value = fn(...args)
    console.log({key, args, fn, value, message: 'node-controller'})
}
----------------------------------
[pdf.py 11-13-2022]:
def pdfFromIndexes(file, outpath, indexes):
    outpath = addExtension(outpath, 'pdf')
    pdf = Pdf.new()
    src = pikeOpen(file)
    #for i in indexes:
        #pdf.pages.extend(src.pages[i[0]: i[1]])
        #pdf.pages.extend(src.pages[i:i + 1])

    if isArray(indexes) and indexes[1] - indexes[0] > 1:
        
    pdf.pages.extend(src.pages[indexes[0]: indexes[1])

    prompt(len(pdf.pages))
    save(pdf, outpath)

----------------------------------
[pdf.py 11-13-2022]:
def DEPRECATEDsplitpdf(
    # deprecated in favor of the various pike methods for splitting and concating pdfs
    file=None, start=0, end=0, outpath="split", extract=0
----------------------------------
[pdf.py 11-13-2022]:
def DEPRECATEDsplitpdf(
    # deprecated in favor of the various pike methods for splitting and concating pdfs
    file=None, start=0, end=0, outpath="split", extract=0
    ):
    start = start - 1
    end = end - 1
    outpath = addExtension(outpath, "pdf")
    kwargs = dict(from_page=start, to_page=end)

    doc = fitzOpen(file)
    out = fitzOpen()
    out.insertPDF(doc, **kwargs)
    out.save(outpath)

    if extract:
        extractpdf(outpath, view=1)
    else:
        ofile(outpath)


----------------------------------
[pdf.py 11-13-2022]:
def extractpdf(file=None, mode="pages", parser=0, view=0):
    #deprecated in favor of extractPages
    if not file:
        file = getLastPdf()

    file = addExtension(file, "pdf")
    pdf = fitz.open(file)

    store = []
    if mode == "blocks":
        for page in pdf:
            blocks = defaultBlocker(
                page.get_text("blocks"), parser
            )
            store.append(blocks)

    elif mode == "pages":
        for page in pdf:
            text = page.get_text()
            store.append(text)

    elif mode == "text":
        for page in pdf:
            text = page.get_text()
            store.append(text)

    elif mode == "":
        for page in pdf:
            text = page.get_text()
            store.append(text)

    elif mode == "layout":
        for page in pdf:
            blocks = page.get_text().encode("utf8")
            store.append(blocks)

    if mode == "text":
        store = join(store)

    return store


----------------------------------
[pdf.py 11-13-2022]:
def DEPRECATEDextractPages(source, pageIndexes, dest="extract.pdf"):
    # the pike version is superior

    mypdf = PdfFileReader(open(source, "rb"))
    try:
        mypdf.getPage(1)
    except Exception as e:
        mypdf = decryptPDF(mypdf, source)
        mypdf.getPage(1)
        print("success")
        return

    output = PdfFileWriter()
    for n in pageIndexes:
        output.addPage(mypdf.getPage(n - 1))
    pdfWriteHelper(dest, output)


----------------------------------
[pdf.py 11-13-2022]:
def DEPpdfWriteHelper(file, output):
    #pikeSave is better
    name = changeExtension(file, "pdf")
    with open(name, "wb") as f:
        output.write(f)
    ofile(name)


----------------------------------
[pdf.py 11-13-2022]:
def DEPdecryptPDF(reader, filename):
    # not needed due to pike doing it naturally
    try:
        reader.decrypt("")
        print("File Decrypted (PyPDF2)")
        return reader
    except Exception as e:
        print(e)
        raise Exception()
        command = (
            "cp "
            + filename
            + " temp.pdf; qpdf --password='' --decrypt temp.pdf "
            + filename
            + "; rm temp.pdf"
        )
        os.system(command)
        print("File Decrypted (qpdf)")
        mypdf = PdfFileReader(open(filename, "rb"))
        return reader


----------------------------------
[pdf.py 11-13-2022]:
def mathBookExtract():
    return 
    runjs('/home/kdog3682/CWF/public/class.js')
    s = clip()
    fix = fixFileNameFactory(dldir)
    """ 
        This is not a good idea.
        It is an unstable construction.
        Fixes should be preventative not after-the-fact.
    """
    for item in s:
        file = item.get("file")
        file = fix(file)
        if not file.startswith("B"):
            continue

        range = item.get("range")
        outpath = item.get("outpath")
        extractPages(file, range, outpath)


----------------------------------
pikeMetaData('wg4') 

The wg4 alias comes from pikeOpen using pdfdict aliasing.
This function is decorated with a toPike wrapper which auto converts strings into potential pike objects.

[class.js 11-14-2022]:
function appendArgsf(f, ...args) {
    return function lambda(s, i) {
        return f(s, ...args)
    }
}

Adds args after the first default arg. A form of currys
----------------------------------
[class.js 11-14-2022 EXAMPLE]:
const Mod = () => {
    class MyClass {
        constructor() {
        }
    }
    const myClass = new MyClass()
    function foobar() {
        console.log('hi from foo')
    }
    const functions = [foobar]
    const state = {
        myClass,
    }

    for (let f of functions) {
        state[f.name] = (...args) => f(...args)
    }
    return state
}
const {myClass, foobar} = Mod()
console.log(myClass.toString(), foobar.toString())

When you string it, the true values are obfuscated.
----------------------------------
[class.js 11-14-2022 EXAMPLE]:
s = [
    {value: 'hi', className: 'bo', style: 'hii'},
    {value: 'hi', className: 'sdfsdf'},
    {
        className: 'foo',
        children: [
    {value: 'hi', className: 'sdfsdf'},
    {value: 'hi', className: 'sdfsdf'},
        {   className: 'boo', tag: 'p',
            children: [

    {value: 'hi', className: 'sdfsdf'},
    {value: 'hi', className: 'sdfsdf'},
    {value: 'hi', className: 'bo'},
        ]},
    ]}
]
console.log((new HTMLStringBuilder().render(s).toString()))
----------------------------------
[class.js 11-14-2022]:
cwtsampledata = {
    official: 0,
    extraMessage: 'hi',
    data: [
        {name: 'the powerly.pdf', id: '', link: ''},
        {name: 'the powerly.pdf', id: '', link: ''},
        {name: 'the powerly.pdf', id: '', link: ''},
    ]
}
function createBody(data) {
    const builder = new HTMLStringBuilder()
    builder.list(data.map((x) => x.name))
    return builder.toString()
}
console.log(createBody(cwtsampledata.data))
----------------------------------
[class.js 11-14-2022 EXAMPLE]:
docstring = `

let me buy lunch today. i owe u 28 dollars
bro calm down. take it easy.
what's up dude. long time no see.
believe in yourself. clear eyes, full heart, can't lose.
sometimes i feel like i am in a war with myself. to be the person i want to be, or to fall into old habits
the hardest step is the first step. but every step after, is hard too.
so anyways, how are things with you?
is everything going okay?
do you have any plans for the new year?
excuse me, I have been waiting since 9PM. I think I should go first.



how old are you? (asking a child)
how old are you? (asking a teenager)
how old are you? (asking a man)
how old are you? (asking a middle-age man)
how old are you? (asking a senior)
how old is your child? (asking a parent)

You know what? I actually have no idea what I am talking about. 
The reason I always turn off the lights is because I used the computer a lot during the day so I want to give my eyes a rest.
I have no comments regarding this subject matter.
I have been reading a memoir, "Educated" by Tara Westover. It is an amazing story. Words cannot describe it. If you have time, I highly recommend you give it a shot.
the only way to not lose, is to not play, but what's the fun in that?
that was a complete exaggeration. i dont think it is correct. i just made it up out of nowhere.
I would like to show you a potential strategy that we can try. After you pass me the ball, move to the corner, and i will pass it back to you.



---------------------------------
:skip
There are 5 students in the classroom, a small, quiet fifth grade class, and one student had just run out of pencil lead. She says, "I'm out of lead. Can I borrow a pencil?" 

A girl near her takes out a pencil pouch, and takes out a small capsule of lead. There are 6 or 7 pieces. She takes one out.

It is for herself.

I wanted to say, "For the small price of a 1-inch piece of lead and 2 words, "Here Daphne", you can make a friend."



---------------------------------
I am having a hard time teaching a group of 4th grade students.
I keep telling myself, do not shout at them.
What happens next?
A few boys start misbehaving.
Soon, like wildfire, a other students start whispering.
Before I know it, I am shouting at them.

I remember my 4th grade teacher very well.
Her name was Ms. Knuth.
She never shouted at us.
Everything was always soft and warm.

How would Ms. Knuth do it?
Whenever I feel stuck as a teacher, this is the question I ask.
What would Ms. Knuth do?
Her classroom was calm. It smelled like scented candles.

My classroom does not have scented candles.
My classroom does not have calm.

Candles = calm? :tearlaugh:

------
General Questions:

How do you politely address a female who you do not know, who you think is 1-2 years older than you?
How do you politely address a parent of a student when you do not know the parent's name? 

What is some small talk I can make with the front desk man of a building? (he is about 60-70 years old)

How do you politely tell someone that you think their idea is wrong or mistaken?

How do you politely tell someone that "Thank you for the suggestion, but that is none of your business?"


`

var tokref1103 = [
    {
        regex: /^--+([^]+?)/,
        props: {
            skip(s) {
                return 
            },
            foo(s) {
                
            }
        },
        parser(s) {
            return s
        }
    },

    {
        regex: /.+/,
        parser(s) {
            return s
        }
    },
]
function foodocstring(s) {
    return tokenizer(Tokenizer1025a, tokref1103, s)
}
----------------------------------

function getf(s, functions) {
    if (!isNestedArray(functions)) {
          functions = partition(functions)
    }
    for (let [a, b] of functions) {
        if (a.test(s)) {
            return b
        }
    }
}

typer0824items = [
        isEmptyLine,
        'linebreak',
        len,
        isDashLine,
        'tableLineBreak',
        null,
        hasDollar,
        'katex',
        latexParser,
        yes,
        'prose',
        proser,
]
//var typer0824 = runf(typer0824items, {partitions:3})
//it feels like CreateTok. 

function incrementalPartition(items, f) {

    const newPage = (item) => {
        current = []
        store.push(current)
        if (item) current.push(item)
    }
    const push = (item) => {
        current.push(item)
    }


    let lastValue = f(items[0])
    let store = []
    let current
    newPage()

    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        let newValue = f(item)
        if (newValue == lastValue) {
            push(item)
        } else {
            lastValue = newValue
            newPage(item)
        }
    }
    return store
}

function foo(s, after) {
    var fs = [
        /  /, 
        wrapf((x) => split(x, /  /), {after}),
        /[;:]/, 
        (x) => split(x, /[;:]/),
    ]
    const values = linegetter(s).map(getf(s, fs))
    return incrementalPartition(values, len)
}
//foo(s)

This stuff really feels a lot like CreateTok.
Feels like a worser version of it.
So it makes sense to deprecate it.
---------------------------------
[class.js 11-14-2022]:
function githubAssetUrl(id) {
    return "https://github.githubassets.com/images/icons/emoji/unicode/" + id + ".png?v8"
}
----------------------------------
[class.js 11-14-2022]:
function newRegex(r, f) {
    const value = f(r.source)
    //if (value) throwError(value)
    if (!value) return r
    return RegExp(value,  r.flags)
}
[todo] This can definitely be articulated with some sort of v-table.

More fine grain control by separating each row from the table.

v-table
    row1 = [
    for trait in traits


Math Midterm  Score
Problem Solving  A  B  C  D
Logical Reasoning  A  B  C  D
Attendance  A  B  C  D
Class Participation  A  B  C  D
Homework Completion  A  B  C  D
Overall Performance  A  B  C  D
Teacher Comments
Parent Signature
`
s2 = `

------------------------
diploma.svg
For more information, please call (212) 334-1989 or (212) 219-9877.
------------------------
華人英數補習學院
Report Card
Name:______
Class:______
Year:____    []spring  []summer  []fall
------------------------

----------------------------------
[vimrc 11-14-2022]:
function! ToLearning() abort

"sdfsdf
"sdfsdf
"sdfsdf


"sdfsdf

    let line = getline('.')
    if Test(line, '^[/#"]')
        ec 'hi'
        let indexes = FindUpDownIndexes('^[^/#"]', '^[^/#"]')
        ec indexes
        return 
    endif
    let [a,b] = GetCodeIndexes()
    let r = '^(const|class|def|(async )?function) '
    let c = FindLineIndex(r, b + 1, 1)
    call Assert(c > -1)
    let lines = GetLines([a, c - 1])
    while 1
        if GetLast(lines) == ''
            call remove(lines, -1)
            let c -= 1
        else
            break
        endif
    endwhile
    call _WriteFile(g:txtdir . 'code.learning.txt', PadLinesWithNameAndDate(lines), 'a')
    call DeleteBlock([a, c])
endfunction
----------------------------------
[class.js 11-14-2022]:
//console.log(magic.join('hi', [['bye\nbb', 'hi', 'vv'], 's\nbb'], 'dd'))
----------------------------------
[class.js 11-14-2022]:

//test_html_string_builder()
//OX2 (where the parsers are stored) for config2
//setupStyleObject(); console.log(createAttributes(STYLIST_REF, {bold: true, color: 'red'}, Object));
----------------------------------
[class.js 11-14-2022]:


//console.log(BUILD_CODE_LIBRARY([getTextFactory, mergeAssign]))
----------------------------------
[class.js 11-14-2022]:
var TestSuiteEvalItems = [
    "permute(abclist.concat('d'), 2)",
    "(new (Classroom)).generateGradingPartners()",
    "There are $a total students. The ratio of boys to girls is $b to $c. How many girls are there?" 
]
----------------------------------
[class.js 11-14-2022]:
const BLETokenizeSVGConfig = {
    config: {
        emptyLineHasPrevSpaceValue: true,
        smartDedent: true,
    },
    setup() {
        this.parse = makeRunner([
            isNull,
            (x) => {
                return
            },
            /^\w+$/,
            (x) => {
                return {
                    tag: x,
                }
            },
            /./,
            htmlLineParser,
        ])
    },
    onReset() {
        this.context = new StateContext()
        this.root = this.context
        this.temp = []
    },
        attributer() {
        if (exists(this.temp)) {
            const attrs = htmlAttrObject(this.temp)
            const state = getLast(this.context.children)
            addProperty(state, 'attrs', attrs)
            this.temp = []
        }
    },
    onReturn() {
        this.attributer()
        const firstTag = this.root.children[0].tag
        if (firstTag != 'svg') {
            const newRoot = new StateContext(this.root)
            newRoot.tag = 'svg'
            let attrs = transformSvgAttrs(this.topAttrs)
            Object.assign(newRoot, attrs)
            this.root.children.forEach((child, i) => {
                child.$parent = newRoot
            })
            newRoot.children = this.root.children
            this.root.children = [newRoot]
        }

        const p = this.root.toJSON()

        if (p.children.length > 1) {
            if (!p.staticClass) {
                p.staticClass = 'app'
            }
            return p
        } else {
            return p.children[0]
        }
    },
        /** 2 **/
    parser(s) {
        let spaces = this.spaces
        let m

        if (m = search(startingLineConfigRE, s || '')) {
            this.temp.push(m)    
            return 
        }
        if (spaces > this.lastSpaces) {
            this.attributer()
            this.context = this.context.enter()
        }
        else if (spaces < this.lastSpaces) {
            //this.attributer()
            let n = (this.lastSpaces - spaces) / 4
            try {
                this.context = this.context.exit(n)
            } catch(e) {
                console.log(n)
               //console.log(this.context)
                throw ''
            }
        }

        const data = this.parse(s)
        this.context.add(data)
        this.lastSpaces = spaces
    },
}
----------------------------------
[class.js 11-14-2022]:
const BLETokenizeHTMLConfig = {
        config: {
            //skipEmptyLines: true,
            emptyLineHasPrevSpaceValue: true,
            smartDedent: true,
        },
        setup() {
            this.parse = makeRunner([
                isNull,
                (x) => {
                    return {
                        staticClass: 'br'
                    }
                },
                /^\w+$/,
                (x) => {
                    return {
                        staticClass: x,
                        value: x,
                    }
                },
                /./,
                htmlLineParser,
            ])
        },
        onReset() {
            this.context = new StateContext()
            this.root = this.context
        },
        onReturn() {
            const p = this.root.toJSON()
            if (p.children.length > 1) {
                if (!p.staticClass) {
                    p.staticClass = 'app'
                }
                return p
            } else {
                return p.children[0]
            }
        },
            /** 2 **/
        parser(s) {
            let spaces = this.spaces

            if (spaces > this.lastSpaces) {
                this.context = this.context.enter()
            }
            else if (spaces < this.lastSpaces) {
                let n = (this.lastSpaces - spaces) / 4
                this.context = this.context.exit(n)
            }

            this.context.add(this.parse(s))
            this.lastSpaces = spaces
        },
}
    
----------------------------------
[class.js 11-14-2022]:
var HtmlLineParserConfigItems = [
    /* deprecated 
     * this has been completely replaced by the OX2 parser-set.
     * */
    /\.(\w+)/,
    function (m) {
        return ['class', m]
    },

    /:(\w+)/,
    function (m) {
        return [':' + m, m]
    },
    /(style|for|s)\((.*?)\)/,
    function (a, b) {
        if (a == 's') a = 'style'
        if (a == 'for') a = 'v-for'
        const ref = {
            'style': inlineStyleParser,
            'for': inlineForParser,
        }
        return [a, ref[a](b)]
    },
    configRE,
    inlineAttributeParser,
]
----------------------------------
[class.js 11-14-2022]:
function deppedoldhtmlLineParser(s) {
    let t
    let [s1, config] = mconfig(s, htmlLineConfigRE)
    config = transformObjectKeys(config, vmap)
    let [className, ...items] = split(s1)
    let text = ''
    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        let ref = htmlmap[item]
        if (ref) {
            if (isObject(ref)) {
                Object.assign(config, htmlmap[item])
            } else {
                config[ref[0]] = parseString(ref[1])
            }
        } else {
            text = items.slice(i).join(' ')
            break
        }
    }

    return {
        staticClass: className,
        attrs: config,
        value: text || className,
    }
}
----------------------------------
[vimrc 11-15-2022 WriteCodeNotes]
----------------------------------
[class.js 11-15-2022 fractionAddsToOne]
There are a few elements at play.
Subtraction should work as well.

A lot of the math stuff revolves around gcd and lcd.
The answer is always 1 ... maybe there is a way to make it higher.
Make the answer 1.5 or 2 or 2.5.
----------------------------------
[class.js 11-16-2022]:
class Spellcheck {
    static spellcheck(s, dict) {
        const spell = new Spellcheck('oneToExclam', 'dedent')
        spell.load(dict)

        s = s.replace(/([a-zA-Z])1(?= |$|\n)/g, '$1!')
        const p = spell.spellcheck(s)
        //console.log(p); throw '';
        return p
    }
    load(dict) {
        if (dict) {
            this.dict = dict
        }
        if (!this.dict) {
            this.dict = require(this.file)
        }
        if (!this.regex) {
            this.regex = reWrap(this.dict, 'pgr')
        }
    }
    run(s) {
        this.load()

        for (let parser of this.parsers) {
            s = parser(s)
        }
        return s
    }
    constructor(...keys) {
        this.file = '/home/kdog3682/JSONS/words.json'
        this.parsers = [trim, this.spellcheck.bind(this)]

        for (let key of keys) {
            this.parsers.push(this[key])
        }
    }
    save(s) {
        let r = /^(\w+) (\w+) *$|^(\w+ \w+) (.+) *$/gm
        let m = findall(r, s)
        let dict = m.reduce((acc, [a, b, c, d], i) => {
            if (a) {
                if (a in this.dict) {
                    console.log('has it', a)
                    return acc
                }
                acc[a] = b
            } else if (c) {
                if (c in this.dict) {
                    console.log('has it', c)
                    return acc
                }
                acc[c] = d
            }
            return acc
        }, {})

        write(this.file, merge(this.dict, dict))
    }
    spellcheck(s) {
        return s.replace(this.regex, (x, offset, o) => {
            if (/[.\'\"]/.test(o.charAt(offset - 1))) {
                return x
            }
            return this.dict[x] || x
        })
    }
    oneToExclam(s) {
        return s.replace(/([a-zA-Z])1/g, '$1!')
    }
    dedent(s) {
        return s.replace(/^ */gm, '')
    }
}
----------------------------------
[class.js 11-21-2022]:
function mix(superclass) {

    /* 
     * https://justinfagnani.com/2015/12/21/real-mixins-with-javascript-classes/
     * */
    class MixinBuilder {
      constructor(superclass) {
        this.superclass = superclass;
      }

      with(...mixins) {
        return mixins.reduce((c, m) => m(c), this.superclass)
      }
    }

    return new MixinBuilder(superclass)
}
----------------------------------
[class.js 11-25-2022]:
function learningwriteProperty(state, ...a) {
    switch (a.length - 1) {
        case 1:
            state[a[0]] = a[1]
            break
        case 2:
            state[a[0]][a[1]] = a[2]
            break
        case 3:
            state[a[0]][a[1]][a[2]] = a[3]
            break
        case 4:
            state[a[0]][a[1]][a[2]][a[3]] = a[4]
            break
        case 5:
            state[a[0]][a[1]][a[2]][a[3]][a[4]] = a[5]
            break
    }
    return state
}
----------------------------------
----------------------------------
[redditscript.py 11-28-2022]:
def oldreddit(mode="reply"):
    def _ask(subreddit, title, body):
        return reddit.subreddit(subreddit).submit(
            title, body
        )

    def getRedditQuestions(s):
        s = read(toRoot("reddit-questions.txt"))
        matches = re.findall("(\w+) (.+)\n+([\w\W]+)", s)
        return [
            {
                "subreddit": env.subredditmap.get(
                    m[0], m[0]
                ),
                "title": m[1],
                "body": m[2],
            }
            for m in matches
        ]

    def ask():
        success = _javascript("prepare-reddit.js")
        if not success:
            print("error")
            return
        # questions = read(
        # "/home/kdog3682/CWF/public/questions.json"
        # )
        questions = getRedditQuestions()
        prompt(questions)
        pprint(map(questions, lambda x: _ask(**x)))
        # clear('/home/kdog3682/CWF/questions.txt')

    def _getPosts(subreddit, mode="new", limit=None):
        if subreddit == "me":
            user = reddit.redditor(env.redditusername)
            posts = list(user.submissions.new(limit=limit))
            print("returning posts")
            return posts

        return list(
            getattr(reddit.subreddit(subreddit), mode)(
                limit=limit
            )
        )

    def getPosts(
        subreddit, mode="new", limit=None, today=0
    ):
        print(today)
        f = (
            lambda x: isRecent(int(x.created), days=1)
            if today
            else 0
        )
        posts = _getPosts(subreddit, mode, limit)
        posts = filter(posts, f)
        print((len(posts)))
        return posts

    def getComments(post, mode="all"):
        post.comments.replace_more(limit=None)
        return (
            post.comments
            if mode == None
            else post.comments.list()
        )

    def getResponses():
        store = []
        posts = getPosts("me", limit=10, today=True)
        print(len(posts))
        for post in posts:
            print(post)
            for c in getComments(post, "all"):
                if c.likes:
                    print("i liked it")
                    continue
                if len(c.body) < 10:
                    print("short body")
                    continue
                if test("\\bbbot\\b", c.body, flags=re.I):
                    print("is bot")
                    continue
                if test(
                    "bot|AutoModerator",
                    str(c.author),
                    flags=re.I,
                ):
                    print("is mod")
                    continue
                store.append([post.title, c])
        return store

    def reply():
        for title, comment in getResponses():
            print(title)
            author = str(comment.author)
            body = str(comment.body)
            answer = prompt(title, author, body)
            comment.upvote()
            if answer:
                comment.reply(answer)
        print("done replying")

    from praw import Reddit

    reddit = Reddit(**env.redditinfo)
    reddit.validate_on_submit = True
    if mode == "ask":
        ask()
    elif mode == "reply":
        reply()
    elif mode == "reply":
        reply()
    elif mode == "reply":
        reply()
    else:
        ask()
        reply()


    from praw import Reddit


import praw
----------------------------------
[class.js 11-28-2022]:

//clip(katexLongDivision(345, 4))
//console.log(katexVerticalArithmetic([12345, 6006, 54, 67823]))
----------------------------------
[class.js 11-28-2022]:

//s = writeProperty({props: {a: 3}}, 'props', 'value', {a:3})
//s = writeProperty(s, 'props', 'value', 'b', 'c')

//console.log(rectangularGridClass('ho', 5))
//css = gridClass('aa/bc', 'ho')
//css.defaults()
//css.colors()
//css.borderize()
//pprint((css.toString()))
/*
----------------------------------
[class.js 11-28-2022]:
function addCssUnits(k, v) {
    if (!v) return v
    if (k == 'content') {
        return singleQuote(v)
    }
    let regex = /wid|hei|mar|pad/
    let defaultUnit = regex.test(k) ? 'px' : ''
    return v + defaultUnit
}
----------------------------------
[class.js 11-28-2022]:
function justQuestion(x) {
    if (isArray(x)) {
        if (x[0].question) {
            return x.map((x) => x.question)
        }
        return x
    }
    if (x[0].question) {
        return x.question
    }
    return x
}
----------------------------------
[class.js 11-29-2022]:

//let sp = createStyleParser({debug: true})
/* sp kind of acts like an external import */
//new CSSPage(cssString1129)

//x = Object.entries(d).reduce((acc, [a,b]) => {
//}, [])
----------------------------------
[class.js 11-29-2022]:

//s = 'asdf = asdf sadf asdf, asdfasdf(asdfadf)'
//console.log(getCommaConfig(s)); throw '';
----------------------------------
[class.js 11-30-2022]:
function cssObjectFixer(o) {
    const f = (v) => {
        if (isNumber(v)) {
            return v + 'px'
        }
        return v
    }
    return transformObject(o, f)
}
----------------------------------
[class.js 11-30-2022]:
function rectangularGridClass(name, n) {
    let gtc = Math.floor(Math.sqrt(n))
    let css = new CSSObject(name)
    let gtcString = '1fr '.repeat(gtc).trim()

    css.set('grid')
    css.set('grid-template-columns', gtcString)

    return gtcString
}
----------------------------------
[class.js 11-30-2022]:
function gridClass(s, name) {
    const items = split(s, /, *|  +|\/ */)
    assert(items.length > 1)
    const uniqueLetters = getUniqueLetters(s)
    const longest = getLongest(items, len, Number)

    function runner(s) {
        let letters = split(s, '')
        if (letters.length == longest) {
            return letters
        } else {
            return fillTo(letters, longest)
        }
    }

    const store = items.map(runner)

    let css = new CSSObject(name || s)
    let gta = joinSpaces(
        store.map((x) => singleQuote(x.join(' ')))
    )
    let gtc = '1fr '.repeat(longest).trim()

    css.set('grid')
    css.set('grid-template-areas', gta)
    css.set('grid-template-columns', gtc)

    for (let letter of uniqueLetters) {
        let child = css.appendChild()
        child.set('grid-area', letter)
    }
    return css
}
----------------------------------
[class.js 11-30-2022]:
var cssMapAliases = {
    newlines: {
        name: 'marginBottom',
        transform(s) {
            return toPixels(s, (x) => x * 10)
        },
    },
    italic: {
        name: 'font-style',
        value: 'italic',
    },
    padding: {
        name: 'padding',
        transform(o) {
            if (isNumber(o)) {
                return map(4, () => toPixels(o)).join(' ')
            }
            let paddings = {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
            }
            let payload = Object.assign({}, o, paddings)
            return Object.values(payload)
                .map(partial(toPixels))
                .join(' ')
        },
    },

    margin: {
        name: 'margin',
        transform(o) {
            if (isNumber(o)) {
                return magic.map(4, o + 'px').join(' ')
            }
            let margins = {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0,
            }
            let payload = Object.assign({}, margins, o)
            return Object.values(payload)
                .map(partial(toPixels))
                .join(' ')
        },
    },

    bold: {
        name: 'font-weight',
        transform(s) {
            switch (s) {
                case true:
                    return 'bold'
                case false:
                    return 'normal'
                default:
                    return s
            }
        },
    },
}
We deprecate this because STYLE_MASTER is stronger.
----------------------------------
[class.js 11-30-2022]:
function isStandardHtml(s) {
    const natives = [
        //'html',
        //'main',
        'body',
        'div',
        'p',
        'a',
        'section',
        'iframe',
        'ul',
        'li',
        'header',
        'footer',
    ]
    return natives.includes(s)
}

deprecate
----------------------------------
[class.js 11-30-2022]:
function isStandardHtml(s) {
    const natives = [
        //'html',
        //'main',
        'body',
        'div',
        'p',
        'a',
        'section',
        'iframe',
        'ul',
        'li',
        'header',
        'footer',
    ]
    return natives.includes(s)
}
----------------------------------
[print.js 11-30-2022]:
async function main(file, outpath, windowData, options) {
    options = assignFresh(options, defaultLayoutOptions)
    const browser = await initBrowser()
    const page = await browser.newPage()
    await windowSet(page, 'puppeteer', true)
    await windowSet(page, windowData)

    if (options.window) {
        await windowSet(page, options.window)
    }

    await page.goto(localPath(file), {
        waitUntil: 'networkidle2',
    })

    if (options.css) await addCssFileFromDownloads(page, url)

    await printPdf(page, outpath, options)

    await page.close()
    await browser.close()
}
----------------------------------
[dep.js 11-30-2022]:
class Classroom2 {
    syncState(state) {
        syncState(this.mt, state)
        syncState(this.qg, state)
    }
    static debug(x, state, debug = 1) {
        const room = new Classroom2(sat9am)
        room.debug = debug
        room.syncState(state)
        if (!isArray(x)) x = [x]
        const payload = room.run(x)
    }
    static simple(...args) {
        const room = new Classroom2(sat9am)
        room.debug = 'simple'
        const payload = room.run(...args)
        return payload
    }

    static create(classRoom, ...questionArrays) {
        const room = new Classroom2(classRoom)
        const payload = room.run(...questionArrays)
        console.log(payload)
    }

    constructor(studentObjectArray) {
        this.students = studentObjectArray
        this.config = {
            numberOfQuestions: 20,
        }

        this.mt = new MathTemplater({
            studentNames: this.students.map((x) => x.name),
            enforceLength: this.config.numberOfQuestions,
        })

        //this.qg = new QuestionGenerator()
        //this.worksheet = new MathWorksheet()
        //this.lettermaker = new LetterInfusion()
    }

    load(student) {
        this.worksheet.reset()
        this.syncState({ level: student.level })
        this.lettermaker.load(
            student.name,
            this.config.numberOfQuestions
        )
    }
    run(...args) {
        console.log(this.makeTransaction)
        console.log(this.qg)
        throw ''
        const runner = (student) => {
            //this.load(student)

            const items = flat(
                args.filter(exists).map((arg) => {
                    return questionmaker2(arg, this.mt, this.qg)
                })
            ).filter(exists)

            if (this.debug == 1) debugit(items)
            if (this.debug == 'simple') {
                return items.map((x) => x.question)
            }

            const payload = items.map(
                ({ question, answer }) => {
                    return this.worksheet.maker(
                        question,
                        answer,
                        this.lettermaker.next()
                    )
                }
            )

            const value = {
                questions: payload,
                name: student.name,
                templateWords: this.lettermaker.templateWords,
            }

            if (this.debug === 2) {
                tl(value)
            }

            return value
        }

        return this.students.map((student) => runner(student))
    }
}
----------------------------------
[dep.js 11-30-2022]:
class Classroom {
    static getStudents(key = 'name', sort = 0) {
        let names = unique(flat(Object.values(g4studentNames)))
        if (key == 'name') {
            return names.map(getFirstWord)
        }
    }
    constructor() {
        this.students = normRead('students.json')
    }
    getStudentNames(key = 'name') {
        return map(this.students, key)
    }
}
----------------------------------
[archive.js 11-30-2022]:
function itemsFromMeasurements(
    // 10-10-2022 
    obj,
    heights,
    {
        margin = 20,
        padding = 0,
        threshold = 100,
        heightFactor = 1,
        layout = 'default',
    } = {}
    ) {
    const items = obj.children
    assert(items.length == heights.length)

    let storage = new Storage()
    let count = 0
    let h = 0

    for (let i = 0; i < heights.length; i++) {
        let height = Math.round(heights[i])
        h += margin
        if (h + height * heightFactor > threshold) {
            console.log('incrementing count', h)
            count++
            h = height
        } else {
            h += padding + height
        }

        storage.add(count, items[i])
    }

    const partitions = Object.values(toJSON(storage))

    const pages = partitions.map((a, i) => {
        /*
         * "a" represents a set of children.
         * there is no wrapper on it.
         * concieveably, you dont need a wrapper.
         * because it just gets slotted in.
         * */

        return {
            component: 'DocPage',
            children: {
                body: a,
                footer: {
                    component: 'DocFooter',
                },
            },
        }
    })

    console.log(pages)
    return pages

    /*  */
}
----------------------------------
[archive.js 11-30-2022]:
class VueSimpleRenderer {
    constructor(state) {
        this.current = []
        this.state = state
        this.h = state.$createElement
        this.components = {
            'hr': DocLine,
        }
    }
    _renderDefaultSlot(key) {
        let slot = this.state.$scopedSlots.default
        if (slot) {
            const options = {staticClass: vueName(this, key)}
            return this.h('div', options, [slot])
        }
    }
    render(key) {
        const node = this._render(key)
        this.current.push(node)
    }

    _render(key) {
        if (isArray(key)) {
            const options = {staticClass: vueName(this)}
            return this.h('div', options, key.filter(exists))
        }

        if (this.components[key]) {
            return this.h(this.components[key])
        }

        if (this.state.hasOwnProperty(key)) {
            const options = {staticClass: vueName(this, key)}
            return this.h('div', options, this.state[key])
        }
    }
}
----------------------------------
[archive.js 11-30-2022]:
var DocMeasure = {
    name: 'DocMeasure',
    props: ['value', 'layout'],
    data() {
        return {
            measurements: null,
        }
    },

    render(h) {
        const items = this.newItems || this.value
        return renderAnything(this, items)
    },

    async mounted() {
        await sleep(400)
        const measurements = takeMeasurements(this.$el)
        const newItems = itemsFromMeasurements(
            this.value,
            measurements
        )
        //this.newItems = newItems
    },
}
----------------------------------
[useful-references.js 11-30-2022]:
var keyListenerForInteractive = {
    right() {
        console.log(this.index)
        this.index =
            modularIncrementFn(this.items, this.index, notDone, 1, Number)
        console.log(this.index)

    },
    left() {
        this.index =
            modularIncrementFn(this.items, this.index, notDone, -1, Number)
    },
    del() {
        this.s = backspace(this.s)
    },
    space() {
        this.s += ' '
    },
    esc(s) {
        this.s = ''
    },
    ctrlD() {
        console.log('ctrld has been activated')
        const value = {
            regexes: this.regexes,
            saved: this.items.map((x) => x.index),
        }
        //setClipboard(value)
        download('inbound-data.json', value)
        /* represents the items that were saved */
    },
    enter() {
        if (!this.s) {
            this.item.done = !this.item.done
            this.index++
            return 
        }

        const regex = RegExp(this.s)
        let count = 0
        this.items.forEach((item) => {
            if (test(regex, item.value)) {
                item.done = true
            } else {
                count++
            }
        })
        this.count = count
        this.index =
            modularIncrementFn(this.items, this.index, notDone, 1, Number)
    },
    enter1() {
        switch (this.s) {
            case '': 
                this.item.done = !this.item.done
                this.index++
                return 
        }

        const regexString = this.s
        const regex = RegExp(regexString)
        const filtered = this.items.filter((x) => {
            return antiTest(regex, x.value)
        })

        //this.saved.push(...filtered.map((x) => x.index))
        if (filtered.length == this.items.length) {
            return
        }
        this.regexes.push(regexString)
        this.items = filtered
        this.index = 0
        this.s = ''
    },
    fallback(k) {
        this.s += k
    },
}
----------------------------------
[useful-references.js 11-30-2022]:
var InteractiveApp = {
    name: 'InteractiveApp',
    /* the template needs pug3 */
    xtemplate: `
        keyboard-input(s)
        container
            count('Number of items Remaining: $count')
            index-item(item)
    `,
    render(h) {
        const r = new VueRenderer(this)
        const Input = r.renderKeyboardInput()
        const Main = r.renderIndexItem()
        return r.renderWrapper(Input, Main)
    },
    data() {
        return {
            count: 0,
            index: 0,
            regexes: [],
            saved: [],
            item: null,
            //item: outboundData[0],
            //items: outboundData,
            item: thomasHyunSAT[0],
            items: thomasHyunSAT,
            regexes: [],
            s: '',
        }
    },
    mounted() {
        windowListener({
            state: this,
            ...keyListenerForInteractive,
        })
        
    },
}
----------------------------------
[useful-references.js 11-30-2022]:
var ConsoleApp = {
    name: 'ConsoleApp',
    props: ['show'],
    data(s) {
        return {
            console: [],
        }
    },
    render(h) {
        if (!this.show) return 
        const items = this.console.map((item, i) => {
            return ['console-item', item]
        })
        return renderWrapper(this, items)
    },
    created(s) {
        console.log('creating the console')
        console.log = (...args) => {
            if (args.length == 1) {
                this.console.push(args[0])
            } else {
                this.console.push(joinString(args))
            }
        }
        console.log('new console has been created')
    },
}
----------------------------------
[render.js 11-30-2022]:
const quizcjuly2022 = {
    template: `
        <div class="app-root-container">
            <transition name="fade" mode="out-in">
                <component :class="cc" :is="cc" 
                    :item="item" :questionIndex="questionIndex">
                </component>
            </transition>
        </div>
    `,
    data() {
        return {
            questionIndex: 0,
        }
    },
    computed: {
        item() {
            return this.items[this.questionIndex]
        },
    },
    created() {
        this.controller = new QuizController(this)
        this.items = [
            {
                guidedinputc: mgc, notes: ['howdy howdy', 'asdfadf'], title: 'fill in the table',
                //animations: {duration: 10000, timeline: cshtimeline()},
            },
            {'guidedinputc': '[1] + [2] = 344', notes: 'howdy howdasdfasdfy'},
            {'guidedinputc': '[1] + [2] = 444344', notes: 'howdy howdasdfasdfy'},
        ]
    },
}
[class.js 12-01-2022]:
function trackProgress() {

    setupNode()
    let file = '/home/kdog3682/CWF/public/class.js'

    date = new Date()
    if (date.getHours() < 18) {
        return 
    }
    console.log(date.getHours()); throw '';
    date1 = incrementDate(date, -1)
    date2 = incrementDate(copyDate(date1), 1)
    let r = dateSplitRE(date1, date2)
    let text = search(r, lastQuarter(read(file)))
    let data = getBindingNames(text)
    let stamp = datestamp(date1) + ' - ' + datestamp(date2)
    assert(data)
    let s = magic.join(stamp, data)
    console.log(s)
    normAppend('daily-code-progress.log', s)
}

to python
----------------------------------
[app-main.js 12-03-2022]:
function foo1(doc, body) {
    var styleCell1 = {};
        styleCell1[DocumentApp.Attribute.FONT_SIZE] = 20;
        styleCell1[DocumentApp.Attribute.HORIZONTAL_ALIGNMENT] = DocumentApp.HorizontalAlignment.CENTER;
        styleCell1[DocumentApp.Attribute.FOREGROUND_COLOR]='#888888';
        styleCell1[DocumentApp.Attribute.FONT_FAMILY]='Roboto';
    
        var styleCell = {};
        styleCell[DocumentApp.Attribute.FONT_SIZE] = 18;
        styleCell1[DocumentApp.Attribute.FOREGROUND_COLOR]='#000000';
        styleCell[DocumentApp.Attribute.HEADING] = DocumentApp.ParagraphHeading.HEADING1;
        styleCell[DocumentApp.Attribute.FONT_FAMILY]='Roboto';
    
        var cells = [
          ['hi', 'bye']
        ];
    
        table = body.appendTable(cells);
    
        table.getRow(0).editAsText().setBold(true);
        table.getRow(0).getCell(1).setAttributes(styleCell);
        table.getRow(0).getCell(0).setWidth(59);
        table.getRow(0).getCell(0).setAttributes(styleCell1);
        //foo2(doc, body, table)
}
----------------------------------
[app-main.js 12-03-2022]:
function foo2(doc, body, table) {
    const index = body.getChildIndex(table);
    logger(index)
    const documentId = doc.getId();
    //const tableStart = Docs.Documents.get(documentId).body.content[index + 1].startIndex;
    var tableStart = 1
    const tempStyle = {width: {magnitude :0, unit: "PT"}, dashStyle: "SOLID", color: {color: {rgbColor: {blue: 0}}}};
    const resource = {requests: [
      {updateTableCellStyle: {
        tableStartLocation: {index: 1},
        tableCellStyle: {borderTop: tempStyle, borderBottom: tempStyle, borderLeft: tempStyle, borderRight: tempStyle},
        fields: "borderTop,borderBottom,borderLeft,borderRight"
      }},
      {updateTableCellStyle: {
        tableRange: {
          tableCellLocation: {tableStartLocation: {index: tableStart}, rowIndex: 0, columnIndex: 0}, rowSpan: 1, columnSpan: 1},
          tableCellStyle: {
            borderRight: {dashStyle: "SOLID", width: {magnitude: 3, unit: "PT"}, color: {color: {rgbColor: {red: 1}}}}
          },
          fields: "borderRight"
      }}
    ]};
    Docs.Documents.batchUpdate(resource, documentId);
    
}
----------------------------------
[ga.py 12-06-2022]:
def messageWithAttachment(sender, to, subject, message_text_plain, message_text_html, attached_file):
    """Create a message for an email.

    message_text: The text of the email message.
    attached_file: The path to the file to be attached.

    Returns:
    An object containing a base64url encoded email object.
    """

    ##An email is composed of 3 part :
        #part 1: create the message container using a dictionary { to, from, subject }
        #part 2: attach the message_text with .attach() (could be plain and/or html)
        #part 3(optional): an attachment added with .attach()

    ## Part 1
    message = MIMEMultipart() #when alternative: no attach, but only plain_text
    message['to'] = to
    message['from'] = sender
    message['subject'] = subject

    ## Part 2   (the message_text)
    message.attach(MIMEText(message_text_html, 'html'))
    #message.attach(MIMEText(message_text_plain, 'plain'))

    ## Part 3 (attachment)
    # # to attach a text file you containing "test" you would do:
    # # message.attach(MIMEText("test", 'plain'))

    #-----About MimeTypes:
    # It tells gmail which application it should use to read the attachment (it acts like an extension for windows).
    # If you dont provide it, you just wont be able to read the attachment (eg. a text) within gmail. You'll have to download it to read it (windows will know how to read it with it's extension).

    #-----3.1 get MimeType of attachment
        #option 1: if you want to attach the same file just specify it’s mime types

        #option 2: if you want to attach any file use mimetypes.guess_type(attached_file)

    my_mimetype, encoding = mimetypes.guess_type(attached_file)

    # If the extension is not recognized it will return: (None, None)
    # If it's an .mp3, it will return: (audio/mp3, None) (None is for the encoding)
    #for unrecognized extension it set my_mimetypes to  'application/octet-stream' (so it won't return None again).
    if my_mimetype is None or encoding is not None:
        my_mimetype = 'application/octet-stream'


    main_type, sub_type = my_mimetype.split('/', 1)# split only at the first '/'
    # if my_mimetype is audio/mp3: main_type=audio sub_type=mp3

    #-----3.2  creating the attachment
        #you don't really "attach" the file but you attach a variable that contains the "binary content" of the file you want to attach

        #option 1: use MIMEBase for all my_mimetype (cf below)  - this is the easiest one to understand
        #option 2: use the specific MIME (ex for .mp3 = MIMEAudio)   - it's a shorcut version of MIMEBase

    #this part is used to tell how the file should be read and stored (r, or rb, etc.)
    if main_type == 'text':
        print("text")
        temp = open(attached_file, 'r')  # 'rb' will send this error: 'bytes' object has no attribute 'encode'
        attachment = MIMEText(temp.read(), _subtype=sub_type)
        temp.close()

    elif main_type == 'image':
        print("image")
        temp = open(attached_file, 'rb')
        attachment = MIMEImage(temp.read(), _subtype=sub_type)
        temp.close()

    elif main_type == 'audio':
        print("audio")
        temp = open(attached_file, 'rb')
        attachment = MIMEAudio(temp.read(), _subtype=sub_type)
        temp.close()

    elif main_type == 'application' and sub_type == 'pdf':
        temp = open(attached_file, 'rb')
        attachment = MIMEApplication(temp.read(), _subtype=sub_type)
        temp.close()

    else:
        attachment = MIMEBase(main_type, sub_type)
        temp = open(attached_file, 'rb')
        attachment.set_payload(temp.read())
        temp.close()

    #-----3.3 encode the attachment, add a header and attach it to the message
    # encoders.encode_base64(attachment)  #not needed (cf. randomfigure comment)
    #https://docs.python.org/3/library/email-examples.html

    filename = os.path.basename(attached_file)
    attachment.add_header('Content-Disposition', 'attachment', filename=filename) # name preview in email
    message.attach(attachment)


    ## Part 4 encode the message (the message should be in bytes)
    message_as_bytes = message.as_bytes() # the message should converted from string to bytes.
    message_as_base64 = base64.urlsafe_b64encode(message_as_bytes) #encode in base64 (printable letters coding)
    raw = message_as_base64.decode()  # need to JSON serializable (no idea what does it means)
    return {'raw': raw}
----------------------------------
//// index2.js

const express = require('express')
const app = express()
const http = require('http').Server(app)
const port = process.env.PORT || 8000
const fs = require('fs')
const {read, write, append} = require('./node-utils.js')
initializeApp(app, http)
// ------------------------------------------ 

function initializeApp(app, http) {

    app.get('/', (req, res) => {
        console.log('hi dev started')
        res.send(text('sr.js'))
    })
    http.listen(port)
}

function text(file) {
    s = `<script>${read(file)}</script>`
    console.log(s)
    return s
}



//// runpy.js



const {spawn} = require("child_process")

module.exports.runPython = runPython


async function runPython(code) {

    let python = spawn('python3',['./runpy.py', code])
    let store = ''
    let done
    let id

    function onData(data) {
         store += data
    }

    function onClose(code, resolve) {
        let [a,b] = store.split('ERROR!')
        let value  =  code ?
            {result: a.trim(), error: b.trim()} :
            {result: store.trim(), error: 0}

        resolve(value)
    }

    return new Promise((resolve) => {
        python.stdout.on('data', onData)
        python.on('close', (code) => onClose(code, resolve))
    })
}

//runPython(s).then((x) => console.log(x))


//// go.js


wt is 
x + y = a     
x - y = a
x + y = -a
x - y = -a

//---------------------------

console.log(a)


sqrt 

sam does 15 minutes of math homework per day. He sleeps 8 hours every day.

what percent of sams wakeful hours are spent on math
wpo sams day is spent on math
// w...p... 
//
//
GRAPH


draggable: false
moving the shapes around ... 












---------------------------


;3graphs rngp15 rng15
//to make a circle, all u nd is a b2 point [h,k] and a b2 radius [r]

---------------------------
function interweave(a, b, n) {
    let s = ''
    for (let i = 0; i < n; i++) {
        if (i == n - 1) {
            s += a
        }
        else {
            s += a
            s += b
        }
    //}
    return s
}
function dynamicRegex(s) {
    s = 'b2'
    const [tag, repeat]  = splitNumberBoundary(s)
    return interweave('\\S+', ' ', repeat)
}

function run(s) {
    return schemaMatch(';$a', s)
}

/* the below can be logged */
/* eval takes into account lexicality */
/* the items below exist in the scope of the calling block */
//console.log(code)
//console.log(child)
//console.log(ce.lastFunction)


//// cl.js

function variableExtractor(fn) {
    let match
    let r = /= (\d*)x(?: [+-] (\d+))?$/
    if (match = search(r, fn)) {
        if (!match[0]) match[0] = 1
        if (!match[1]) match[1] = 0
        return match.map(Number)
    }

    if (test(/= \d*x(?: [+-] \d+)?$/, fn)) {
        return getNumbers(fn)
    }

    if (test(/\(\w [+-] \w\)\^2/, fn)) {
        return findall(/[+-] (\d+)|(\d)+$/g, fn).map(Number)
    }

    if (test(/[a-z]\^2/, fn)) {
        return [0, 0, Number(search(/\d+$/, fn))]
    }
}
function findCircleLineIntersections(r, h, k, m, n) {
    const a = 1 + Math.sqrt(m)
    const b = -h * 2 + m * (n - k) * 2
    const c = Math.sqrt(h) + Math.sqrt(n - k) - Math.sqrt(r)
    return quadratic(a, b, c)
}
function quadratic(a, b, c) {
    const d = Math.sqrt(b) - 4 * a * c
    if (d >= 0) {
        const intersections = [
            (-b + Math.sqrt(Math.sqrt(b) - 4 * a * c)) / (2 * a),
            (-b - Math.sqrt(Math.sqrt(b) - 4 * a * c)) / (2 * a),
        ]
        if (d == 0) {
            return [intersections[0]]
        }
        return intersections
    }
    return []
}

function radiusOfCircleFromTwoPoints(a, b) {
    let [x1, y1] = a
    let [x2, y2] = b
    return Math.sqrt( Math.pow((x1-x2), 2) + Math.pow((y1-y2), 2) )
}

//---------------------------
//import math-utils
//console.log(radiusOfCircleFromTwoPoints([1,1], [4,5]))
//console.log(findCircleLineIntersections(1, 0, 0, 1, 0))
//console.log(findCircleLineIntersections('y = x', 'x^2 + y^2 = 1'))
//console.log(findCircleLineIntersections( 'x^2 + y^2 = 1', 'y = x'))
//runtests 
//fasterTosee
//missingParentheses
// what did i do so far?
// typing away.


//// .js



function toModuleExports(items) {
    const moduleExports =
        '\n' + join(toArray(items).map((x) => `module.exports.${x} = ${x}`))
    return moduleExports
}




function toModuleImports(path, items) {
    return `${brackify(
        'var',
        toArray(items).map(addf(','))
    )} = require("${fixFilePath(path)}")`
}




//// school-utils.js

function namePassWordDecipher(name) {
    //school
    const length = name.length
    return name.split('').map(x => {
        let n = char2n(x) - length
        if (n < 0) n += 26
        return n2char(n)
    }).join('').toUpperCase()
}

function calculateGradeFromStudentReference(student) {
    const year = (new Date()).getFullYear()
    const {startDate, grade} = ref[student]
    return grade + year - startDate
}

function namePassWordCipher(name) {
    //school
    const length = name.length
    return name.split('').map(x => {
        let n = char2n(x) + length 
        //console.log(n)
        if (n > 26) n -= 26
        n %= 26
        //console.log(n)
        const p = n2char(n)
        //console.log(p, 'p')
        return p
    }).join('')
}

function calculateGradeFromBirthYear(birthyear) {
    const [month, year] = getMonthAndYear()
    if (month < 6) year -= 1
    return year - 5 - birthyear
}


//// html-parser.js

function htmlParser(state, s, isOpening) {
    const defaultattrmap = {
        autofocus: '',
    }
    const divdict = {
        title: {
            class: 'title',
            tag: 'h3',
        },

        main: {
            tag: 'main',
            class: 'main',
        },
    }

    let attrs = []
    let text
    let item
    let rest
    let div = 'div'
    let className = ''
    let refName
    let tag = 'div'
    let doubleAttrs
    let singleAttrs
    if (!state.count) state.count = 0
    let containerClass = 'container-' + 100 + state.count++
    let isComponent

    if (test(/^\w\S+$/, s)) {
        if (s.includes('=')) {
            let [a, b] = split(s, '=')
            let div = 'div'
            if (a == 'for') {
                let arg = depluralize(b)
                let stuff = `(${arg}, index) in ${b}`
                className = toDashCase(arg) + '-item'
                return toOpeningTag('div', {
                    class: className,
                    'v-for': stuff,
                })
            }
        }
        if (s == 'div' || s == 'container') {
            return toOpeningTag(div, {
                class: containerClass,
            })
        }

        if (s == 'transition') {
            return toOpeningTag(s, {
                mode: 'out-in',
                name: 'fade',
            })
        }

        if (s == 'component') {
            return divify(s, {
                ':is': 'currentComponent',
            })
        }
        if (test(/^item\.\w+$/, s)) {
            let className = state.forArg
                ? state.forArg + '-' + toDashCase(s)
                : toDashCase(s)

            return divify('div', { class: className }, vueText(s))
        }

        return divify('div', { class: toDashCase(s) }, vueText(s))
        return toOpeningTag(div, { class: s })
    }

    ;[s, text] = mreplace(/\[(.*?)\]/, s)
    if (test(/^{/, text)) {
        text = text.replace(/\{{1,2}/, '{{').replace(/\}{1,2}/, '}}')
    }
    ;[item, rest] = splitonce(s)
    ;[item, tag] = mreplace(/^[.!@#]/, item)
    ;[rest, doubleAttrs] = mreplace(/(\S+?) *= *(\S+)/g, rest)
    singleAttrs = split(rest)
    let originalItem = item
    if (!doubleAttrs) doubleAttrs = []
    if (!singleAttrs) singleAttrs = []

    if (item == 'slot') {
        return ``
        singleAttrs = []
        div = 'ul'
    }

    if (item == 'for') {
        singleAttrs = []
        div = 'ul'
        let target = getLastWord(rest)
        className = target
        let arg = 'item'
        state.forArg = target
        let vfor = `${arg} in ${target}`
        attrs.push(['v-for', vfor])
    } else if (tag == '@') {
        le.componentName = item
        className = item + '-component'
    } else if (tag == '#') {
        div = item + '-component'
        className = item + '-component'
        isComponent = true
    } else if (item in divdict) {
        let ref = divdict[item]
        className = ref.class || ''
        div = ref.tag
    } else if (tag == '.') {
        div = 'div'
        className = item
    } else if (isStandardHtml(item)) {
        div = item
    } else if (test(/^item\.\w+$/, item)) {
        className = state.forArg
            ? state.forArg + '-' + toDashCase(item)
            : toDashCase(item)

        text = vueText(item)
        div = 'div'
    } else if (item) {
        div = 'div'
        className = item
        if (!isOpening) text = vueText(item)
    }

    for (let [attr, val] of doubleAttrs) {
        if (attr == 'class') {
            if (!className.includes(val)) className += ' ' + val
            continue
        }

        if (attr.startsWith(':')) {
            attrs.push([attr, val])
            continue
        }

        if (attr == 'key') {
            attrs.push([':key', val])
            continue
        }

        if (attr == 'show') {
            if (!test(/^(show|is)/, val) && !val.includes('.')) {
                val = 'show' + capitalize(val)
            }
            attrs.push(['v-show', val])
            continue
        }

        if (attr == 'for') {
            const b = depluralize(val)
            const c = pluralize(val)
            const stuff = `(${b}, index) in ${c}`

            if (isComponent) {
                attrs.push([':' + b, b])

                if (!attrs.find((x) => x[0] == ':key')) {
                    attrs.push([':key', 'index'])
                }
            }

            attrs.push(['v-for', stuff])
            continue
        }
        if (attr.startsWith('v')) {
            attr = attr.replace(/^v(?=\w)/, 'v-')
            attrs.push([attr, val])
            continue
        }

        if (vmap[attr]) {
            attr = vmap[attr]
            attrs.push([attr, val])
            continue
        }

        if (true) {
            attr = ':' + attr
            attrs.push([attr, val])
            continue
        }
    }

    //console.log(singleAttrs)
    for (let attr of singleAttrs) {
        if (attr.startsWith('@')) {
            if (attr == '@') {
                attrs.push([
                    '@' + toDashCase(originalItem),
                    toCamelCase('on' + capitalize(originalItem)),
                ])
                continue
            }

            let val = attr.slice(1)
            let value = toCamelCase(
                val.startsWith('on') ? val : 'on' + capitalize(val)
            )
            attrs.push(['@' + toDashCase(val), value])
            continue
        }
        if (attr.startsWith('.')) {
            let name = attr.slice(1)
            if (!className.includes(name)) className += ' ' + name
            continue
        }

        if (attr == 'style') {
            attrs.push([
                ':style',
                `computed${capitalize(originalItem)}Style`,
            ])
            continue
        }

        if (attr == 'show') {
            attrs.push([
                'v-show',
                toCamelCase('show-' + originalItem),
            ])
            continue
        }

        if (attr == 'for') {
            const a = getFirstWord(originalItem.toLowerCase())
            const b = depluralize(a)
            const c = pluralize(a)
            const stuff = `(${b}, index) in ${c}`
            attrs.push(['v-for', stuff])
            continue
        }

        if (attr == 'ref') {
            attrs.push(['ref', toCamelCase(originalItem)])
            continue
        }

        if (attr.startsWith('v')) {
            attr = attr.replace(/^v(?=\w)/, 'v-')
            attrs.push([attr, getFirstWord(originalItem)])
            continue
        }

        if (defaultattrmap[attr]) {
            attrs.push(...defaultattrmap[attr])
            continue
        }

        if (attr) {
            attrs.push([':' + toDashCase(attr), attr])
            continue
        }
    }

    //console.log([text, className])
    if (className) {
        className = fixClassName(className)
        attrs.push(['class', className])
    }
    let htmlPayload = divify(div, attrs, text)
    return isOpening
        ? toOpeningTag(div, attrs, isComponent /* force */)
        : htmlPayload
}

module.exports.htmlParser = htmlParser

function toOpeningTag(el, attrs = '', force) {
    if (el == 'html') return '<!doctype html><html>'

    if (isString(attrs)) {
        attrs = ' class=' + doublequote(attrs)
    } else if (attrs) {
        attrs = reduceToString(attrs, (a, b) => {
            return b ? ` ${a}="${b}"` : a
        })
    } else {
        attrs = ''
    }

    const suffix = hasHtmlSuffix(el, force) ? '>' : '/>'
    return '<' + el + attrs + suffix
}

function hasHtmlSuffix(el, force) {
    if (force) return true
    return closers.includes(el)
}

const closers = [
    'style',
    'pre',
    'script',
    'body',
    'ul',
    'li',
    'p',
    'textarea',
    'button',
    'section',
    'div',
    'h1',
    'h2',
    'h3',
    'main',
    'blockquote',
    'span',
    'article',
    'body',
    'html',
    'head',
    'template',
    'h4',
    'h5',
    'h6',
]

function divify(tag, attrs = '', x = '') {
    if (!x) x = ''
    let s = toOpeningTag(tag, attrs)

    if (
        isArray(x) ||
        (isString(x) && (hasNewline(x) || hasHtml(x)))
    ) {
        s += newlineIndent(x)
    } else {
        s += x
    }

    s += toClosingTag(tag)
    return s
}

function hasHtml(s) {
    return test(/<[a-z]/, s)
}

function toClosingTag(el) {
    if (closers.includes(el)) return '</' + el + '>'
    return ''
}

function vueText(s) {
    return '{{' + toCamelCase(s) + '}}'
}

function fixClassName(s) {
    s = s.trim()
    if (!s || test(/[A-Z]/, s)) return s
    const items = [
        'post',
        'get',
        'split',
        'set',
        'is',
        'has',
        'create',
        'component',
    ]
    const regex = ncg('^(?:$1)(?!(?:-|$))', items)
    return replace(regex, '$&-', s, '')
}



//// post.js

function randomColor(h, s, l, a = 1) {
    if (h == null) h = rng(0, 360)
    if (s == null) s = rng(42, 98)
    if (l == null) l = rng(40, 90)
    return `hsl(${h},${s}%,${l}%, ${a})`
}


//// waterfall.js



function waterfall3(items, callback) {
    let i = 0
    let length = items.length
    return new Promise((resolve) => {
        function runner(items) {
            function done() {
                i += 1
                if (i == length) {
                    return resolve()
                } else {
                    runner(items)
                }
            }
            const value = callback(items[i], i, done)
            if (isPromise(value)) {
                done()
            }
            /* somehow, the value gets looped in */
        }
        return runner(items)
    })
}




function waterfall(items, onTick, callback) {
    let id
    let i = 0
    let max = items.length
    let delay

    function runner(x) {
        let item = items[i++]
        //console.log(item)
        delay = item.delay || 1000
        onTick(item)
        if (i == max) {
            clearTimeout(id)
            setTimeout(() => {
                callback()
            }, delay + 250)
            return
        }
        id = setTimeout(() => {
            runner()
        }, delay)
    }
    runner()
}




function waterfall2(promises) {
    return promises.reduce((acc, promise, i) => {
        return acc.then(() => {
            return promise.then(() => {
                return true
            })
        })
    }, Promise.resolve([]))
}




function timeline(aa) {
    if (!isNestedArray(aa)) {
        aa = partition(aa, 2)
    }
    let index = 0
    let id
    function runner() {
        if (index == aa.length) {
            console.log('done')
            clearTimeout(id)
            return 
        }

        let item = aa[index]
        let [delayBefore, callback] = item
        id = setTimeout(() => {
            callback(index++)
            runner()
        }, delayBefore)
    }
    runner()
}




//// advanced-utils.js



function bindObject(state, object) {
    if (!exists(object)) {
        return
    }
    for (let [k, v] of Object.entries(object)) {
        if (isFunction(v)) {
            state[k] = v.bind(state)
        } else {
            state[k] = v
        }
    }
}




function initializeStateVariable(state, key, value) {
    if (!state.hasOwnProperty(key)) {
        state[key] =
            arguments.length == 4
                ? {}
                : key.endsWith('s')
                ? []
                : null
    }
    const f = type(state[key])
    switch (f) {
        case 'Set':
            return state[key].add(value)
        case 'Array':
            return state[key].push(value)
        case 'Object':
            return (state[key][arguments[2]] = arguments[3])
        default:
            state[key] = value
    }
}




function bind(state, fnKey) {
    return state[fnKey].bind(state)
}




function toggleVue(state, key, value, duration = 1000) {
    let from = state[key]
    let to = value
    toggle(state, key, from, to, duration)
}




function toggle(state, key, from, to, duration = 750) {
    let value
    if (arguments.length == 2) {
        value = !state[key]
        if (isBoolean(state[key])) state[key] = value
        return value
    }

    if (arguments.length == 3) {
        if (isFunction(state)) {
            return toggleFunction(...arguments)
        }
        if (isBoolean(state[key])) {
            from = state[key]
            to = !state[key]
            duration = arguments[2]
        } else {
            to = from
            from = state[key]
        }
    }

    state[key] = to
    setTimeout(() => {
        state[key] = from
    }, duration)
}




function stateCurryEnd(state, key, ...kwargs) {
    return function stateCurry(...args) {
        state[key](...args, ...kwargs)
    }
}




function stateCurryStart(state, key, ...kwargs) {
    return function stateCurry(...args) {
        return state[key](...kwargs, ...args)
    }
}




function exporter(state, key, ...args) {
    if (isClassObject(state)) {
        return state[key] && state[key].bind(state)
    }
    state = new state(...args)
    return state[key].bind(state)
}




function stateTrace(state, fnKey) {
    state[fnKey] = trace(state[fnKey].bind(state))
}




//// traash.js

function wrapFunction(state, key, fn) {
    const prev = state[key]
    state[key] = (x) => {
        fn.call(state, x)
        prev.call(state, x)
    }
}


//// quill-component.js

function CreateEditorView(selector) {
    const editor = new Quill(fixSelector(selector), {
        theme: 'snow',
    })


    for (let [k, v] of Object.entries(EditorCommands)) {
        defineProperty(editor, k, v)
    }

    autoFocus(editor)
    return editor
}


//// a2.js

//var { range, test, parseJSON, sorted, getLast, merge, isObject, exists, findall, toArgument, isFunction, isPrimitive, isString, ftest, isNumber, removeAllComments, search, assert, fixPath, fixPath, datestamp, write} = require('./utils.js')

var Abc1 = {
    name: 'Abc1',
    props: [''],
    render(h) {
        
    },
    mounted() {
        console.log('hi from Abc1')
    }
}

var Child = {
    name: 'Child',
    props: [''],
    render(h) {
        $left = renderSlot(h, 'left', 'left', {
            on: {
                click(e) {
                    console.log('hiiiiiii', e)
                },
            }
        })
        $right = renderSlot(h, 'right', 'right')
        $default = renderSlot(h, 'default', 'default')
        const children = [$left, $right, $default]
        return h(MyButton, {
            scopedSlots: {
                left(slotProps) {
                    return h('button', {
                       click: slotProps.onClick 
                    }, 'cccccc')
                }
            }
        }, children)
  },
}
var Abc = {
    name: 'Abc',
    props: [''],
    render(h) {
        return h('Child', {
            scopedSlots: {
                default(slotProps) {
                    return h(
                        'button',
                        {
                            on: {
                                click: slotProps.importedFunction,
                            },
                        },
                        'Do something'
                    )
                },
            },
        })
    },
    mounted() {
        console.log('hi from Abc')
    },
}
//\dfrac{1}{\left(\dfrac{2}{\left(\dfrac{3}{4}\right)}\right)}
//\dfrac{1}{\left(\dfrac{2}{\left(\dfrac{3}{\left(\dfrac{4}{\left(\dfrac{5}6\right)}\right)}\right)}\right)}\right)}\right)}
//
//\dfrac{1}{\left(\dfrac{2}{\left(\dfrac{3}{\left(\dfrac{4}{\left(\dfrac{5}{6}\right)}\right)}\right)}\right)}
t = "\dfrac{1}{\left(\dfrac{2}{\left(\dfrac{3}{\left(\dfrac{4}{\left(\dfrac{5}{6}\right)}\right)}\right)}\right)}"
s = "\dfrac{1}{\left(\dfrac{2}{\left(\dfrac{3}{\left(\dfrac{4}{\left(\dfrac{5}{6}\right)}\right)}\right)}\right)}"
//$\dfrac{\left(\dfrac{\left(\dfrac{2}{3}\right)}{2}\right)}{3}$


function dfrac(a, b) {
    let left = '\\left('
    let right = '\\right)'
    return `\\dfrac{${a}}{${left}${b}${right}}`
}

function refAndLength(n) {
    if (isNumber(n)) {
        n = range(n)
    }
    let length = n.length
    let ref = n
    return [ref, length]
}
function runnerUp(n = 10) {
    let [ref, length] = refAndLength(n)

    let s = '\\dfrac{\\left('.repeat(length - 2)
    s += `\\dfrac{${ref[0]}}{${ref[1]}}`
    for (let i = length - 2; i < length; i++) {
        let val = ref[i]
        console.log(val , 'hi')
        s += `\\right)}{${val}}`
    }
    return s
}

function runnerDown(n = 5) {
    let [ref, length] = refAndLength(n)
    let lefts = [ 'left', 'big', 'Big', 'bigg', 'Bigg' ]
    let rights = [ 'right', 'big', 'Big', 'bigg', 'Bigg' ]
    let s = ''
    for (let i = 0; i < length - 1; i++) {
        let val = ref[i]
        let next = ref[i + 1]
        //let left = lefts[i]
        let left = 'left'
        s += `\\dfrac{${val}}`
        s += i < length - 2 ? `{\\${left}(` : `{${next}}`
    }
    s += range(length - 2).map((i) => {
        return `\\right)}`
        return `\\${rights[i - 1]})}`
    }).join('')
    '\\right)}'.repeat(length - 2)
    return s
    return dollarWrap(s)
}

function dollarWrap(s) {
    return `$${s}$`
}


//write(runnerDown(a))


//// vue-file-loader.js

const FileReaderComponent = {
    mounted() {
        this.reader = new FileReader()
    },
    name: 'FileReaderComponent',
    template: `
        input type="file class="FileReader @change="onChange"/>
    `,

    methods: {
        onChange(e) {
            const file = e.target.files[0]
            this.reader.readAsText(file)

            const runner = () => {
                console.log(this.reader); throw ''
                return this.reader.result
            }

            const callback = (x) => {
                this.$emit('file-read', x)
            }

            if (isUtf(file)) {
                getAndGetAgain(runner).then(callback)
            }
        },
    },
}


//// todo.js

function scratch(s) {
    console.log('hiiiiiiii scratch')
}


s = `

title stages of my life (maybe)
Age 60+ : the game is coming to an end
Age 80+    : the game is coming to an end
---------------------------

it is using similar things...
statement label:content

function label(s) {
    return capitalize(s)
}
function content(s) {
    return periodify(s)
}

`


function foo(s) {
    let [a,b] = splitThePage(s)
    const store = []
    const lib = {}
    const ref = {
        periodify,
        capitalize,
        scratch,
    }
    getChunks(b).map((item, i) => {
        if (hasNewline(item)) {
            let name = getFunctionName(item)
            lib[name] = bringToLife(item, ref)
        }
        else {
            let [a,b] = splitonce(item)
            let value = [a, parse(b)]
            store.push(value)
        }
    })

    for (let [parent, [names, regex]] of store) {
        if (test(regex, a)) {
            let output = {}
            let m = findall(regex, a).map((item, i) => {
                for (let i = 0; i < names.length; i++) {
                    let name = names[i]
                    output[name] = (lib[name] || identity)(item[i])
                }
                return output
            })
            return m
        }
    }

    function parse(b) {
        b = removeSpaces(b)
        const items = split(b, /(\W)/)
        const iter = new Iter(items)
        let r = ''
        let names = []
        while (iter.next()) {
            if (iter.nextValue && !isWord(iter.nextValue)) {
                names.push(iter.value)
                r += `(.+?) *${iter.nextValue} *`
                iter.next()
                continue
            }
            else if (iter.size == iter.index) {
                r += '(.+)'
                names.push(iter.value)
            }
            else {
                console.log('gm'); throw ''
            }
        }
        return [names, r]
    }
}

function renderConsoleComponent(state, h, item) {
    /* can pass in additional stuff as necessary */

    return renderPre(h, item)

    //const H = hfactory(h)
    //return H(
    return runner(item)

    function runner(x, mode, depth = 0) {
        if (x == null) {
            return H('console-object-null', x)
        }
        if (isString(x)) {
            return H('console-object-string', x)
        }

        if (isNumber(x)) {
            return H('console-object-number', x)
        }

        if (isFunction(x)) {
            return H('console-object-function', x.name)
        }
            
        return H('console-object-pre', stringify(x))

        if (isArray(x)) {
            const $1 = x.map((item, i) => {
                return runner(item, Array, depth + 1)
            })

            if (mode == 'preview') {
                // 
                return H({
                    class: 'array-preview-item',
                    click() {
                        
                    }
                })
            }

            const items = x.map((item, i) => {
                return runner(item)
            })

            if (len(x) < 5) {
                return H('console-object-array', items)
            }

            const previewItems = x.slice(0, 5).map((item, i) => {
                return runner(item, 'preview')
            })
            const preview = H('array-preview', previewItems)
            return H('console-object-array', items, preview)
        }

        if (isObject(x)) {
            if (!exists(x)) {
                return H('empty-object')
            }
            if (allPrimitives(x)) {
                return H('pre', x)
            }

            const children = Object.entries(x).map(([a,b]) => {
                return [
                    H('object-key', a),
                    H('object-value', b),
                ]
            })
            const preview = Object.keys(x).slice(0, 5).map((item, i) => {
                return H('preview-item', item)
            })
            return H('object-wrapper', preview, children)
        }

        const name = x.constructor.name
        // smth that returns itself.
        return H('console-item-class-object', Name)
    }
}


//// calender.js


const VCalender = {
    template: `
        calender-grid
            header(weekdays)
            items(weeks)
            
    `,
    data() {
        return {
            ...dateInfo()
        }
    },
    methods: {
        callback({up, down, left, right, enter, escape}) {
            if (up) {
                this.pos += 1
            }
        },
    },
    mounted() {
        this.removeListener = keyListener(this, 'wasd-arrow-keys')
    },
    beforeDestroy() {
        this.removeListener()
    },
}

-------------------------------------------
[consolidate.py]
from test import *
from filesystem import *
from libra import *

def rpw(fn):
    def wrapper(inpath, outpath = None)
        value = fn(read(inpath))
        write(outpath or inpath, value)
    return wrapper


@rpw
def change_module(s):
    # actually it kind of doesnt work
    module = removeExtension(file)
    r = f"from \zs{module}\ze import \*"
    if test(r, s):
        return re.sub(r, newModule, s)


def fix_python(s):
    r = '"(.*?)\\zs' 
    rep = '(?<=' + x.group(1) + ')'

    r = \\ze(.*?)"'
    rep = '(?=' + x.group(1) + ')'




from filesystem import *
from test import *

def main(file):
    if getExtension(file) == 'js':
        regex = 'new \w+|\w\w\w+\.(?!log|toString)[a-z]\w+(?=\()'
    else:
        regex = 'new \w+|\w\w\w+\.(?!log|toString)[a-z]\w+(?=\()'

    matches = unique(re.findall(regex, read(file), flags=re.M | re.I))


    store = {}

    for match in matches:
        abrev = toAbrev(match)
        if store.get(abrev):
            prev = store.pop(abrev)
            print(prev)
            print(match)
            print('type X Y to determine new keys X and Y for the two items')
            a,b = input().split(' ')
            store[a] = prev
            store[b] = match
        else:
            store[abrev] = match

    print(store)

    output = ''

    for k,v in store.items():
        s = f"iab {k} {v}()<LEFT><C-R>=Eatchar('\s')<CR>"
        output += s + '\n'

    print(output)
    input("\ndo you wish to append this output to '/home/kdog3682/.vimrc'?")
    append('/home/kdog3682/.vimrc', output)



code = [ 'class asdfsdaf', 'class a extends b', 'class foo', 'aooo']

code.sort(key=codesort)
pprint(code)





raise Exception()

a = ['dog', 'cat', 'banana', 'apple', 'a']


def redirected():
    print('starting inptu for redirect')
    s = input('')
    redirect = {}
    r = '(\w+) to ([\.\w$_]+)(?: as (\w+))?'
    matches = re.findall(r, s, flags=re.M)

    for a, b, c in matches:
        redirect[a] = filegetter(b)
    return redirect


redirect = redirected()
print(redirect)
raise Exception('')


#print(sorted(a))
store = Storage()
#print(hasattr(store, 'store'))
#print(hasattr(1, 'store'))

#store = [[1,2,3], [4,5, 5, 6]]
#for a,b,c in store:
    #print([a,b,c])



a = '''
aa to browser inferlang to base
bb to css
cc to vue as vscroll'''

r = '(\w+) to (\w+)(?: as (\w+))?'
matches = re.findall(r, a, flags=re.M)
#print(matches)





def to_pyvim(key):
    file = 'vim.txt'
    r = '^(\w+) [\'\"]?(.*?)[\'\"]?$'
    matches = re.findall(r, read(file), flags=re.M)
    value = {a:b for a,b in matches}
    lang = 'vim.py'
    payload = toVariable(key, value, lang)
    append('vim.py', payload)
    raise Exception('')



# there are often multiple ways of achieving something, but some ways are more memoriable.

store = {'browser.css': ['b', 'c', 'd', 'bb'], 'css-parser.js': ['aa', 'cc'], 'vue.js': ['va', 'vb', 'inferlang']}

targets = [m[0] for m in matches]
originmap = {}

for k,v in store.items():   # h
    for name in v:
        if not targets:
            break
        if name in targets:
            pop(targets, name)
            originmap[name] = k

destinations = [m[1] for m in matches]
destinationmap = {}

for destination in destinations:
    value = find(store.keys(), '^' + destination)
    if not value:
        value = prompt('input a value for', destination)
    destinationmap[destination] = value


for target, destination, newName in matches:
    origin = originmap[target]
    destination = destinationmap[destination]
    value = storage.store[origin][target]

    if newName:
        store[destination][newName] = value
    else:
        store[destination][target] = value

    store[origin].pop(target)

print(store)



from test import *
from libra import *
import time
import sys
import String
import webbrowser
import black
from filesystem import *

class LineParser:
    def __init__(self, file, condition, parser):
        self.lines = [parser(line) for line in read(file).split('\n') if condition(line)]

    def __call__(self):
        pprint(tally(self.lines))
         
#LineParser(ff(dir='TRASH', file='utils.py')

def condition(s):
    s = s.strip()
    if len(s) < 10:
        return False

    if test('^[^\w]', s):
        return False

    if test('^[^\w]', s):
        return False

    return True

def run():
   for file in FileManager(py=1, dir='TRASH', name='^env.py$|script.py$'):
       file.moveTo('.')


def to_vim(**kwargs):
    file = tail(file)
    names = getFunctionNames(read(file))
    payload = f"let g:{vimDictionary}[{file}] = {String.array(*names, quoted=1)}"
    print('payload', payload)
    print('names', names)
    input()
    append('/home/kdog3682/.vimrc', payload)

run()



def pythonconnector():
    if __name__ != '__main__' or len(sys.argv) < 2:
        return
    buffer, key, *args = sys.argv[1:]
    fn = globals().get(key)
    if fn.__code__.co_varnames[0] == 's' and not args:
        value = fn(read(buffer))
    else:
        value = fn(*args)
    if value:
        pprint(value)


def dprint(s):
    print(len(s))
    write('foo', toString(s))
    webbrowser.open('foo')
    raise Exception('')


def get_new_functions(file, outpath):
    data = invivo_library(file)
    current = globals()
    keys = data.keys()
    values = data.values()
    runner = lambda key: sum([1 if test(f"\\b{key}\\b", x) else 0 for x in values])
    filteredKeys = filtered(keys, lambda x: not current.get(x) and runner(x) > 5)
    payload = [data.get(key) for key in filteredKeys]
    return payload


#update_library(['libra.py'])
#update_library(['bar.py', 'foo.py', 'libra.py'])


def parse_misc(s):
    commentDelimiter, consoleLog = jspy(s, 'commentDelimiter', 'consoleLog')
    r = f"^{commentDelimiter} *"
    s = re.sub(r, '', s) 

    r = f"^(?:{consoleLog}) *\( *(.+?)\) *$"
    s, temp = mreplace(r, s)
    lines = [line for line in s.splitlines() if line.strip()]

    kwargs = {
        'prose': lines,
        'callables': temp,
    }

    to_kdog(outpath='lib.bigdata.json', append=1, **kwargs)




def toVariable(a, b, lang = 'py'):
    prefix = jspy(lang, 'const')
    return prefix + a + ' = ' + stringify(b)

def jspy(lang, key):

    namePY = '^(?:\w+(?= )|(?<=def |class )\w+)'
    nameJS = '^(?:(?:async )?function|def|class|const) (\w+)'
    callablePY = '\w\w\w+\.(?!log|toString)[a-z]\w+(?=\()'
    callablePY = '[\w\.]{8,}(?=\()' 
    callableJS = 'new \w+|\w\w\w+\.(?!log|toString)[a-z]\w+(?=\()'
    commentJS = '// '
    commentPY = '# '

    functionJS = '(?:(?<=\n)|^)(?:(?:async )?function|const|class) \w+\\b[\w\W]+?\n}'
    functionPY = '(?:(?<=\n)|^)(?:def|class) \w+\\b[\w\W]+?(?=\n\w|$)'

    if len(lang) > 3 and isfile(lang):
        lang = getExtension(lang)

    indexes = ['js', 'py', 'vim', 'bash', 'css', 'html']

    ref = {
        'compiler': ['node', 'python3', None, 'bash'],
        'const': ['const ', '', 'let'],
        'callableRE': [callableJS, callablePY],
        'nameRE': [nameJS, namePY],
        'functionRE': [functionJS, functionPY],
        'comment': [commentJS, commentPY],
    }

    return ref[key][indexes.index(lang)]




from test import *
import stringhtml
import json
from filesystem import *
from libra import *
        
def html_file_from_main_entrypoint(key):

    chdir("/home/kdog3682/CWD") 
    similar = ff(startswith=key, js=1)
    helpers = GLOBALS.WEBSITE_HELPER_FILES

    ignore = helpers + similar
    files = ff(css=1, js=1, ignore=ignore)
    files = choose(files, list)
    files.extend(ignore)
    files = [tail(file) for file in files]
    files.sort(key=filesort)
    files.insert(0, 'https://unpkg.com/vue')

    s = stringhtml.toHtml(files)
    prompt(s)
    write('index.html', s, 1)


def filesort(file):
    helpers = GLOBALS.WEBSITE_HELPER_FILES
    name = tail(file)
    if getExtension(name) == 'css':
        return -1
    if 'main' in name:
        return 1000
    if name in helpers:
        return helpers.index(name)
    else:
        return len(helpers) 


def runjs(file, *args):
    os.system('node ' + file + ' ' + ' '.join(args))

#chdir('cwd')
#print(stringhtml.toHtml(files=['a.js'], script='hi'))


from storage import *
from sys import argv

#iterate(dirs, lambda dir: getfiles(dir=dir, extension='json'))
#f = getfiles(before=30, extension='json')


def organizefiles():
    store = SimpleStorage()
    items = getfiles(key=isdir)
    dir = choosedir(items)

    try:
        for item in getfiles(dir=dir, key='json'):
            data = read(item)

            if isObject(data) or isArray(data):
                print(data)
                print('-' * 30)
                print(item)
                answer = Input('write tag')
                if answer:
                    store.add(answer, item)
    except:
        write('filetags.json', store.value)
        return print('finishing due to error')

    write('filetags.json', store.value)

def choosedir(items):
    a = Input('choose a number index-base-1 to open the file', 'type b to go backwards', 'press enter to exit')
    a = int(a)
    item = items[a - 1]
    return item


def getnodefile():
    items = getfiles(key=isdir)
    runner(items)
    store = SimpleStorage()

    def runner(items):
        os.system('clear') 
        if not isArray(items): items = absdir(items)
        pprint(items)
        a = Input('choose a number index-base-1 to open the file', 'type b to go backwards', 'press enter to exit')
        if isNumber(a):
            a = int(a)

            item = items[a - 1]
            if isfile(item):

                data = read(item)
                if isArray(data):
                    index = 0
                    while True:
                        os.system('clear') 
                        print(data[0])
                        z = Input('[s]top')
                        if z == 's':
                            break
                        elif z:
                            store.add(z, item)
                            break

                else:
                    openfile(item)

                runner(dir)
            if isdir(item):
                runner(item)

        else:
            if a == 'b':
                dir = re.sub('/$', '', dir).rsplit('/', maxsplit=1)[0]
                runner(dir)
            else:
                print('done')
                return  

    runner(dir)
    write('filetags.json', store.value)


def getmathtags():
# basically, spent better part of a morning iterating through the file. 
#organizefiles()
f = '/home/kdog3682/CWF/08-22-2021/aopsamc8master.json'
#tl( openfile(f) )

data = read(f)
data = [item.get('question') for item in data]
store = []
def parser(x):
    if x == 'd':
        lookbehind = '(?<!' + ncg(months) + ' )'
        r = lookbehind + '-?\d+(?:\.\d+)?'
        return r
    return x

tags = []
last = None
while True:
    a = Input('keys')
    if a.startswith('go'):
        print('last')
        data = filtered(data, lambda x: not test(last, x, flags=re.I))
        tags.append((a, last))
        print(tags)
    else:
        keys = re.split('  |, ?', a)
        keys = iterate(keys, parser)
        regex = '.*?'.join(keys)
        last = regex
        print(regex)

        items = filtered(data, regex)
        print('number of items', len(items))
        print('\n\n'.join(items))
    
#view-source:https://www.nhs.uk/conditions/vitamins-and-minerals/
#<a class="nhsuk-contents-list__link" href="(/conditions/vitami.*?)">(.*?)</a>
#parsing the data but this can be done later.



import vim
from libra import *

    
def redirected():
    s = input('')
    redirect = {}
    r = '(\w+) to ([\w-._]+)(?: as (\w+))?'
    matches = re.findall(r, s, flags=re.M)

    if matches:
        for a, b, c in matches:
            redirect[a] = vim.filedict.get(b, b)
    return redirect

def redire():
    for outpath, names in storage:
        for name in names:
            value = service.store.get(name)

            if name in redirect:
                outpath = redirect[name]
            
            storage2.add(outpath, value)


#pprint(getDuplicates(getFunctionNames(read('vimbackup.txt'))))
# this is way too complicated.
#tempest({k: sorted(list(v.keys())) for k,v in target.partitions.items()})
#target.compareWith('base.js')
#s = interactive(target)
#print(s)
#target = CodeService('infusion-generator.js')
#extracted = target.extract('inf')
#write(target.file, extracted.values())
#append('math-helpers.js', str(target))
#target = CodeService('question-generator.js')
#target.extract('NumberGen', 'numbergen.js')
#target.extract('InfusionGenerator', 'infusion-generator.js')
#target.write()
#write('asdfxvcv', ('asd', 'sd'))








service = CodeService('/home/kdog3682/CWF/public/current.js')
regex = ncg('^$1', CodeService('browser.js').store)

service.partition('css-parser.js', key='^cs|css|cabmap|tailwind|vmap')
service.partition('animations.js', key="^kf|appear|animate", value='el.animate')
service.partition('browser.js', key=regex)
service.partition('browser.js', key='catpics')
service.partition('vuetify.js', key='^[v$]|directive$')
service.partition('vue-messy.js', key='^(?:socket|modal|autoaction|mount|watch|setup|submit|info|getinfo|create|wrapf)')
service.partition('html-parser.js', key='html|divify|tag$')
service.partition('math-helpers.js', key='math|nerd|latex|katex|answer|NaN|square|cube|fraction|lcm|divmod|percentage|gcd|factors|\\bodd|\\beven|prime|digit|operator|decimal|percent|ratio|power|equal|variable|rng|terminat|subutract|getnumbers|isodd|iseven|coinflip|range')
service.partition('helpers.js')

storage = Storage()
storage2 = Storage()
for k,v in service.store.items():
    for outpath, checkpoint in service.checkpoints:
        if checkpoint(k,v):
            storage.add(outpath, v)
            storage2.add(outpath, k)
            break

chdir('/home/kdog3682/CWD')

for outpath, values in storage:
    values.sort(key=codesort)
    write(outpath, values)

write('service.json', storage2.store.items())


from test import *

def link(s):
    return '<link href="' + s + '" rel="stylesheet"/>'

def script(s):
    return '<script charset="utf8" src="' + s +'"></script>'

def scriptOrLink(s):
    if isHtml(s):
        return s
    if isUrl(s):
        if not test('^http', s):
            s = 'https://' + s
        return script(s)

    return script(s) if getExtension(s) == 'js' else link(s)

def html(s):
    return '<!doctype html><html>\n' + indent(s) + '\n</html>'

def div(attrs = ''):
    content = ''
    el = 'div'
    if attrs: attrs = ' ' + attrs
    return "<" + el + attrs + ">" + content + "</" + el + ">"

def toOpeningTag(el, attrs=""):
    if attrs:
        attrs = ' class="' + attrs
    return "<" + el + attrs + ">"

def toClosingTag(el):
    return "<" + el + "/>"


def newlineIndent(s):
    return '\n' + indent(s) + '\n'



def toHtml(files=0, body = 0, script = 0, css = 0, html=0, js=0, style=0, links=0):

    if links:
        files = links 
    if html:
        body = html
    if js:
        script = js 
    if style:
        css = style

    if files and find(files, 'vue'):
        if not body: body = div('id="app"')
        if not script: script = 'const app = new Vue(App).$mount(\'#app\')'

    s = ''
    s += '<!doctype html><html>\n'
    s += '    <head>\n'

    if files:
        if isArray(files):
            for file in files:
                s += '        ' + scriptOrLink(file) + '\n'
        else:
            s += indent(files, 8) + '\n'

    s += '    </head>\n\n'
    if css:
        s += '    <style>\n'
        s += indent(css, 8) + '\n'
        s += '    </style>\n\n'

    s += '    <body>\n'
    if body: s += indent(body, 8) + '\n'
    s += '    </body>\n\n'
    s += '    <script>\n'
    if script: s += indent(script, 8) + '\n'
    s += '    </script>\n\n'
    s += '<html>\n'
    return s




import unidecode
import html
from storage import *

def replaceFromFactory(dict):
    normal = []
    empty = []
    for k,v in dict.items():
        if v == '':
            empty.append(k)
        else:
            normal.append([k, v])

    def replacer(s):
        regex = ncg(empty)
        s = re.sub(regex, '', s, prepareflag(regex))
        for [a,b] in normal:
            s = re.sub(a, b, s, prepareflag(a))
        return s.strip()

    return replacer

mathdict2 = {
    r'(?:\\text\{)?\\textdollar\}? *([\d.]+)': lambda x: x.group(1) + ' ' + pluralize('dollar', x.group(1)),
    r'^ *\\:?': '',
    r'\\(?:emph|text(?:sc)?){(.*?)}': lambda x: x.group(1),
    r'\^\\text{th}': 'th',
    r'\\quad': '',
    '&lt;': ' < ',
    '&gt;': ' > ',
    '&#36;': '$',
}


def converter():
    store = []
    aops8fix = replaceFromFactory(mathdict2)

    for item in read('aops-product.json'):

        name = item.get('name')
        name = re.sub('(?<=AMC)_(?=\d+)', '', name) 
        name = re.sub('_', '-', name)
        info = item.get('info')

        if not info or info.get('base') != info.get('answer'):
            print('nope', name)
        else:
            print('success', name)
            for q in item.get('exam'):
                id = name + '-Q' + str(q.get('id'))
                if not q.get('question') or test('asy|tabular', q.get('question')):
                    continue
                question = aops8fix(q.get('question'))
                choices = [aops8fix(el) for letter, el in q.get('choices').items()]
                answer = char2n(q.get('answer'))

                product = {'id': id, 'question': question, 'choices': choices, 'answer': answer}
                store.append(product)

    write('aopsamc8master.json', store)

def editjson2(file, dict):
    data = read(file)
    for i in ranger(data):
        for key, fn in dict.items():
            data[i][key] = fn(data[i]) if isFunction(fn) else fn

    write(file, data)

#def removeDollar():
#editjson2('aopsamc8master.json', {'question': lambda x: removeDollar(aopsfix8(x.get('question')))}


#print(readFileForDependencies('thursday.html'))
def doit():
    text = ''
    if True and istodayfile('temp.txt'):
        text = read('temp.txt')
    else:
        print('creating new temp file')
        text = read('sat-practice-test-1-answers2.txt')
        text = html.unescape(text.strip())
        text = unidecode.unidecode(text)
        text = re.sub('\(cid:\d+\)', '', text)
        write('temp.txt', text)
    #r = re.findall('^Choice \w+ is the best answer', text, flags=re.M)
    #print(len(r))
    #return
    r = '^Choice [ABCDE] is the best answer[\w\W]+?(?=(?:Choice [ABCDE] is the best answer|QUESTION \d+))'

    def parser(s):
        #print(visiblenewlines(s))
        #s = re.sub(' \s+', ' ', s)
        #tl( s )
        dict = {
           ' \n\n': '\n\n', 
           ' \n \n': ' ',
        }
        s = dreplace(s, dict)
        return s.strip()

    matches = iterate(re.findall(r, text, flags=re.M), parser)
    print(len(matches))
    write('z.json', matches)

#doit()
#s = read('temp.txt')

s = '''
Choice D is the best answer. Woolf writes that the men who conduct
WKHDƬDLUVRIWKHQDWLRQOLQHVŠDVFHQGLQJWKRVHSXOSLWV
preaching, teaching, administering justice, practising medicine,
transacting business, making money”) are the same men who go to
joining this procession, an act that suggests the workforce has become
less exclusionary: “For there, trapesing along at the tail end of the 


'and from work in a "procession" (line 10). Woolf notes that women are'
"procession, we go ourselves" (lines 23-24)."
(cid:87)(cid:75)(cid:72)(cid:3)(cid:68)(cid:428)(cid:68)(cid:76)(cid:85)(cid:86)(cid:3)(cid:82)(cid:73)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:81)(cid:68)(cid:87)(cid:76)(cid:82)(cid:81)(cid:3)(cid:11)(cid:79)(cid:76)(cid:81)(cid:72)(cid:86)(cid:3)(cid:20)(cid:24)(cid:16)(cid:20)(cid:26)(cid:29)(cid:3)(cid:352)(cid:68)(cid:86)(cid:70)(cid:72)(cid:81)(cid:71)(cid:76)(cid:81)(cid:74)(cid:3)(cid:87)(cid:75)(cid:82)(cid:86)(cid:72)(cid:3)(cid:83)(cid:88)(cid:79)(cid:83)(cid:76)(cid:87)(cid:86)(cid:15)(cid:3) 
'''


s = '''
(cid:87)(cid:75)(cid:72)(cid:3)(cid:68)(cid:428)(cid:68)(cid:76)(cid:85)(cid:86)(cid:3)(cid:82)(cid:73)(cid:3)(cid:87)(cid:75)(cid:72)(cid:3)(cid:81)(cid:68)(cid:87)(cid:76)(cid:82)(cid:81)(cid:3)(cid:11)(cid:79)(cid:76)(cid:81)(cid:72)(cid:86)(cid:3)(cid:20)(cid:24)(cid:16)(cid:20)(cid:26)(cid:29)(cid:3)(cid:352)(cid:68)(cid:86)(cid:70)(cid:72)(cid:81)(cid:71)(cid:76)(cid:81)(cid:74)(cid:3)(cid:87)(cid:75)(cid:82)(cid:86)(cid:72)(cid:3)(cid:83)(cid:88)(cid:79)(cid:83)(cid:76)(cid:87)(cid:86)(cid:15)(cid:3)
'''
pair = "the affairs of the nation (lines 15-17: \"ascending those pulpits,"

def cidpair():
    cids = orderedunique(re.findall('\d+', s.strip()))
    letters = orderedunique(list(pair.strip()))
    print(cids)
    print(letters)
    store = {}
    for i, item in enumerate(cids):
        try: store[item] = letters[i]
        except: continue
    print(len(cids))
    print(len(letters))
    print(store)

def deciphercid(s):
    dict = {'15': 'n', '87': 't', '75': 'h', '72': 'e', '3': ' ', '68': 'a', '428': 'ff', '76': 'i', '85': 'r', '86': 's', '82': 'o', '73': 'f', '81': '(', '11': 'l', '79': '1', '20': '5', '24': '-', '16': '7', '26': ':', '29': '"', '352': 'c', '70': 'd', '71': 'g', '74': 'p', '83': 'u', '88': ','}
    return re.sub('\(cid:(\d+)\)', lambda x: dict[x.group(1)], s)


def maketeaching():
    data = read('10958.json')
    store = []
    for i in [2,4,8,16,32,64,128,256,512]:
        print(i, str(i))
        item = data.get(str(i))
        if not item:
            raise Exception('ray') 
        store.append(item)

    append('teaching.json', store)


def organizefiles(lang = 'js'):
    for file in getfiles(key=lang):
        size = getfilesize(file)
        if size < 25:
            os.remove(file)
            continue
        if size > 3000:
            continue

        os.system('clear')
        a = input(file)
        if a == 'r':
            s = read(file)
            print(s)
            print()
            print(file)
            a = input()
        if a:
            continue
        else:
            print(file)
            os.remove(file)

#organizefiles()

def matchfinder(r, file):
    s = read(expand(file)) if isfile(expand(file)) else file
    return re.findall(r, s, flags=re.M)

def organizeBashHistory():
    matches = matchfinder('pip.*', '~/.bash_history')
    return matches




def singlesweep(file, clear=1):
    def onInputDestination(destination, ext):
        if destination == 'self': return 'self'
        destination = filegetter(destination)
        while len(destination) < 5:
            if destination == 'del':
                return destination
            destination = prompt('Destination length is too short, and the destination is not in filegetter. Write a destination. an extension will automatically be appended for you.')
        if not getExtension(destination):
            destination += '.' + ext
        return destination

    def onInputRegex(regex):
        if ',' in regex:
            regex = '(?:' + regex.replace(',', '|') + ')'
        return regex

    ext = getExtension(file)
    s = mwrite(file)
    s, ref = mlibrary(s)
    pprint(ref)
    return 

    partitioner = PartitionObject(ref)
    regex = 1

    while len(partitioner.items.keys()) > 0:

        messageArgs = ['-----------', partitioner.keystore.store, partitioner.items.keys(), 'choose destination and regex', '-----']
        args = ['Welcome to single_sweep. This function will walk thru a cleanup of the currently opened file.', 'file inpath: ' +  file, 'Number of matches is', len(ref)] + messageArgs if once() else messageArgs
        query = prompt(*args)
        #if query == 'u':
            #partitioner.undo()

        if query == 'done':
            break
        if not query:
            query = prompt('enter nothing to exit. All remaining items will be partitioned to self.')
        if not query:
            partitioner.partition('self', '^' + '.')
            break

        destination, regex = splitonce(query)
        if destination == 'del' or destination == 'd': destination = 'trash'
        if regex:
            destination = onInputDestination(destination, ext)
            regex = onInputRegex(regex)
            if test('^[ \d]+$', regex):
                partitioner.partitionByIndexes(destination, regex)
            else:
                partitioner.partition(destination, '^' + regex)

    selfItems = partitioner.store.pop('self', '')
    selfItems.sort(key=len)

    if clear:
        if selfItems:
            s += '\n' + toString(selfItems)
        
        s = removeEmptyLines(s)
        tempest(s)
    
    prompt('keystore items', partitioner.keystore.store, 'finished with process. Type yes to proceed to build process. Each of the items in the keystore will be appended to the given destination. The current pop up file is what is left in the original store. labeled under:', file, 'for items labeled as del, they are being popped from the partitioner', 'destinations:', '---------', partitioner.store.keys(), '---------')

    for destination, items in partitioner:
        append(destination, items)

    if clear:
        write(file, s)



from test import *
import time
from filesystem import *
from libra import *


class PartitionObject(Storage):
    def __init__(self, items):
        super().__init__()
        self.items = items
        self.keystore = Storage()

    def partitionByIndexes(self, destination, s):
        items = list(self.items.keys())
        indexes = s.split(' ') if ' ' in s else [x for x in list(s) if isNumber(x)]
        keys = [items[int(i) - 1] for i in indexes] 

        self.lastItems = {}
        self.lastDestination = destination

        for key in keys:
            self.lastItems[key] = self.items[key]
            self.add(destination, self.items.pop(key))
            self.keystore.add(destination, key)

    def undo(self):
        self.items.update(self.lastItems)
        self.keystore.store[self.lastDestination] = difference(self.keystore.store[self.lastDestination], self.lastItems.keys())
        self.store[self.lastDestination] = difference(self.store[self.lastDestination])
        
    def partition(self, destination, key = 0, value = 0, flags=0):
        for k,v in self.items.copy().items():
            if self.checkpoint(key, value, flags, k, v):
                self.add(destination, v)
                self.keystore.add(destination, k)
                self.items.pop(k)

    def checkpoint(self, key, value, flags, k, v):
        if key and not ftest(key, k, flags):
            return False

        if value and not ftest(value, v, flags):
            return False

        return True

        




def inferDependencies(s):
    ref = {
        'vue': ['mounted', 'methods:'],
        'mathquill': ['mathquill'],
        'katex': ['katex'],
        'nerdamer': ['nerdamer'],
    }

    scripts = {
        'vue': ['vue.js', 'vuex.js', 'vuerouter.js'],
        'prettier': ['standalone.js', 'parser-html.js', 'parser-babel.js'],
        'katex': ['katex.min.js', 'katex.min.css'],
        'Vue': ['vue.js'],
        'mathquill': ['mathquill.min.js'],
        'codemirror': ['codemirror.js', 'codemirror.css', 'codemirror.docs.css'],
        'quill': ['quill.js'],
        'nerdamer': ['nerdamer.js'],
        'self': ['questiongenerator.js'],
        'jshint': ['jshint.js'],
        'controller': ['element-controller.js', 'ec.css'],
    }
    store = []
    for k,v in ref.items():
        if ftest(v, s, flags=re.I):
            store.extend(scripts.get(k))
    return store


def buildsnippets(file):
    files = ff(get='py')

    def runner(file):
        regex = '^ *(\w+(?:, *\w+)?) *= *(?:[\'\"](.*)[\'\"]|([\w-]+\(.*))'
        m = findall(regex, file)
        return m

    storage = Storage()
    storage(map(files, buildsnippets))
    writejson(storage.value)
    #not enough t oj ust aggregate the data need to use it too.
    #  these are for varaible snippets


def defprog(file):
    condition = '^\w+'
    parser = trim
    lines = linegetter(file, condition, parser)
    tally = Tally()
    tally(lines)
    store = tally.get(min=2)
    printer(store)



def vuetransform(entrypoint = 'html2.js'):
    ''' this is a big file. '''
    htmloutpath = entrypoint + '.html'
    datapath = entrypoint + '.json'
    jsoutpath = entrypoint + '.source.js'

    chdir('cwd')

    print('running js')
    print('creating the json transfer data')
    mode = 'production'
    result = runjs('vue-transform.js', entrypoint, mode)
    if result:
        raise Exception('an error occured at vue-transform because we have exited with a non-zero status. most likely methods are missing')

    data = readjson(datapath)
    dependencies = data.get('dependencies')
    value = data.get('value')

    
    lib = GLOBALS.jsimportlib
    libhelpers = flat(filtered([lib.get(x.lower()) or filegetter(fnNameToFileName(x, 'js'), throw=1) for x in dependencies]))
    prefixkey = search('^(\w+)-', entrypoint)
    similar = ff(js=1, css=1, name='^' + prefixkey) if prefixkey else []
    basehelpers = GLOBALS.WEBSITE_BASE_HELPER_FILES
    store = libhelpers + basehelpers + similar 
    store = [tail(file) for file in store]
    store.append(jsoutpath)
    #store.sort(key=filesort)
    s = stringhtml.toHtml(store)
    prompt(s)
    write(htmloutpath, s, 1)


def filesort(file):
    helpers = GLOBALS.WEBSITE_HELPER_FILES
    name = tail(file)
    if getExtension(name) == 'css':
        return -1
    if 'main' in name:
        return 1000
    if name in helpers:
        return helpers.index(name)
    else:
        return len(helpers) 



from test import *
from fileservice import *
from pdfservice import *

#write('t2.json', {'subjects': subjects, 'store': store}, open=1)
#s = read('tempest.json')[3]
#t = search('Miss Grace[\W\w]+?That\'s right\."', unidecode.unidecode(s))
#print(t)

satanswerlinks = [
    "/home/kdog3682/CWF/08-22-2021/scoring-sat-practice-test-1.pdf",
    "/home/kdog3682/CWF/08-22-2021/scoring-sat-practice-test-3.pdf",
    "/home/kdog3682/CWF/08-22-2021/scoring-sat-practice-test-5.pdf",
    "/home/kdog3682/CWF/08-22-2021/scoring-sat-practice-test-6.pdf",
    "/home/kdog3682/CWF/08-22-2021/scoring-sat-practice-test-7.pdf",
    "/home/kdog3682/CWF/08-22-2021/scoring-sat-practice-test-8.pdf",
    "/home/kdog3682/CWF/08-22-2021/scoring-sat-practice-test-9.pdf"
    "/home/kdog3682/CWF/08-22-2021/scoring-sat-practice-test-10.pdf",
]


def splitsat(n, dir, once = False):
    for i in range(1, 11):
        if n and i != n: continue

        file = 'sat-practice-test-' + str(i) + '.pdf'
        if not isfile(file):
            print('error', file)
            continue
        else:
            pages = pdfToArray(file)
            indexes = getSatPageIndexes(pages)
            indexes = indexes.get('Reading')
            if once:
                first = indexes[0]
                second = indexes[1][0]
                third = indexes[-1][1]
                indexes = [first, [second, third]]
            splitpdf(file, indexes, dir=dir)



def getSatPageIndexes(pages):
    print(len(pages))
    r = '^[\s\d]*(Reading|Math|Writing and Language) Test'
    r2 = 'Questions \d+-(\d+) are based on'
    section = None
    store = {}
    chunks = []
    awaitingFinish = False
    memory = None
    for originalIndex, s in enumerate(pages):
        i = originalIndex + 1
        if not section:
            if test(r, s, re.I):
                section = search(r, s, flags=re.I)
                if awaitingFinish:
                    chunks.append(i)
                    awaitingFinish = False
                    if not memory:
                        raise Exception('ray') 
                    store[memory] = pagegroup(chunks)

            else:
                continue

        if section == 'Reading':
            match = search(r2, s, flags=re.I)
            if match:
                r3 = 'This passage[\w\W]+?\n\n'
                blurb = search(r3, s)
                print(blurb)

                print('appending i', i)
                chunks.append(i)

                if match == '52':
                    print('matched at 52, done')
                    awaitingFinish = True
                    memory = section
                    section = None
        
        elif section == 'Writing and Language':
           break 

        elif section == 'Math':
           break 

    return store



def getTestInfo(file):
    pages = pdfToArray(file)
    store = []
    subjectRE = 'Writing and Language Test|Reading Test|Math Test'
    currentSubject = 0
    regex = 0

    dict = {
        'Reading Test': 'Questions (\d+)-(\d+) ([\w\W]+?)Line',
        'Math Test': None,
        'Writing and Language Test': 'Questions (\d+)-(\d+) ([\w\W]+?)\n\n',
    }

    subjects = []

    for i, page in enumerate(pages):
        subject = search(subjectRE, page[0:100])
        if subject:
            currentSubject = subject
            pageNumber = search('\n(\d\d\d)\n', page)
            regex = dict.get(currentSubject)
            subjects.append([subject, pageNumber])

        if regex:
            match = search(regex, page)
            if match:
                pageNumber = search('\n(\d\d\d)\n', page)
                questionRange = [match[0], match[1]]
                info = match[2]
                store.append({
                    'pageNumber': pageNumber,
                    'questionRange': questionRange,
                    'info': info,
                })

    return store


# have to preparse it. because there will be things missing.
def satanswerparser(s):
    chunks = split(s, '\n\n+')
    #tags = ['reading', 'writing', 'math-no-calculator', 'math-calculator']
    dict = {
        'reading': 52,
        'writing': 44,
        'math-no-calculator': 20,
        'math-calculator': 38,
    }

    tags = list(dict.keys())
    store = {}
    for index, chunk in enumerate(chunks):
        tag = tags[index]
        items = split(chunk, '\n')
        if items[0] == '1' and items[2] == '2' and items[4] == '3':
            items = [item for i, item in enumerate(items) if i % 2 == 1]
        if len(items) != dict.get(tag):
            print(len(items), tag, dict.get(tag))
            raise Exception()
        store[tag] = items

    return store

#rpw(file='a1.txt', parser=satanswerparser, outpath='sat10-answerkey.json', wait=1)
#url = "/home/kdog3682/CWF/08-22-2021/scoring-sat-practice-test-10.pdf"
#pdfToArray(url, index=7)



from test import *


class LineEdit:

    def __init__(self, fn):
        self.fn = fn
        self.store = []
        self.index = 0

    def nextIsEmpty(self, i = 0):
        return len(self.lines[self.index + 1 + i].strip()) == 0

    def run(self, s):
        s = smartDedent(s)
        self.lines = s.strip().split('\n')
        length = len(self.lines)
        while self.index < length:
            line = self.lines[self.index]
            spaces = len(search('^ *', s))
            empty = len(line.strip()) == 0
            raw = line.strip()
            self.fn(self, raw, self.index, spaces, empty)
            self.index += 1

        return self
    def __str__(self):
        return '\n'.join(self.store)

def divify(tag, attrs, s):

    attrs = stylegetter(attrs)
    space = ' ' if attrs else ''

    return f"<{tag}{space}{attrs}>{s}</{tag}>"


def htmlify(state, line, index, spaces, empty):
    def parser(x):
        key = re.sub('^/', '', x.group(1).strip())
        s = x.group(2).strip()
        return bold(s)

    if empty:
        value = newline()

    elif test('^-', line):
        value = bullet(line)

    else:
        key = 'b'
        longkey = 'bold'
        regex = f"(/{key}|{longkey} )(.*?(?::|(?= -|[,.])))"
        value = re.sub(regex, parser, line)
        value = paragraph(value)

    state.store.append(value)

def stylegetter(s):
    dict = {
        'bold': 'font-weight: bold',
        'small': 'font-size: 8px',
        'bullet': 'margin-left: 10px',
        'highlight': 'background: yellow',
        'paragraph': 'padding: 0; margin: 0; line-height: 1.3',
    }
    style = dict.get(s, '')
    return f"style=\"{style}\"" if style else ''


def bullet(s):
    s = re.sub('^- *', '', s)
    return divify('li', 'bullet', s)

def bold(s):
    return divify('span', 'bold', s)

def paragraph(s):
    return divify('p', 'paragraph', s)

def newline():
    return '<br/>'


body = f"""

    /bFirst PDF: the topic is fun

    bold Second PDF - 7 assignments. 
        
        - Front page is notes. 
        - Back page is questions. 
        - One assignment for every day of the week.

"""
body = f"""

    SAT ENGLISH - Miss Spivey Passage

    Nice work Alan!
    Nice work with evidence.
    Nice work with preparation. (can be a little bit better)

    bold Challenge for next week: 
    - A) No ralphord mistakes              <-- THIS IS A WIN! (or)
    - B) Catch yourself making a ralphord. <-- THIS IS A WIN!

    bold A ralphord mistake is:
    - You see a piece of evidence in the text and use it because the question has the word "ralphord" and the evidence also has the word "ralphord." 
    - Unfortunately, there is another piece of evidence in the passage that also uses the word "ralphord." It is actually this piece of evidence which will leads to the correct answer.

    bold Tips to avoiding ralphord mistakes:
    - 1. The evidence gives you a feeling of 95% confidence in your answer.
    - 2. Make sure the evidence actually answers the question.


"""

body = """
    bold Q1: foo bar

"""
s = LineEdit(htmlify).run(body)
#print(s)


from pydub import AudioSegment
from pydub.playback import play

file =  '/home/kdog3682/CWF/4616 Seventh Ave 2.m4a'
sound = AudioSegment.from_file(file)
sound.export('file.wav', format='wav')
#play(sound)


from test import *
import stringhtml
import json
from filesystem import *
from libra import *
        
def index_html_file_from_main_entrypoint(key):

    chdir("/home/kdog3682/CWD") 
    helpers = GLOBALS.HELPER_FILES
    similar = ff(startswith=key, js=1)
    ignore = helpers + similar
    files = ff(css=1, js=1, ignore=ignore)
    files = choose(files, list)
    files.extend(ignore)
    files = [tail(file) for file in files]
    files.sort(key=filesort)
    files.insert(0, 'https://unpkg.com/vue')

    s = stringhtml.toHtml(files)
    prompt(s)
    write('index.html', s, 1)


def filesort(file):
    helpers = GLOBALS.HELPER_FILES
    name = tail(file)
    if getExtension(name) == 'css':
        return -1
    if 'main' in name:
        return 1000
    if name in helpers:
        return helpers.index(name)
    else:
        return len(helpers) 






import env
import requests
import os
import re
import time
from jspy import *
import datetime
import decorators
from test import *
import vimservice as vimser
import stringhtml
import json
from filesystem import *
from libra import *
from intel import request
from pprint import pprint as printer
import vim
from fileservice import *
from filesystem import *
import sys










def tsc(dir):
    chdir(dirgetter(dir, force = 1))
    system(f"""
        tsc
    """)



#tsc('gen')
#s = "/home/kdog3682/CWF/generator/src/lezer-generator.js"
#action  =  lambda x: os.rename(x, changeExtension(x, 'cjs'))
#files = ff2(dir = s, js = 1 , reignore = 'roll', action = action)
#pprint(files)


def gobacm(s):
    
    store  = []
    def par(x):
        a,b,c,d,e,f  =  x.groups()
        if d and e:
            #print(x.groups())
            store.append(f)
            return e + f
        return 'const' + b + ' = require("' + c + '")'

    def parser(s):
        return re.sub('^(?:(import)(.+ )from "(.*?)"|(export)( \w+ )(\w+))', par, s, flags = re.M)

    p  = parser(read(s))
    assert store
    if store:
        p += '\nmodule.exports  =  {' + ','.join(store) + '}'
    #print(p)
    #s = "/home/kdog3682/CWF/generator/src/lezer-generator.js"
    return p

def buildcmparts():
    
#s = "/home/kdog3682/CWF/generator/src/build.js"
#print(gobacm(s))
    s = "/home/kdog3682/CWF/generator/src"
    f = ff2(dir = s, js = 1, reignore = 'test|rollup')
    iter(f, lambda x: write('/home/kdog3682/CWF/' + tail(x), gobacm(x), open = 1))



def joincmtogether():
    iter(f, lambda x: openfile('/home/kdog3682/CWF/' + tail(x)))
    write('/home/kdog3682/CWF/cmgen.js', '\n\n'.join(iter(f, lambda x: parser(read(x)))), open = 1)
pprint(buildcmparts())


from test import *
import vim
from filesystem import *
from libra import *

def multisweep(file, ignore=0):
    # notes:
    # if ignore, the destination is automatically set as ignore
    # regex is automatically set as '^'
    #
    #
    s = read(file)
    s, ref = mlibrary(s)

    ignored = []
    if ignore:
        ignoreNames = getFunctionNames(read(ignore))
        for name in ignoreNames:
            value = pop(ref, name)
            if value: ignored.append(value)

    #print(len(ignored))
    #print(len(ref))
    #input()
    #prompt(ref)
    partitioner = Partitioner(ref)

    regex = 1
    while len(partitioner) > 0:
        os.system('clear') 
        numbered(partitioner.keys)
        print('--------------------- partitioner.storage.value ---')
        print(partitioner.storage.value)
        print('choose 1-based indexes')
        a = input('')
        if not a:
            break
        if ignore:
            destination = ignore
            regex = a
        else:
            destination, regex = splitonce(a)
            if isNumber(destination):
                regex += ' ' + destination
                destination = 'u'
            destination = vim.filedict.get(destination, destination)

        partitioner.partition(destination, regex)



    selfItems = map(partitioner.keys, lambda key: partitioner.items.get(key))
    if ignored: selfItems.extend(ignored)
    #s = before + '\n\n' + toString(selfItems) + after
    s += '\n\n' + toString(selfItems)
    s = removeEmptyLines(s)

    commentString = '\n'
    for destination, keys in partitioner.storage:
        if destination == 'del': 
            continue

        items = map(keys, lambda key: partitioner.items.get(key))
        commentString += join(keys)
        append(destination, items)
    
    write(file, s + commentString)

class Partitioner:
    def __len__(self):
        return len(self.keys)

    def __init__(self, items):
        self.items = items
        self.keys = list(self.items.keys())
        self.storage = Storage()
 
    def partition(self, destination, s):
        if destination:
            self.lastDestination = destination
        elif hasattr(self, 'lastDestination'):
            destination = self.lastDestination
            
        items = unique(split(s))
        store = []

        for item in items:
            if '-' in item:
                a,b = item.split('-')
                for item in range(int(a), int(b) + 1):
                    value = self.keys[int(item) - 1]
                    store.append(value)

            elif isNumber(item):
                value = self.keys[int(item) - 1]
                store.append(value)

            else:
                if ',' in item:
                    item = '(?:' + item.replace(',', '|') + ')'

                values = filtered(self.keys, '^' + item, flags=re.I)
                store.extend(values)

        for key in store:
            pop(self.keys, key)
            self.storage.add(destination, key)
        

#chdir("cwd")
#multisweep('nodehelpers.js', 'utils.js')
#multisweep('pdfgen.js', 'utils.js')



def textToCsv(f):
    s = textgetter(f)
    return map(split(s, '\n')[1:], lambda x: split(x, ','))


def csv1():
    f='baby-names.csv'
    import csv
    keys = ['name', 'sex']
    indexes = []
    boys = []
    girls = []
    with open(f) as file:
        reader = csv.reader(file, delimiter=",")
        for i, row in enumerate(reader):
            if i == 0:
                for key in keys:
                    indexes.append(row.index(key))
                continue

            if int(row[0]) < 2000:
                continue
            destination = boys if row[3] == 'boy' else girls
            destination.append(row[1])

        write('names.json.js', {
            'boys': sort(unique(boys)), 'girls': sort(unique(girls))
        })



def babynames():
    
    #csv = textToCsv('yob2016.txt')
    #names = [f[0] for f in csv if int(f[2]) > 2000]
    #pprint(names)
    r = '<td.*?>(.*?)</td>'
    url = 'view-source:https://www.ssa.gov/OACT/babynames/decades/names2010s.html'
    m = re.findall(r, request(url))
    names = filtered(m, lambda x: x and not isNumber(x))
    write('names.json.js', names)



functionNameRE = '^(?:class|const|(?:async )?function|def) (\w+)|^(\w+)(?: ?=|\.prototype)'
htmllinks = '(?:href|src)="?(.*?)[">]'
textfile = '\.(?:txt|json|py|json|lib|log|css|html|vue|js|vim)$'
constant = '^(?:const )?\w+ ='
stringconstant = '^(?:const )?\w+ = [\'\"\`]'
objectconstant = '^(?:const )?\w+ = [\{\[]'
ncg = lambda x: x if type(x) == str else ('(?:' + '|'.join(x) + ')')

advancedimports = [
    "black",
    "FPDF",
    "fbchat",
    "sys\.",
    "praw\.",
    "default_timer\.",
    "difflib\.",
    "urllib\.",
    "itertools\.",
    "pprint",
    "html\.",
    "requests\.",
    "subprocess\.",
    "shutil\.",
    "socket\.",
    "inspect\.",
    "datetime\.",
    "time\.",
    "json\.",
    "sys\.",
    "re\.",
    "os\.",
]

dirmap = {
    "desktop": "desktop",
    "dl": "downloads",
    "documents": "documents",
}

testobj = {
    'a': 1,
    'b': 2,
    'c': 3,
}
testlist = [
    'fish',
    'carrot',
    'onion'
]
doublespace = '(?<=\w)  +(?=\w)'
redditchunks = '(?<=^|\n)@?(?:r\.)?(\w+)(?: |z)([\w\W]+?)(?=$|\n(?:@|(?:r\.)?(?:js|py|vim)))'

subredditmap = {
    "math": "cheatatmathhomework",
    "mhw": "cheatatmathhomework",
    "ebs": "explainbothsides",
    "ck": "cooking",
    "ap": "askprogramming",
    "ljs": "learnjavascript",
    "js": "learnjavascript",
    "lp": "learnpython",
    "me": "mementomoriok",
    "nsq": "nostupidquestions",
    "vue": "vuejs",
    "py": "learnpython",
    "p": "learnpython",
    "eli5": "explainlikeimfive",
    "vim": "vim",
    "v": "vim",
    "vimrc": "vim",
    "css": "css",
}

isjson = '\.(log|config|json|lib)$'
restarter = '(?<=^|\n)'
caret = '^'
codeprefix = "(?:class|const|(?:async )?function|def) "
jscodeprefix = '^(?:class|const|(?:async )?function|Vue)'
codename = caret + codeprefix + '(\w+)|^(\w+)(?: ?=|\.prototype)'
name = caret + codeprefix + '(\w+)|^(\w+)(?: ?=|\.prototype)'
wallu = "[\w\W]+?"
cwallu = "([\w\W]+?)"
comment = "(?://|#|\") *"
simplecomment = "(?://|#|\") *"
body = restarter + codeprefix + wallu + '(?=$|\n[^\s}\]])'
codechunks = "(?:\n *)+(?=^[^\s}\]\)/])"
ender = '(?:\n(?:endfunction|\]\})|(?=$|\n[#/"\w]))'

functions = restarter + codeprefix + wallu + ender
namedcodebodies = lambda x: restarter + codeprefix + ncg(x) + '\\b' + wallu + ender
functionnames = '^' + codeprefix + '(\w+)'

variableline = '^(?:const |let )?\w+ ?=.*'
#advancedimports = ncg(advancedimports)
def cleanerFactory(regex):
    return lambda s: re.sub(regex, "", s.strip(), flags=re.M)

jspymap = {
    "html": {
        "comment": lambda x: "<!-- " + x + " -->",
    },
    "history": {
        "comment": '"',
        "filename": "~/.bash_history",
        "file": "~/.bash_history",
        "remove": True,
    },
    "vim": {
        "comment": '"',
        "filename": "~/.vimrc",
        "file": "~/.vimrc",
        "remove": False,
    },
    "bash": {
        "comment": "#",
        "filename": "~/.bash_aliases",
        "file": "~/.bash_aliases",
        "remove": False,
    },
    "js": {
        "cleanerCommand": "prettier --write",
        "lang": "js",
        "unsafe": ["prettier", "fs", "localstorage", "fetch", "path"],
        "libsrcfile": "utils.js",
        "scrapRE": "^// *(\w+\(.*)|^(?:let |const )? (\w+) ?=\s*`([\w\W]+?)`",
        "sampleanswer": "howdy",
        "sampletest": "console.log('howdy')",
        "runtime": "node",
        "cwf": ["index1.html", "methods.js"],
        "files": ["utils.js", "methods.js"],
        "command": "node",
        "references": ["methods.js", "index.html"],
        "s +=": "let s = ''",
        "function": "function ",
        "add": "new Storage()",
        "append": "[]",
        "push": "[]",
        "[": "{}",
        "comment": "//",
        "log": "console.log",
        "const": "const ",
    },
    "py": {
        "cleanerCommand": "black --write ",
        "lang": "py",
        "unsafe": [
            "inspect",
            "praw",
            "sys",
            "subprocess",
            "webbrowser",
            "gzip",
            "socket",
            "requests",
            "fpdf",
            "StringIO",
            "FPDF",
            "pprint",
            "contextmanager",
            "unicodedata",
            "fbchat",
        ],
        "libsrcfile": "utils.py",
        "scrapRE": "^# *(\w+\(.*)|^(\w+) ?=\s*'''([\w\W]+?)'''",
        "sampleanswer": "howdy",
        "sampletest": "print('howdy')",
        "runtime": "node",
        "cwf": ["ec.py"],
        "files": ["utils.py", "archive3.py"],
        "command": "python3",
        "references": [],
        "const": "",
        "log": "print",
        "s +=": "s = ''",
        "function": "def ",
        "add": "Storage()",
        "append": "[]",
        "push": "[]",
        "[": "{}",
        "comment": "#",
    },
}

questionwords = [
    'istaw',
    'would',
    'can',
    'for',
    'will',
    'which',
    'whose',
    'shud',
    'who',
    'what',
    'where',
    'when',
    'why',
    'how',
    'should',
    'could',
    'do',
    'is',
    'have',
    'has',
    'does',
    'are',
    'might',
    'y',
]

anydatestamp = '^\d\d.*?\d:? (?=[a-zA-Z])'
redditquestion = '^' + ncg(questionwords) + '\\b'
#print(  redditquestion  )

codechunks = '\n+(?=function |const |def |class |\w+ =)|(?<=\n+doesntwork'
allchunks = '\n+(?=\S)(?!endfunction|}|\])'
vimchunks = '\n+(?=\S)(?!endfunction|}|\])'
startingcomment = '^ *(?:#|//|") *'
logstatement = '(?:print|console.log|echom?|ec) *\(? *(.*?)\) *$'

base = '/home/kdog3682/'
vimrc = base + '.vimrc'
bashrc = base + '.bash_aliases'

pmwb = {
    'sug': 'suggestion',
    'sugs': 'suggestions',
    'stfuf': 'stuff',
    'alu': 'aluminum',
    'usly': 'usually',
    'exped': 'experienced',
    'aytap': 'appreciate your tips and advice',
    'lets': "let's",
    't4yh': 'thanks for your help',
    't4yi': 'thanks for your input',
    'ael': 'addEventListener',
    'pls': 'please',
    'intrd': 'interested',
    'bable': 'be able',
    'prob': 'problem',
    'probs': 'problems',
    'lks': 'likes',
    'prog': 'progress',
    'jst': 'just ',
    'bst': 'best',
    'ck': 'cook',
    'stl': 'still',
    'wich': 'which',
    'thsi': 'this',
    'oft': 'often',
    'sv': 'save',
    'svs': 'saves',
    'wrd': 'word',
    'wrds': 'words',
    'bndry': 'boundary',
    'bndries': 'boundaries',
    'wrds': 'words',
    'abt': 'about',
    'lang': 'language',
    '2gethr': 'together',
    'wknd': 'weekend',
    'wknds': 'weekends',
    'shct': 'shortcut',
    'shcts': 'shortcuts',
    'bt': 'but',
    'wrk': 'work',
    'estabd': 'established',
    'estab': 'establish',
    'prsn': 'person',
    'prsns': 'persons',
    'lk': 'like',
    'grnd': 'ground',
    'cssrem': 'rem',
    't4yr': 'thanks for your reply',
    'lmk': 'let me know',
    'q': 'question',
    'mite': 'might',
    'tfyhas': 'thanks for your help and support',
    't4yhas': 'thanks for your help and support',
    'tfyhasitm': 'thanks for your help and support in this matter',
    't4yhasitm': 'thanks for your help and support in this matter',
    'alilbit': 'a little bit',
    'ntbi': 'not the best idea',
    'hm': 'how much',
    'algos': 'algorithms',
    'algo': 'algorithm',
    'org': 'organize',
    'chld': 'child',
    'wil': 'will',
    'whr': 'where',
    'wheres': "where's",
    'ezier': 'easier',
    'absrb': 'absorb',
    "// '4": 'for',
    'tyvm': 'Thank you very much',
    'ty': 'thanks',
    'thx': 'thanks',
    'thot': 'thought',
    'thots': 'thoughts',
    'evone': 'everyone',
    'wrt': 'with respect to',
    'lrnd': 'learned',
    'mch': 'much',
    'frm': 'from',
    'fbafw': 'for better and for worse',
    'alwd': 'allowed',
    'tkn': 'taken',
    'tken': 'taken',
    'insts': 'instances',
    'serches': 'searches',
    'iisc': 'it is correct',
    'acheve': 'achieve',
    'justinyan': 'Justin Yan',
    'queyr': 'query',
    'fut': 'future',
    'gens': 'generations',
    '2gthr': 'together',
    'cur': 'current',
    'inc': 'include',
    'info': 'information',
    'b/c': 'because',
    'pri': 'priority',
    'acs': 'access',
    'bc': 'because',
    'freq': 'frequent',
    'freqly': 'frequently',
    'freqcy': 'frequency',
    'wnt': 'want',
    'srs': 'serious',
    'c': 'c',
    'isc': 'is correct',
    'isinc': 'is incorrect',
    'w/': 'with',
    'vry': 'very',
    'alw': 'allow',
    'strt': 'start',
    'ltrs': 'letters',
    'shtct': 'shortcut',
    'tht': 'that',
    'posble': 'possible',
    'posbly': 'possibly',
    'src': 'source',
    'thn': 'then',
    'thts': 'thats',
    'imdly': 'immediately',
    'otherwse': 'otherwise',
    'kev': 'Kev',
    'colab': 'collaboration',
    'rsns': 'reasons',
    'infrnt': 'infront',
    'althou': 'although',
    'althgh': 'although',
    'thr': 'there',
    'bel': 'believe',
    'exprsd': 'expressed',
    'td': 'today',
    '2d': 'to do',
    'anyo': 'anyone nemor anymore',
    'comp': 'computer',
    'buildup': 'build-up',
    'whl': 'while',
    'dich': 'dichotomy',
    'whil': 'while',
    'evning': 'evening',
    'evnings': 'evenings',
    'strng': 'strong',
    'frc': 'force',
    'kp': 'keep',
    'grw': 'grow',
    'grwing': 'growing',
    'grws': 'grows',
    'posibl': 'possible',
    'svd': 'saved',
    'ctina': 'Christina',
    'azn': 'Asian',
    'hpns': 'happens',
    'hpn': 'happen',
    'vm': 'very much',
    'lern': 'learn',
    'lerning': 'learning',
    'supp': 'suppose',
    'stuf': 'stuff',
    'ltly': 'lately',
    'drp': 'drop',
    'drping': 'dropping',
    'occ': 'occassion',
    'occs': 'occassions',
    'stmch': 'stomach',
    'fls': 'feels',
    'rn': 'right now',
    'dunno': "don't know",
    'y': 'why',
    'mtr': 'matter',
    'mtrd': 'mattered',
    'mtrs': 'matters',
    'arnd': 'around',
    'goin': 'going',
    'efrt': 'effort',
    'arnt': "aren\\'t",
    'dir': 'directory',
    'val': 'value',
    '4evr': 'forever',
    'dng': 'doing',
    'ev': 'every',
    'chngs': 'changes',
    'chng': 'change',
    'comf': 'comfortable',
    'suprt': 'support',
    'sprt': 'sport',
    'imd': 'immediate',
    'hap': 'happen',
    'aprox': 'approximately',
    'wts': "what's",
    'ez': 'easy',
    'undrstnding': 'understanding',
    'lst': 'list',
    'whte': 'white',
    'hoisauce': 'Hoisin Sauce',
    'hoisinsauce': 'Hoisin Sauce',
    'sbs': 'slowly, but surely',
    'isnc': 'it is incorrect',
    'mayo': 'mayonaise',
    'actuly': 'actually',
    'basicly': 'basically',
    'prply': 'properly',
    'alumin': 'aluminum',
    'frds': 'friends',
    'frd': 'friend',
    'pls': 'please',
    'u': 'you',
    'chkpt/s': 'checkpoint',
    'reqd': 'required',
    'lazzefair': 'laizze-faire',
    'emc': 'EMC Learning Center',
    'loc': 'location',
    'evn': 'even',
    'folo/s': 'follow',
    'cr8': 'create',
    'delish': 'delicious',
    'delishh': 'delish',
    'msg/s': 'message',
    'brg': 'bring',
    'srcs': 'sources',
    'hvnt': "haven't",
    'nethg': 'anything',
    'slping': 'sleeping',
    'nds': 'needs',
    'wo': 'without',
    'bu': 'back-up',
    'thxus': 'than-yous',
    'cnt': "can\\'t",
    'cn': 'cannot',
    'thnking': 'thinking',
    '4ward': 'forward',
    'lrg': 'large',
    'lrgr': 'larger',
    'hrd': 'hard',
    'hardr': 'harder',
    'hrdr': 'harder',
    'mks': 'makes',
    'mk': 'make',
    'transltn': 'translation',
    'cmpnt': 'component',
    '2m': 'too much',
    'erlier': 'earlier',
    'xchg': 'exchange',
    'xchng': 'exchange',
    'mself': 'myself',
    'fl8': 'feeling',
    'mser/s': 'middle school student',
    'hser/s': 'high school student',
    '7': 'and',
    'diffly': 'differently',
    'wrld': 'world',
    'chldrn': 'children',
    'awa': 'as well as',
    'ne': 'any',
    'gv/s': 'give',
    'aea': 'appreciate everyone’s advice on this',
    'chg': 'change',
    'absly': 'absolutely',
    'ull': "you'll",
    'chi': 'Chinese',
    'nthg': 'nothing',
    'gdrive': 'Google Drive',
    '2day': 'today',
    '2mrw': 'tomorrow',
    'ans': 'answer',
    'on2': 'onto',
    'tgether': 'together',
    '2gether': 'together',
    'adverts': 'advertisements',
    'stdnts': 'students',
    'cb': 'Challenge Basketball',
    'brk': 'break',
    'wrg': 'wrong',
    'sm': 'some',
    'wimsies': 'whimsies',
    'diffs': 'difficulties',
    'nvr': 'never',
    'speces': 'species',
    'alota': 'a lot of',
    'eff': 'effect',
    'becom': 'become',
    'mor': 'more',
    'mems': 'memories',
    'mem': 'memory',
    'mech': 'mechanism',
    'rem': 'remember',
    'lving': 'living',
    'hnging': 'hanging',
    'mightve': "might've",
    'wudve': "would've",
    'cudve': "could've",
    'wndr': 'wonder',
    'diss': 'this is',
    'dese': 'of these',
    'abrevs': 'abbreviations',
    'abrev': 'abbreviation',
    'helthy': 'healthy',
    'gon': 'going to',
    'dnt': "don't",
    'nec': 'necessary',
    'pert': 'pertinent',
    'uncomf': 'uncomfortable',
    'fing': "f'ing",
    'asp': 'aspect',
    'deving': 'developing',
    'dev': 'Devin',
    'lifecy': 'lifecycle',
    'rly': 'really',
    'adv': 'advantage',
    'nxt': 'next',
    'lvl': 'level',
    'ty4g': 'Thanks for your guidance',
    'tyfg': 'thanks for your guidance',
    'somehow': 'some how',
    'opp': 'opportunity',
    'def': 'definitely',
    'defly': 'definitely',
    '2b': 'to be',
    'smo': 'someone',
    'essen': 'essentially',
    'essly': 'essentially',
    'sig': 'significant',
    'sigly': 'significantly',
    'twoc': 'The Way of China',
    'twoa': 'The Way of America',
    'ist': 'is to',
    'spk': 'speak',
    'tangi': 'tangible',
    'cc': 'chit-chat',
    'dled': 'downloaded',
    'dl': 'download',
    'popu': 'population',
    'leggo': "Let's go",
    'smtimes': 'sometimes',
    'ppls': "people's",
    'ppl': 'people',
    'istaw': 'is there a way',
    'imo': 'in my opinion',
    'alrdy': 'already',
    'facetime': 'FaceTime',
    'btwn': 'between',
    'waterb': 'waterbottle',
    'esq': 'esque',
    'imp': 'important',
    '4ever': 'forever',
    'ftham': 'Fort Hamilton',
    'fav': 'favorite',
    'yamisuke': 'Yami Sukehiro',
    'incorec': 'incorrect',
    'corec': 'correct',
    'nye': "New Year's Eve",
    'envs': 'environments',
    'bball': 'basketball',
    'yr': 'year',
    'aong': 'along',
    'tpofgr': 'the path of greatest resistance',
    'rslts': 'results',
    'rslt': 'result',
    'tpoflr': 'the path of least resistance',
    'ctown': 'C-Town',
    'bingo': 'Bingo',
    'advs': 'advantages',
    'dec': 'December',
    'mar': 'March',
    'feb': 'Februrary',
    'jan': 'January',
    'noness': 'nonessential',
    'recs': 'recommends',
    'drei': 'Andrei',
    'anythg': 'anything',
    'esp': 'especially',
    'viet': 'Vietnamese',
    'ese': 'else',
    'fe': 'for example',
    'xtra': 'extra',
    'nding': 'needing',
    'yt': 'Youtube',
    'evplace': 'every place',
    'whenev': 'whenever',
    'lrn': 'learn',
    'gv': 'give',
    'fl': 'feel',
    'ephemeraly': 'ephemerally',
    'evwhere': 'everywhere',
    'hving': 'having',
    'lkd': 'liked',
    'alwys': 'always',
    'ml': 'Maylynn',
    'fam': 'family',
    'ralph': 'Ralph',
    'lauren': 'Lauren',
    'utube': 'YouTube',
    'jayden': 'Jayden',
    'darren': 'Darren',
    'beleve': 'believe',
    'thou': 'though',
    'thru': 'through',
    'bobby': 'Bobby',
    'evt': 'everything',
    'ur': 'your',
    'thnk': 'think',
    'ssp': 'Sunset Park',
    'b': 'be',
    'itic': "I think it's correct",
    'folo': 'follow',
    'mygithubvimrc':
        'https://raw.githubusercontent.com/kdog3682/backup/master/.vimrc',
    'mygithubbashrc':
        'https://raw.githubusercontent.com/kdog3682/backup/master/.bashrc',
    'mypersonalwebsite': 'https://zzsdfidsfsfdasdf',
    'myemail': 'kdog3682@gmail.com',
    'ayga': 'Appreciate your advice',
    'ubiq': 'ubiquitous',
    'ubiqitis': 'ubiquitous',
    't4yh': 'Thanks for your help',
    'aygaot': "Appreciate your guys's advice on this",
    'ayaot': 'Appreciate your advice on this',
    'tyvm4th': 'Thank you very much for the help',
    'tis': 'this is',
    'hw': 'homework',
    'tfth': 'Thanks for the help',
    't4th': 'Thanks for the help',
    'gonna': 'going to',
    'st': 'start',
    'wanna': 'want to',
    'w': 'with',
    'abble': 'able',
    'dne': '!=',
    'wasnt': "wasn't",
    'lking': 'looking',
    'didnt': "didn't",
    'evr': 'ever',
    'fevr': 'forever',
    'hapd': 'happened',
    'hapn': 'happen',
    'np': 'No Problem',
    'npaa': 'No problem at all!',
    'purp': 'purpose',
    'ts': 'this',
    't': 'the',
    'ot': 'of this',
    'cls': 'class',
    'mny': 'money',
    'isto': 'is to',
    'tpo': 'the purpose of',
    'prp': 'purpose',
    'receve': 'receive',
    'evo': 'everyone',
    'tu': 'thank you',
    'wen': 'when',
    'nd': 'need',
    'thgs': 'things',
    'simp': 'simple',
    'diff': 'difference',
    'diffi': 'difficulty',
    'xmas': 'Christmas',
    'thxgiving': 'Thanksgiving',
    'mxmas': 'Merry Christmas',
    'sry': 'sorry',
    'receved': 'received',
    'haneka': 'Hanukkah',
    'lbrphone': '----------',
    'lbr': '----------',
    'ty4th': 'Thanks for the help!',
    'im': "I'm",
    'evthg': 'everything',
    'wd': 'would',
    'sd': 'should',
    'wt': 'what',
    'Thx': 'Thanks',
    'thg': 'thing',
    'smth': 'something',
    'doesnt': "doesn't",
    'whats': "what's",
    'euivalent': 'equivalent',
    'ive': "I've",
    'b4': 'before',
    'tmrw': 'tomorrow',
    'mv': 'move',
    'hv': 'have',
    'ny': 'New York',
    'bklyn': 'Brooklyn',
    'wa': 'Washington',
    'i': 'I',
    'its': "it's",
    'itz': 'its',
    'r': 'are',
    'theyre': "they're",
    'hasnt': "hasn't",
    'wud': 'would',
    'youre': "you're",
    'arent': "aren't",
    'wudnt': "wouldn't",
    'shud': 'should',
    'shudve': "should've",
    'shudnt': "shouldn't",
    'becky': 'Becky',
    'maylynn': 'Maylynn',
    'obs': 'observation',
    'obss': 'observations',
    'exp': 'experience',
    'exps': 'experiences',
    'reg': 'regular',
    'eo': 'everyone',
    'tm': 'tomorrow',
    'prep': 'prepare',
    'cud': 'could',
    'cudnt': "couldn't",
    'gm': 'Good morning',
    'prbly': 'probably',
    'dont': "don't",
    'wont': "won't",
    'dis': 'this',
    'gud': 'good',
    'isnt': "isn't",
    'couldnt': "couldn't",
    'shouldnt': "shouldn't",
    'wouldnt': "wouldn't",
    'cant': "can't",
    'hey': 'Hey',
    'ex': 'example',
    'exs': 'examples',
    'thats': "that's",
    'diffclty': 'difficulty',
    'diffclt': 'difficulty',
}

def proseregex(dict):
    return '\\b' + ncg(dict) + '\\b'
    return '\\b' + ncg(dict) + '(?=\s|,|\.|\!|$|\'|\"|\))'

pyimportdict = {
    "contextmanager": "from contextlib import contextmanager",
    "pprint": "from pprint import pprint",
    "re": "import regex as re",
    "urllib": "import urllib.request",
    "math": "import math",
    "webbrowser": "import webbrowser",
    "requests": "import requests",
    "traceback": "import traceback",
    "StringIO": "from io import StringIO",
    "FPDF": "from fpdf import FPDF",
    "fbchat": "import fbchat",
    "sys": "import sys",
    "praw": "import praw",
    "subprocess": "import subprocess",
    "shutil": "import shutil",
    "socket": "import socket",
    "inspect": "import inspect",
    "datetime": "import datetime",
    "time": "import time",
    "json": "import json",
    "os": "import os",
    "random": "import random",
    "unicodedata": "import unicodedata",
}

mdrive = "/users/harfunmaterials/Google Drive"
gdrive = "/mnt/chromeos/GoogleDrive/MyDrive/"
importre = '\b(?:sys|praw|default_timer|difflib|urllib|itertools|html|requests|subprocess|shutil|socket|inspect|datetime|time|json|sys|re|os)(?=\.)|\b(?:black|FPDF|fbchat|pprint\()(?=\()'

pmwb = {
    "wts": "what's",
    "ty4th": "Thanks for the help!",
    "im": "I'm",
    "evthg": "everything",
    "wd": "would",
    "sd": "should",
    "wt": "what",
    "Thx": "Thanks",
    "thgs": "things",
    "thg": "thing",
    "smth": "something",
    "lk": "like",
    "ty": "thanks",
    "thx": "thanks",
    "doesnt": "doesn't",
    "whats": "what's",
    "euivalent": "equivalent",
    "thnk": "think",
    "ive": "I've",
    "b4": "before",
    "tmrw": "tomorrow",
    "mv": "move",
    "hv": "have",
    "ny": "New York",
    "bklyn": "Brooklyn",
    "wa": "Washington",
    "i": "I",
    "its": "it's",
    "itz": "its",
    "r": "are",
    "theyre": "they're",
    "hasnt": "hasn't",
    "u": "you",
    "wud": "would",
    "youre": "you're",
    "arent": "aren't",
    "wudnt": "wouldn't",
    "shud": "should",
    "shudnt": "shouldn't",
    "becky": "Becky",
    "maylynn": "Maylynn",
    "obs": "observation",
    "obss": "observations",
    "exp": "experience",
    "exps": "experiences",
    "reg": "regular",
    "eo": "everyone",
    "td": "today",
    "tm": "tomorrow",
    "prep": "prepare",
    "cud": "could",
    "cudnt": "couldn't",
    "gm": "Good morning",
    "prbly": "probably",
    "dont": "don't",
    "wont": "won't",
    "dis": "this",
    "gud": "good",
    "ne": "any",
    "shudnt": "shouldn't",
    "isnt": "isn't",
    "couldnt": "couldn't",
    "shouldnt": "shouldn't",
    "wouldnt": "wouldn't",
    "cant": "can't",
    "hey": "Hey",
    "ex": "example",
    "exs": "examples",
    "thats": "that's",
}

pmwb = {
    "wts": "what's",
    "ty4th": "Thanks for the help!",
    "im": "I'm",
    "evthg": "everything",
    "wd": "would",
    "sd": "should",
    "wt": "what",
    "Thx": "Thanks",
    "thgs": "things",
    "thg": "thing",
    "smth": "something",
    "lk": "like",
    "ty": "thanks",
    "thx": "thanks",
    "doesnt": "doesn't",
    "whats": "what's",
    "euivalent": "equivalent",
    "thnk": "think",
    "ive": "I've",
    "b4": "before",
    "tmrw": "tomorrow",
    "mv": "move",
    "hv": "have",
    "ny": "New York",
    "bklyn": "Brooklyn",
    "wa": "Washington",
    "i": "I",
    "its": "it's",
    "itz": "its",
    "r": "are",
    "theyre": "they're",
    "hasnt": "hasn't",
    "u": "you",
    "wud": "would",
    "youre": "you're",
    "arent": "aren't",
    "wudnt": "wouldn't",
    "shud": "should",
    "shudnt": "shouldn't",
    "becky": "Becky",
    "maylynn": "Maylynn",
    "obs": "observation",
    "obss": "observations",
    "exp": "experience",
    "exps": "experiences",
    "reg": "regular",
    "eo": "everyone",
    "td": "today",
    "tm": "tomorrow",
    "prep": "prepare",
    "cud": "could",
    "cudnt": "couldn't",
    "gm": "Good morning",
    "prbly": "probably",
    "dont": "don't",
    "wont": "won't",
    "dis": "this",
    "gud": "good",
    "ne": "any",
    "shudnt": "shouldn't",
    "isnt": "isn't",
    "couldnt": "couldn't",
    "shouldnt": "shouldn't",
    "wouldnt": "wouldn't",
    "cant": "can't",
    "hey": "Hey",
    "ex": "example",
    "exs": "examples",
    "thats": "that's",
}

ignorelist = [
    'div',
    'pattern', 'requirement', 'target', 'gradelevel', 'operator', 'pick', 'choices', 'answer', 'template', 'length', 'clength', 'question', 'questions', 'bins', 'bin', 'outpath', 'inpath', 'filepath', 'chunks', 'destination', 'lowerIndex', 'upperIndex', 
    'tde',
    'prev',
    'iOS',
    'new', 
    'etype',
    'first',
    'last',
    'next',
    'tep',
    'always',
    'payload',
    'prev',
    'force',
    'sort', 
    'open',
    'flags', 'ttps',
    "build", 'replacement',
    "current",
    "storage",
    "lines",
    "pass",
    "break",
    "default",
    "Object",
    "RegExp",
    "JSON",
    "console",
    "console.log",
    "function",
    "def",
    "key",
    "keys",
    "fs",
    "round",
    "exec",
    "stderr",
    "stdout",
    "parserHandler",
    "recursiveRunner",
    "runner",
    "format",
    "catch",
    "raise",
    "try",
    "except",
    "super",
    "decode",
    "encode",
    "uri",
    "recursive",
    "escape",
    "callable",
    "chunk",
    "data",
    "fontFamily",
    "fontSize",
    "sortkey" "seen",
    "capture",
    "bool",
    "extra",
    "left",
    "top",
    "bottom",
    "right",
    "section",
    "isinstance",
    "instanceof",
    "enumerate",
    "longest",
    "array",
    "dir",
    "byte",
    "bytes",
    "int",
    "max",
    "min",
    "files",
    "str",
    "set",
    "continue",
    "int",
    "char",
    "config",
    "Config",
    "return",
    "false",
    "index",
    "true",
    "resolve",
    "reject",
    "res",
    "rej",
    "css",
    "html",
    "python",
    "print",
    "require",
    "trim",
    "strip",
    "tags",
    "Error",
    "tag",
    "title",
    "option",
    "options",
    "opts",
    "acc",
    "before",
    "after",
    "filter",
    "names",
    "params",
    "param",
    "count",
    "isNaN",
    "objects",
    "location",
    "spaces",
    "arr",
    "string",
    "arg",
    "args",
    "placeholder",
    "error",
    "value",
    "line",
    "sentence",
    "file",
    "regex",
    "ReferenceError",
    "SyntaxError",
    "ValueError",
    "child",
    "parent",
    "grandchild",
    "content",
    "output",
    "input",
    "start",
    "end",
    "Function",
    "delimiter",
    "range",
    "object",
    "parseFloat",
    "parseInt",
    "Array",
    "Number",
    "String",
    "isNaN",
    "eval",
    "isFinite",
    "NaN",
    "encodeURI",
    "decodeURI",
    "encodeURIComponent",
    "decodeURIComponent",
    "text",
    "lang",
    "len",
    "length",
    "idx",
    "index",
    "this",
    "self",
    "action",
    "parser",
    "list",
    "dict",
    "map",
    "Map",
    "key",
    "val",
    "name",
    "items",
    "abc",
    "result",
    "product",
    "cat",
    "type",
    "mode",
    "null",
    "true",
    "false",
    "None",
    "setTimeout",
    "setInterval",
    "True",
    "False",
    "store",
    "matches",
    "ignore",
    "match",
    "if",
    "elif",
    "else",
    "while",
    "for",
    "item",
]

regexdict = {
    'csp': '(\\S+)',
    'wallu': '[\\w\\W]+?',
    'cwallu': '([\\w\\W]+?)',
    'cwall': '([\\w\\W]*)',
    'cwp': '(\\w+)',
    'nwp': '\\w+',
    'cdp': '(\\d+)',
    'ndp': '\\d+',
    'ncg': '(?:',
    'plb': '(?<=',
    'nlb': '(?<!',
    'nla': '(?!',
    'pla': '(?=',
    'cdotu': '(.*?)',
    'dotu': '.*?',
    'asp': '\\s*',
    'cdot': '(.*)',
    'cdazp': '([-.a-zA-Z]+)',
    'dazp': '[a-zA-Z-.]+',
    'cazp': '([a-zA-Z]+)',
    'azppp': '[a-zA-Z]{3,}',
    'azp': '[a-zA-Z]+',
    '8': '*',
    'q': '?',
    '9': '(',
    '0': ')',
    '6': '^',
    '4': '$',
    'az': '[a-zA-Z]',
    '2la': '.*\\n.*\\n',
    'sn': '\\n',
    'divcode': '^<(?:div|code|pre).*',
}


stopwords = [
    'a',
    'about',
    'above',
    'after',
    'again',
    'against',
    'all',
    'am',
    'an',
    'and',
    'any',
    'are',
    "aren't",
    'as',
    'at',
    'be',
    'because',
    'been',
    'before',
    'being',
    'below',
    'between',
    'both',
    'but',
    'by',
    "can't",
    'cannot',
    'could',
    "couldn't",
    'did',
    "didn't",
    'do',
    'does',
    "doesn't",
    'doing',
    "don't",
    'down',
    'during',
    'each',
    'few',
    'for',
    'from',
    'further',
    'had',
    "hadn't",
    'has',
    "hasn't",
    'have',
    "haven't",
    'having',
    'he',
    "he'd",
    "he'll",
    "he's",
    'her',
    'here',
    "here's",
    'hers',
    'herself',
    'him',
    'himself',
    'his',
    'how',
    "how's",
    'i',
    "i'd",
    "i'll",
    "i'm",
    "i've",
    'if',
    'in',
    'into',
    'is',
    "isn't",
    'it',
    "it's",
    'its',
    'itself',
    "let's",
    'me',
    'more',
    'most',
    "mustn't",
    'my',
    'myself',
    'no',
    'nor',
    'not',
    'of',
    'off',
    'on',
    'once',
    'only',
    'or',
    'other',
    'ought',
    'our',
    'ours',
    'ourselves',
    'out',
    'over',
    'own',
    'same',
    "shan't",
    'she',
    "she'd",
    "she'll",
    "she's",
    'should',
    "shouldn't",
    'so',
    'some',
    'such',
    'than',
    'that',
    "that's",
    'the',
    'their',
    'theirs',
    'them',
    'themselves',
    'then',
    'there',
    "there's",
    'these',
    'they',
    "they'd",
    "they'll",
    "they're",
    "they've",
    'this',
    'those',
    'through',
    'to',
    'too',
    'under',
    'until',
    'up',
    'very',
    'was',
    "wasn't",
    'we',
    "we'd",
    "we'll",
    "we're",
    "we've",
    'were',
    "weren't",
    'what',
    "what's",
    'when',
    "when's",
    'where',
    "where's",
    'which',
    'while',
    'who',
    "who's",
    'whom',
    'why',
    "why's",
    'with',
    "won't",
    'would',
    "wouldn't",
    'you',
    "you'd",
    "you'll",
    "you're",
    "you've",
    'your',
    'yours',
    'yourself',
    'yourselves',
]


easywords = [
  "help",
  "hi",
  "hello",
  "bye",
  "account",
  "acid",
  "act",
  "addition",
  "adjustment",
  "advertisement",
  "after",
  "again",
  "against",
  "agreement",
  "air",
  "and",
  "anger",
  "angle",
  "animal",
  "apparatus",
  "apple",
  "approval",
  "arch",
  "argument",
  "arm",
  "army",
  "art",
  "attraction",
  "authority",
  "awake",
  "baby",
  "back",
  "bag",
  "balance",
  "ball",
  "band",
  "basin",
  "basket",
  "beautiful",
  "bed",
  "bee",
  "beetle",
  "behaviour",
  "belief",
  "bell",
  "bent",
  "bird",
  "bit",
  "bite",
  "black",
  "blade",
  "blood",
  "board",
  "body",
  "boil",
  "bone",
  "book",
  "boot",
  "bottle",
  "box",
  "boy",
  "brain",
  "brake",
  "branch",
  "brass",
  "bread",
  "brick",
  "bridge",
  "brown",
  "brush",
  "bucket",
  "burn",
  "business",
  "butter",
  "button",
  "cake",
  "canvas",
  "card",
  "cart",
  "cattle",
  "chain",
  "chalk",
  "cheese",
  "child",
  "chin",
  "clear",
  "clock",
  "cloud",
  "coal",
  "coat",
  "cold",
  "collar",
  "colour",
  "comb",
  "comparison",
  "competition",
  "complex",
  "condition",
  "connection",
  "cooking",
  "copy",
  "cord",
  "cork",
  "cotton",
  "country",
  "credit",
  "crime",
  "cup",
  "current",
  "cushion",
  "daughter",
  "day",
  "death",
  "debt",
  "destruction",
  "difference",
  "digestion",
  "direction",
  "dirty",
  "discovery",
  "discussion",
  "disease",
  "distribution",
  "division",
  "door",
  "drain",
  "drink",
  "ear",
  "earthworm",
  "east",
  "edge",
  "education",
  "egg",
  "electricity",
  "engine",
  "equal",
  "error",
  "example",
  "existence",
  "experience",
  "eye",
  "face",
  "fact",
  "failure",
  "fall",
  "false",
  "farm",
  "fat",
  "father",
  "fear",
  "feather",
  "female",
  "fertility",
  "fiction",
  "field",
  "finger",
  "fire",
  "fish",
  "flag",
  "flat",
  "flight",
  "floor",
  "flower",
  "fly",
  "food",
  "foolishness",
  "foot",
  "fork",
  "fowl",
  "frame",
  "free",
  "friend",
  "fruit",
  "future",
  "garden",
  "girl",
  "girlfriend",
  "glass",
  "gold",
  "good",
  "government",
  "grain",
  "grass",
  "gray",
  "green",
  "group",
  "growth",
  "gun",
  "hair",
  "hammer",
  "hand",
  "harbor",
  "hat",
  "hatred",
  "head",
  "talk",
  "contributions",
  "categorytalk",
  "help",
  "tools",
  "sandbox",
  "wiktionary",
  "sicilianu",
  "help",
  "health",
  "hearing",
  "heart",
  "heat",
  "history",
  "hook",
  "hope",
  "horn",
  "horse",
  "hospital",
  "hour",
  "house",
  "ice",
  "idea",
  "if",
  "impulse",
  "industry",
  "ink",
  "insect",
  "intelligence",
  "invention",
  "island",
  "jelly",
  "jewel",
  "judge",
  "jump",
  "kettle",
  "key",
  "kick",
  "kind",
  "kiss",
  "knee",
  "knife",
  "knot",
  "knowledge",
  "land",
  "leaf",
  "leg",
  "letter",
  "like",
  "limit",
  "line",
  "lip",
  "liquid",
  "list",
  "lock",
  "love",
  "machine",
  "man",
  "manager",
  "map",
  "market",
  "match",
  "measure",
  "memory",
  "milk",
  "minute",
  "modular",
  "money",
  "monkey",
  "month",
  "moon",
  "morning",
  "mother",
  "motion",
  "mountain",
  "mouth",
  "move",
  "muscle",
  "music",
  "nail",
  "name",
  "nation",
  "native",
  "necessary",
  "nerve",
  "new",
  "no",
  "north",
  "nose",
  "now",
  "number",
  "nut",
  "observation",
  "of",
  "office",
  "oil",
  "old",
  "operation",
  "opinion",
  "opposite",
  "order",
  "organization",
  "oven",
  "pain",
  "paint",
  "pants",
  "paper",
  "parallel",
  "parcel",
  "paste",
  "peace",
  "pen",
  "physical",
  "plant",
  "plate",
  "plow",
  "pocket",
  "poison",
  "polish",
  "porter",
  "position",
  "power",
  "price",
  "prison",
  "property",
  "protest",
  "punishment",
  "question",
  "rail",
  "rain",
  "rat",
  "reading",
  "receipt",
  "record",
  "red",
  "relation",
  "religion",
  "representative",
  "reward",
  "rhythm",
  "rice",
  "ring",
  "river",
  "road",
  "rod",
  "roof",
  "root",
  "round",
  "sadness",
  "safe",
  "sail",
  "salt",
  "sand",
  "school",
  "science",
  "scissors",
  "screw",
  "second",
  "secret",
  "secretary",
  "seed",
  "sense",
  "shade",
  "sharp",
  "shelf",
  "ship",
  "shoe",
  "sibling",
  "sign",
  "silk",
  "silver",
  "simplicity",
  "single",
  "size",
  "skin",
  "skirt",
  "sky",
  "sleep",
  "slope",
  "slow",
  "smell",
  "snake",
  "sneeze",
  "snow",
  "sock",
  "solid",
  "son",
  "song",
  "sound",
  "soup",
  "south",
  "spade",
  "sponge",
  "spoon",
  "spring",
  "square",
  "start",
  "station",
  "steam",
  "steel",
  "sticky",
  "stomach",
  "stone",
  "store",
  "straight",
  "talk",
  "contributions",
  "categorytalk",
  "help",
  "tools",
  "sandbox",
  "wiktionary",
  "sicilianu",
  "help",
  "street",
  "substance",
  "success",
  "sugar",
  "suggestion",
  "sun",
  "support",
  "surprise",
  "sweet",
  "swim",
  "system",
  "tail",
  "taste",
  "tax",
  "test",
  "textile",
  "this",
  "thread",
  "thumb",
  "thunder",
  "ticket",
  "time",
  "to",
  "toe",
  "tongue",
  "tooth",
  "town",
  "transport",
  "tray",
  "tree",
  "truth",
  "umbrella",
  "unit",
  "value",
  "view",
  "voice",
  "walk",
  "wall",
  "war",
  "warm",
  "wash",
  "waste",
  "wave",
  "weather",
  "week",
  "weight",
  "well",
  "west",
  "wheel",
  "whip",
  "whistle",
  "white",
  "will",
  "wind",
  "window",
  "wine",
  "wing",
  "wire",
  "woman",
  "wood",
  "wool",
  "word",
  "work",
  "writing",
  "year",
  "yellow",
  "yes",
  "yesterday",
  "you",
  "talk",
  "contributions",
  "help",
  "tools",
]
advancedimports = [
    "black",
    "FPDF",
    "fbchat",
    "sys\.",
    "praw\.",
    "default_timer\.",
    "difflib\.",
    "urllib\.",
    "itertools\.",
    "pprint",
    "html\.",
    "requests\.",
    "subprocess\.",
    "shutil\.",
    "socket\.",
    "inspect\.",
    "datetime\.",
    "time\.",
    "json\.",
    "sys\.",
    "re\.",
    "os\.",
]
anyCommentRE = '^ *(?:#|//|").+\n?'

swearwords = [
  "cocksucker",
  "sweet Jesus",
  "piss",
  "bollocks",
  "bullshit",
  "sisterfucker",
  "fatherfucker",
  "brotherfucker",
  "effing",
  "bugger",
  "Christ on a bike",
  "Christ on a cracker",
  "Jesus Harold Christ",
  "Jesus wept",
  "godsdamn",
  "Jesus fuck",
  "motherfucker",
  "cunt",
  "hell",
  "crap",
  "arse",
  "ass",
  "asshole",
  "bastard",
  "bitch",
  "bollocks",
  "brotherfucker",
  "bugger",
  "bullshit",
  "child-fucker",
  "Christ on a bike",
  "Christ on a cracker",
  "cocksucker",
  "crap",
  "cunt",
  "damn",
  "effing",
  "fatherfucker",
  "frigger",
  "fuck",
  "goddamn",
  "godsdamn",
  "hell",
  "holy shit",
  "horseshit",
  "Jesus Christ",
  "Jesus fuck",
  "Jesus H. Christ",
  "Jesus Harold Christ",
  "Jesus wept",
  "Jesus, Mary and Joseph",
  "Judas Priest",
  "motherfucker",
  "nigga",
  "piss",
  "prick",
  "shit",
  "shit ass",
  "shitass",
  "sisterfucker",
  "slut",
  "son of a bitch",
  "son of a whore",
  "sweet Jesus",
  "twat",
]
---------------------------------
[animations.js 12-12-2022]:
function animated(el, key, start, end, options = 1000) {
    el.style[key] = start
    const animation = el.animate([{[key]: start}, {[key]: end}], options)
    return animation.finished.then(() => el.style[key] = end)
}
----------------------------------
[animations.js 12-12-2022]:
function appeardisappear(el, duration = 2000) {
    el.style.opacity = 0
    const keyframes = [
        {opacity : 0, offset: 0},
        {opacity : 1, offset: 0.1},
        {opacity : 1, offset: 0.9},
        {opacity : 0, offset: 1},
    ]
    const options = {
        duration,
        fill: 'forwards',
    }

    return el.animate(keyframes, options).finished.then((x) => el.style.opacity = 0)
}
----------------------------------
[finderror.js 12-12-2022]:
function mainFindError() {
    const process = require('process')
    const buffer = process.argv[2]
    const fs = require('fs')
    const read = (buffer) => fs.readFileSync(buffer, 'utf8')
    const text = read(buffer)
    findError(text)

    function findError(s) {
        function getChunks(s) {
            const r = /\n+(?=[\w.#])/
            return s.trim().split(r)
        }

        const chunks = getChunks(s)
        const store = []

        for (let chunk of chunks) {
            try {
                eval(chunk)
            } catch (e) {
                if (e.constructor.name == 'ReferenceError') {
                    continue
                }
                store.push([e.toString(), chunk])
            }
        }
        if (store.length > 0) {
            console.log(store)
            console.log(store.length)
        } else {
            console.log('no errors!')
        }
    }
}
----------------------------------
[html3.js 12-12-2022]:
const MathQuill = {
    template: `
        <div class="math-quill-component"></div>
    `,
    props: ['answer'],
    methods: {
        onEnter() {
            const userAnswer = this.quill.latex()
            const answerKey = this.answer
            const isCorrect = this.checkAnswer(userAnswer, answerKey)
            this.$emit('on-enter', isCorrect)
        },
        onEdit() {
            this.onEnter()
            console.log('hi from edit')
        }
    },
}
----------------------------------
[html3.js 12-12-2022]:
const MathSection = {
    components: {StandardKatexQuestion, MathQuill},
    template: `
        <div class="math-section-component">
            <div class="index">{{index}}</div>
            <div class="intro">{{question.intro}}</div>
            <standard-katex-question :style="computedStyleIsCorrect" :question="question.question"/>
            <div v-show="isCorrect" class="checkmark"></div>
            <math-quill @onEnter="isCorrect = $event" :answer="question.answer"/>
        </div>
    `,
    props: ['question', 'index'],
    data() {
        return {
            isCorrect: '',
        }
    },
    computed: {
        computedStyleIsCorrect() {
            return 'hi'
        }
    },
}
----------------------------------
[html3.js 12-12-2022]:
const App = {
    components: {MathSection},
    template: `
        <div class="app-component">
            <div class="title">math practice</div>
            <div class="section-container">
                <math-section
                    v-for="(question, index) in questions"
                    :question="question"
                    :index="index"
                />
            </div>
            <div class="encouragement">nice work!</div>
        </div>
    `,
    data() {
        return {
            questions: [],
        }
    },
    methods: {
        foo() {
            console.log('saying hi')
        }
    },
}
----------------------------------
[f.js 12-12-2022]:
function doGoogle(f, data) {
    const fetch = require('node-fetch')
    const { read } = require('./node-utils.js')

    function fetchPost(url, data) {
        fetch(url, {
            method: 'POST',
            body: JSON.stringify(data),
            headers: { 'Content-Type': 'application/json' },
        })
            .then((res) => res.json())
            .then((json) => console.log(json))
    }

    function callGoogle(f, data) {
        let appscriptfile = '/home/kdog3682/CWF/public/app2.js'
        let googleUrl =
            'https://script.google.com/macros/s/AKfycbx3VFYdpdvIOMu6g5WFs4965dcYf7rTfF3YKDZ-Hr-KmUVut9My7qcOeqpeSJuMGbY3/exec'

        let callable = f ? toStringCallable(f, data) : ''
        //callable = '23 + 34'
        let s = read(appscriptfile) + '\n\n' + callable
        fetchPost(googleUrl, { evaluate: s })
    }

    callGoogle()
}
----------------------------------
[class.js 12-17-2022]:
----------------------------------
[class.js 12-23-2022]:
----------------------------------
[ss.js 12-28-2022]:
function le(s) {
    function f(...args) {
        console.log(args)
    }
    
    alist = ['a', 'b', 'c', 'd', 'e']
    
    f(...alist, 'hi')
}
----------------------------------
[ss.js 12-28-2022]:
----------------------------------
[ss.js 12-28-2022]:
function value(value = 'a') {
    return {
        value: value.toUpperCase()
    }
}
----------------------------------
[Lezer.js 01-02-2023]:
class Foo {
    constructor() {
    }
    boo() {
        
    }
}
----------------------------------
[utils.js 01-04-2023]:
function makeRunnerFromSource(r, items) {
    for (let [a,b] of partition(items)) {
        if (a(r)) {
            return getParameters(b).length == 2 ?
                b : curryEnd(b)
        }
    }
}
----------------------------------
[CodeOrganizer.js 01-04-2023]:
class CodeFile2 {
    organize() {
        function runner(info, lezer) {
            console.log(lezer)
            throw ''
        }
        runLezer(this.text, runner)
    }
    constructor(file) {
        this.file = file
    }
    get name() {
        return tail(this.file)
    }
    get text() {
        return this._text = 
            this._text || read(this.file)
    }
    get names() {
        return this._names = 
            this._names || getBindingNames(this.text)
    }
    get implied() {
        return this._implied = 
            this._implied || getImplied(this.text)
    }

    get library() {
        return this._library =
            this._library || getLibrary(this.text)
    }

    get imports() {
        return this._imports =
            this._imports || getImports(this.text)
    }

    get exports() {
        return this._exports =
            this._exports || getExports(this.text)
    }

    get body() {
        return this._body =
            this._body || getBody(this.text)
    }

    get utils() {
        return this._utils =
            this._utils || new CodeFile('utils.js')
    }

    addExports() {
        //let s = parseCodeFile(this.text, null, this.names)
        //write(this.file, s)
    }
    addFunctions() {
        let missing = this.implied
        if (!exists(missing)) {
            return console.log('no functions to add because everything is in place')
        }
        console.log(missing); throw '';
        write(this.file, s)
    }
    fulfill() {
        let exports = this.names.filter(isCapitalized)
        let imports = {
            'utils.js': shared(this.implied, this.utils.names)
        }
        //console.log(imports); throw '';
        let others = unique(this.implied, this.utils.names)
        let org = new CodeOrganizer()
        //org.lib.getRecursiveDependencies(others)
        let codeItems = org.fulfill(others)
        //console.log(Object.keys(codeItems))
        //console.log(Object.keys(org.fulfill(others)))
        //return
        let s = parseCodeFile(
            this.text, imports, exports, Object.values(codeItems)
        )
        //clip(s)
        //return
        write(this.file, s)
    }
    moveSmallFunctionsToUtils() {
        
    }
    async askMove() {
        const names = this.names.filter(isFunctionString)
        const popped = await choose(names)
        /* this is a useful thing */
        return fulfill(this.file, {
            addExports: null,
            addImports: popped,
            removeItems: popped,
        })
    }
    addImports(dict) {
        this._imports = mergeOnTop(this.imports, dict)
    }
    iiixxxxfulfill() {
        const organizer = new CodeOrganizer()
        const dict = organizer.fulfill(this.implied)
        const [keys, values] = unzip(dict)

        throw ''
        console.log(Object.keys(dict)); throw '';
        throw ''
        const imports = organizer.getImports()
        console.log(imports); throw '';
        console.log(); throw '';
        console.log(moduleImports(organizer.getImports()))
        return 
        //console.log(Object.keys(dict)); throw '';
        append(this.file, join(Object.values(dict)))
    }
}
----------------------------------
    //console.log(editor.iterate('getLineInfo'))
    //console.log(editor.find("okay", { dir: 1, start: ".", move: true }))
    //console.log(editor.find("yum", { dir: 1, start: ".", move: true }))
----------------------------------
[base.py 01-05-2023]:
def ff(
    dir=".",
    mode=0,
    sort=0,
    find=0,
    move=0,
    copy=0,
    fn=0,
    **kwargs,
):

    extensions = []

    def f(k, v):
        if k in utfe:
            extensions.append(k)
        elif k == "noe":
            extensions.append("")
        else:
            return v

    #kwargs = map(kwargs, f)
    #if extensions:
        #kwargs["extensions"] = extensions
    check = checkpointf(**kwargs)
    dir = absdir(dirgetter(dir))
    # print(dir)
    # pprint(kwargs)
    # return

    if find:
        files = [globals().get("find")(dir, check)]
    else:
        files = filter(dir, check)
        print(len(files))

    if not files:
        return print("no files")

    if sort:
        files.sort(key=mdate)

    if fn:
        prompt(files)
        return flat(map(files, fn))

    if mode == "debug":
        s = "%A %B %d -- %-I:%M:%S%p"
        pprint(
            map(files, lambda x: (tail(x), datestamp(x, s)))
        )

    elif mode == "review":
        files = _cleandir(files)
        map(files, askToRemove)

    elif mode == "open":
        map(files, ofile)

    elif mode == "info":
        map(files, fileInfo)

    elif copy:
        map(files, cfile, dirgetter(copy))

    elif move:
        map(files, mfile, dirgetter(move))

    else:
        pprint(files)

    return files
----------------------------------
[base.py 01-05-2023]:
def uploadMathHomework(
    file="Math Homework.pdf",
    subject="Math Homework",
    body="",
    attachments="",
    ):
    chdir(dldir)
    sendToOutboundDrive(file)
    file = tail(file)
    attachmentString = file
    callable = f"""
        email2({{
            'attachments': '{attachmentString}',
            'subject': '{subject}',
            'body': '{body}',
            'from': 'kevinlulee1@gmail.com',
        }})
    """
    googleAppScript(callable)
----------------------------------
[OX3HTML.js 01-09-2023]:
const E3HTML = {
    key: "CreateE3",
    options: {
        blahblah: true,
        mode: Object,
    },
    items: [
        { regex: /^([#.])(\w+)/, parser: "handleIdOrClass" },
        {
            regex: /([@:])(\w+)(?: *= *(\S+))?/,
            parser: "handleVueAttr",
        },
        {
            regex: /(\w+(?:[.-]\w\+)?) *= *({.*?}|\[.*?\]|\S+)/,
            parser: "handleNormalAttr",
        },

        {
            regex: /.+/,
            parser: "default",
        },
    ],
    default(s) {
        return ['text', s]
    },
    handleIdOrClass(a, b) {
        if (a == "#") {
            return ["id", b]
        }
        return ["class", b]
    },

    handleVueAttr(symbol, a, b, externalArg) {
        //console.log({symbol, a, b})
        function vuePropHelper(a, b) {
            return [symbol + a, b]
        }

        if (symbol == ':' && isWord()) {
            const j = a.slice(1)
            return vuePropHelper(a, VUE_SINGLE_TO_DOUBLE_REF[j] || j)
        }

        a = HTML_MASTER_KEY_MAP[a] || a
        return vuePropHelper(a, b)
    },
    handleNormalAttr(a, b) {
        console.log({a, b})
        a = HTML_MASTER_KEY_MAP[a] || a
        if (a == "v-for" && isWord(b)) {
            b = inlineForParser(b)
        }
        return [a, b]
    },
}
----------------------------------
LineEdit.js
let str0110 = `
bo {
    hi
    okay
    smart  go to the store
    bob {
        safsdf
        sdfdf
    }
}
`
console.log(combineBrackets(str0110))

----------------------------------
[server.js 01-19-2023]:
function resetApp(app) {
    app.set("etag", false)
    app.disable("view cache")
    app.use((req, res, next) => {
        res.set("Cache-Control", "no-store")
        next()
    })
}
app.use(express.static(CURRENT_DIRECTORY))
app.get("/", mainGet)
app.listen(PORT, mainListen)
app.use("/birds", birdRouter)
----------------------------------
[LineEdit.js 01-23-2023]:
function combineBrackets(s) {
    function getRE(n) {
        const spaces = " ".repeat(n)
        const r = `^(${spaces})([\\w-]+) {([^]+?)${spaces}}`
        return RegExp(r, "gm")
    }
    function runner(_, spaces, a, b) {
        b = b.trim().replace(/\n */g, ";")
        return `${spaces}${a} {${b}}`
    }

    const spacings = sorted(
        unique(
            findall(/^( *)[\w-]+ {/gm, s).map(
                (x) => x.length
            )
        ),
        null,
        true
    )

    spacings.forEach((spacing, i) => {
        const r = getRE(spacing)
        s = s.replace(r, runner)
    })
    //console.log(s); throw '';

    return s
}
----------------------------------
[variables.js 01-26-2023]:
function foo(s) {
    import { clip, appendVariable } from "./node-utils.js"
    appendVariable(Object.entries(materialColors).reduce((acc, [k,v]) => {
        Object.entries(v).forEach(([a,b]) => {
            const newKey = /^\d/.test(a) ?
                k + a[0] : k + a.slice(1)
            acc[newKey] = b
            if (newKey.endsWith('5')) {
                acc[newKey.slice(0, -1)] = b
            }
        })
        return acc
    }, {}))
}
----------------------------------
[base.py 01-26-2023]:
def appScript(f, data=None):
    s = read(env.appscriptfile) + "\n\n"
    s += toCallable(f, data)
    google_request(s)
----------------------------------
[base.py 01-26-2023]:
def appScript(f, data=None, use=""):
    namer = lambda f: normDirPath(addExtension(f, "js"))
    files = map(split(use, ",? +"), namer)
    files.append(env.appscriptfile)
    s = ""
    if use:
        s += removeJavascriptStuff(normRead("utils.js"))
    s += mergefiles(files)
    s += "\n\n"
    s += toCallable(f, data)
    google_request(s)
    print("called google")
----------------------------------

[run.py 02-14-2023]:
def PythonController(**kwargs):
    file = os.path.abspath(apps.__file__)
    keys = astFunctions(file)
    key = choose(keys, mode=1)
    fn = getattr(apps, key)
    fn()

env.basepyref['gpa'] = 'gitPushAll'
# gitInit()
# print(ofile(gitUrl(pydir)))
# print(isRecent(glf(), days=1))
----------------------------------


[utils.js 02-15-2023]:
function foo1() {
    /* Testing storage.pop */
    const storage = new Storage()
    storage.add('a', 'b')
    const value = storage.pop('a')
    console.log(storage.toJSON())
    console.log(value)
}
----------------------------------


[utils.js 02-15-2023]:
function foo2() {
    /* testing addobject */
    const storage = new Storage({addObjectAsObject: 1})
    storage.add('asdf', {a:2})
    storage.add('asdf', {b:3})
    storage.add('xasdf', {b:3})
    console.log(storage.toJSON())
}
----------------------------------


[utils.js 02-15-2023]:
function foo3() {
    let d = {
        foo() {
            
        },
        sortFunction: identity,
        a: {
            boo() {
                
            }
        }
    }
    return objectToString(d)
}
----------------------------------

function conditionf(condition, fn) {
    /* dep */
    return function lambda(s) {
        if (condition(s)) {
            return fn(s)
        }
        return s
    }
}
----------------------------------

[utils.js 02-15-2023]:
function queryString(x) {
    if (isString(x)) {
        x = getKwargs(x)
    }
}
----------------------------------


[utils.js 02-15-2023]:
function valueGetter(a, b) {
    if (!exists(a)) {
        return null
    }
    if (isArray(a)) {
        return a[b]
    }
}
----------------------------------


[utils.js 02-15-2023]:
function parsePythonSlice(s, slice) {
    const pythonSliceRE = /\[(-?\d*):(-?\d*)\]/
    const [a,b] = search(pythonSliceRE, slice).map(Number)
    if (a && b) {
        return s.slice(a, b)
    }
    if (a) {
        return s.slice(a)
    }
    if (b) {
        return s.slice(0, b)
    }
}
----------------------------------


[utils.js 02-15-2023]:
function addCaret(s) {
    if (isString(s)) {
        if (!s.startsWith('^')) {
            s = '^' + s
        }
        return RegExp(s)
    } else {
        return s.source.startsWith('^') ?
            s : RegExp('^' + s.source, s.flags)
    }
}
----------------------------------


[utils.js 02-15-2023]:
function alphaValue(s) {
    const items = s.split('').map((x, i) => {
        return Math.pow(10, i * -1) * char2n(x)
    })
    return sum(items)
}
----------------------------------


[utils.js 02-15-2023]:
function delta(a, b) {
    return Math.abs(a - b)
}
----------------------------------


[data-parsers.js 02-15-2023]:
function howdy(s, message) {
    return `Howdy from ${s}${message ? ': ' + message : ''}`
}
----------------------------------


[data-parsers.js 02-15-2023]:
class Parcel {
    reset() {
        this.keys = Object.keys(this.store)
    }
    constructor(store) {
        this.store = store
        this.reset()
    }
    pop(k) {
        const value = this.store[k]
        pop(this.keys, k)
        return value
    }
    get size() {
        return this.keys.length
    }
    has(k) {
        return this.keys.includes(k)
    }
}
----------------------------------


[data-parsers.js 02-15-2023]:
function flatten(a) {
    const store = []
    for (let item of a) {
        nestPush(store, item)
    }
    return store
}
----------------------------------


[data-parsers.js 02-15-2023]:
function isJSON(s) {
    return getExtension(s) == 'json'
}
----------------------------------


[data-parsers.js 02-15-2023]:
function isJS(s) {
    return getExtension(s) == 'js'
}
----------------------------------


[data-parsers.js 02-15-2023]:
function isPY(s) {
    return getExtension(s) == 'py'
}
----------------------------------


[data-parsers.js 02-15-2023]:
function splitInHalf(s) {
    const a = Math.floor(s.length / 2)
    return [s.slice(0, a), s.slice(a)]
}
----------------------------------


[data-parsers.js 02-15-2023]:
function setStateValue(state, key, value) {
    return state[key] ? state[key] : state[key] = fparse(value)
}
----------------------------------


[utils.js 02-15-2023]:
function getFirstName(name) {
    if (/jeff/i.test(name)) {
        return 'Jeff'
        ----------------

    }
    const items = split(name, ' ')
    if (items.length == 1) return name
    return capitalize(items.slice(0, -1).join('').toLowerCase())
}
----------------------------------


[utils.js 02-15-2023]:
function makeComplicatedRunner(items, {prepareFn, runFn, key} = {}) {
    /* it is currently not working well */
    const keyDict = {
        'match': ['searchf', 'match'],
        'all': ['testf', 'default'],
    }
    if (key) {
        ;[prepareFn, runFn] = keyDict[key]
    }

    const dict = {
        searchf,
        testf,
        match(b, s, m) {
            return isArray(m) ?
                b(...m) :
                b(s)
        },
        default(b, s) {
            return b(s)
        }
    }

    const getter = (x) => isString(s) ? dict[x] : x
    const first = getter(prepareFn)
    const run = getter(runFn)
    const runners = partition(items).map(atFirst(first))
    return function lambda(s, i) {
        for (let [a, b] of runners) {
            const m = a(s)
            if (m) {
                const value = run(b, s, m)
                if (isDefined(value)) {
                    return value
                }
            }
        }
    }
}
----------------------------------


[utils.js 02-15-2023]:
function atBoth(a, b, mode) {
    if (isObject(a)) {
        const keys = Object.keys(a)
        return (x, i) => {
            return {
                [keys[0]]: a[keys[0]](x[0], i),
                [keys[1]]: a[keys[1]](x[1], i),
            }
        }
    }

    if (mode == Object) {
        return (k, v) => [a(k), b(v)]
    }
    return (x, i) => [a(x[0], i), b(x[1], i, x[0])]
}
----------------------------------


[utils.js 02-15-2023]:
function ignoref(x) {
    if (isObject(x)) {
        return function lambda(s) {
            return !x.hasOwnProperty(s)
        }
    }

    if (isArray(x)) {
        return function lambda(s) {
            return !x.includes(s)
        }
    }

    if (isString(x)) {
        return function lambda(s) {
            return !test(x, s)
        }
    }

    if (isFunction(x)) {
        return x
    }

    if (isRegExp(x)) {
        return function lambda(item, i) {
            return !x.test(item)
        }
    }

    return function lambda(item, i) {
        return x != item
    }
}
----------------------------------


[CodeOrganizer.js 02-15-2023]:
function buildBrowserFunction(key, arg = '') {
    const text = mergeFiles('browser-utils.js', 'utils.js')
    const lib = new CodeLibrary(text)
    const items = lib.getRecursiveDependencies(key)

    let code = lib.export(String)
    code += `\n\n${key}(${arg})`
    code = uglify(code)
    write('temp.js', payload, true)
}
----------------------------------


[utils.js 02-15-2023]:
function noop() {
    return null
}
----------------------------------


[utils.js 02-15-2023]:
function multiSplit(s, r1, r2) {
    const value = lineGetter(s).map(curryEnd(split, r1))
    return r2 ? 
        value.map(atSecond(curryEnd(split, r2))) : 
        value
}
----------------------------------


[utils.js 02-15-2023]:
function itemGetter(x, ...args) {
    if (!isDefined(x)) {
        return 
    }
    if (!isDefined(args[0])) {
        return 
    }
    if (isObject(x)) {
        return dictGetter(x, ...args)
    }
    if (isArray(x)) {
        return x[args[0]]
    }
}
----------------------------------


[utils.js 02-15-2023]:
function toJSON(x) {
    if (!x) return null

    if (!isObject(x)) {
        return x
    }

    if ('toJSON' in x) {
        return x.toJSON()
    }

    if ('getValue' in x) {
        return x.getValue()
    }

    if ('storage' in x) {
        return x.storage.store
    }

    if ('store' in x) {
        return x.store
    }
}
----------------------------------

function generatePossibleNameAbbreviations(names) {
    const total = []
    function runner(name) {
        let store = []
        let a = abrev(name)
        store.push(a)
        if (a.length == 3) {
            store.push(a.slice(0, 2))
        }
        let short = name.slice(0, 3).toLowerCase()
        store.push(short)
        total.push(...unique(store))
        return store
    }
    const f = (name) => [name, runner(name)]
    const g = ([name, store]) => {
        const abrevs = shared(store, json)
        let count = 4
        while (abrevs.length == 0) {
              let newAbrev = name.slice(0, count++).toLowerCase()
              if (json.includes(newAbrev)) {
                  continue
              }
              abrevs.push(newAbrev)
        }
        return {
            name,
            abrevs
        }
    }
    const items = names.map(f)
    const tally = new Tally(total)
    const json = tally.filter((count) => count == 1).toJSON()
    const results = items.map(g)
    const abrevs = flat(results.map((x) => x.abrevs))
    const r = reWrap(abrevs)
    return r
}
----------------------------------
[Classroom.js SpeakerFactory 02-16-2023]:

    if (f === 'asdf') {
        return function lambdaSpeakerWrap(s, convo) {
            function getSpeaker() {
                if (convo) {
                    if (convo == true) convo = 2
                    if (cGroup.length < convo) {
                        cGroup.push(store.shift())
                    }
                    const value = cGroup[cIndex++ % cGroup.length]
                    return value
                }
                else if (cGroup.length) {
                    cGroup = []
                    cIndex = 0
                }

                const speaker = store.shift()
                return speaker
            }
            const speaker = getSpeaker()
            const text = s.replace(/\$\d?/g, (x) => {
                if (x == '$') {
                    return lastSpeaker
                }
                if (x == '$1') {
                    return speaker
                }
            })
            lastSpeaker = speaker
            return {
                speaker, value: text
            }
        }
    }
    return function speakerWrap(componentKey, props) {
        const speaker = store.shift()
        const slot = {
            component: "v-speaker",
            props: { value: speaker },
        }
        if (isObject(arguments[0])) {
            return {
                slot,
                ...arguments[0],
            }
        } else {
            return {
                slot,
                component: componentKey,
                props,
            }
        }
    }
----------------------------------


[clip.js 02-17-2023]:
//]
// 02-17-2023
----------------------------------


[codeOrganizer.js 02-20-2023]:
function dryOrDebug(state, debug) {

    function getter(fn) {
        const r = /(this.*)\)/g
        const m = findall(r, fn.toString())
        return m.map((x) => x.replace(/this/g, 'state')).map((item) => {
            return evaluate(item, {state})
        })
    }

    if (state.hasOwnProperty('write')) {
        if (debug) {
            console.log(getter(state.write.toString()))
        } else {
            state.write()
        }
    }
}
----------------------------------


[codeOrganizer.js 02-20-2023]:
function testff({key, regex, flags = ''} = {}) {
    if (key) {
        if (regex) {
            if (isString(regex)) {
                regex = RegExp(x, flags)
            }
            return function test(s) {
                return regex.test(s[key])
            }
        }
        else {
            return function wrapper(x) {
                const regex = RegExp(x, flags)
                return function test(s) {
                    return regex.test(s[key])
                }
            }
        }
    }
}
----------------------------------


[utils.js 02-21-2023]:
function getCaller(n = 0) {
    const r = /(?:consoleLog|getCaller).+\s+at\s+(\S+)[^]+?at\s+(\S+)/
    const s = new Error().stack
    const match = search(r, s)
    return match[Math.abs(n)]
}
----------------------------------


[parseGrades.js 02-21-2023]:
function parseGrades2(s) {
    const storage = new Storage()
    const matches = findWordNumberTokens(s)

    const classroomA = new Classroom(4)
    const classroomB = new Classroom(5)
    const refA = generateStudentAliases(classroomA.students).dict
    const refB = generateStudentAliases(classroomB.students).dict
    const gradeLevelA = classroomA.gradeLevel
    const gradeLevelB = classroomB.gradeLevel

    matches.forEach(([a,score]) => {
        if (score < 50) score = 100 - score
        let studentFullName
        let gradeLevel

        if (refA.hasOwnProperty(a) && refB.hasOwnProperty(a)) {
            return 
        } else if (refA.hasOwnProperty(a)) {
            studentFullName = refA[a]
            gradeLevel = gradeLevelA
        } else if (refB.hasOwnProperty(a)) {
            studentFullName = refB[a]
            gradeLevel = gradeLevelB
        }
        else {
            let pA = fuzzy(a, classroomA.students)
            let pB = fuzzy(a, classroomB.students)
            if (pA && pB) {
                if (pA.score > pB.score) {
                    gradeLevel = gradeLevelA
                    studentFullName = pA.target
                } else {
                    gradeLevel = gradeLevelB
                    studentFullName = pB.target
                }
            }
            else if (pA) {
                    gradeLevel = gradeLevelA
                    studentFullName = pA.target
            }
            else if (pB) {
                    gradeLevel = gradeLevelB
                    studentFullName = pB.target
            }
            else {
                throw new Error(a)
            }
        }

        storage.add(gradeLevel, studentFullName, score)
    })
    return storage.toJSON()
}
----------------------------------

function codeOrganizer(options) {
    const state = new CodeState(options.file)
    state.debug = options.debug

    targetedEdits(state, options.edits) 
    typedActions(state, options.actions)
    popAction(state, options.handlePopped)

    popAction takes a popFn.
    If the popFn exists ... we proceed.
    Else, early return.

    targetedEdits touches individual functions.
    It usually runs some sort of text analysis on them.

    typedActions touches types (comment | variable | function | etc)
    state.write()
}

[ma.js 03-01-2023]:
function unique_cartesian_power(xs, n) {
  var result = cartesian_power(xs, n);
  var unique_result = [];
  const set = new Set();

  result.forEach(function(value) {
    var representation = value.sort().join(' ');
    if (!set.has(representation)) {
      set.add(representation);
      unique_result.push(value);
    }
  });

  return unique_result;
}

//console.log(cartesianProduct([[1,2,3], [2,4]]))
//console.log(unique_cartesian_power(range(2, 10), 3)) /* it is very similar ... */
----------------------------------


[ma.js 03-01-2023]:
function cartesian_power(xs, n) {
  var result = xs;
  for (var i = 1; i < n; i++) {
    result = cartesian_product(result, xs)
  }
  return result;
}
----------------------------------


[ma.js 03-01-2023]:
function cartesian_product(xs, ys) {
  var result = [];
  for (var i = 0; i < xs.length; i++) {
    for (var j = 0; j < ys.length; j++) {
      result.push([].concat.apply([], [xs[i], ys[j]]));
    }
  }
  return result;
}
----------------------------------


[ma.js 03-01-2023]:
function flatten(a) {
    const store = []
    for (let item of a) {
        store.push(...item)
    }
    return store
}

//console.log(generate1213())
//console.log(latexTemplater('ab/c * b * ab * bb * c + a', [2,3,4]))
----------------------------------


[ma.js 03-01-2023]:
function F(key, ...args) {
    const f = new Fraction(3, 4)
    return f[key](...args)
}
----------------------------------


[ma.js 03-01-2023]:
function trange(n) {
    return changeMiddle(partition(range(n).map((x) => ' '), Math.sqrt(n)), 'FREE')
}
----------------------------------


[ma.js 03-01-2023]:
function changeMiddle(a, payload) {
    let size = a.length
    let h = Math.floor(size / 2)
    a[h][h] = payload
    return a
}
----------------------------------


[ma.js 03-01-2023]:
function joinLines(lines) {
            let s = ''
            lines.forEach((line) => {
                if (isWhiteSpace(line)) {
                    s += line
                } else {
                    s += line + '\n'
                }
            })
            return s.trim()
}
----------------------------------


[ma.js 03-01-2023]:
function labelMatch(s, queries) {
    for (let [r, label] of partition(queries)) {
        if (r.test(s)) {
            return label
        }
    }
}
----------------------------------


[ma.js 03-01-2023]:
var VMixedNumberDemo = {
    name: 'VMixedNumberDemo',
    props: ['n', 'd'],
    mounted() {
        const data = generateMixedNumberSnippet(this.n, this.d)
    },
    template: `
        We start with frac(n, d)
        Look. The numerator(n) is bigger than the denominator(d).

        This can totally be framed as a timeline movie.
        You just need to incorporate a clock.

    `,
}
----------------------------------


[ma.js 03-01-2023]:
function latexTemplater(s, ref) {
    ref = arrayToDict(ref)

    const f = (s) => {
        if (s.length == 1) {
            return ref[s] || s
        }
        const items = split(s, "")
        const value = multiply(items.map((x) => ref[x]))
        if (isNaN(value)) {
            return s
        }
        return value
    }
    const r = /\b[abc]{1,3}\b/g
    return s.replace(r, f)
}
----------------------------------

    const transform = ({min, max, equals}) => {
        let hasMin = isDefined(min)
        let hasMax = isDefined(max)

        if (equals) {
            return createFunction('rngEquals', equals)
            return () => equals
        } 
        if (hasMin && hasMax) {
            return createFunction('rngMinMax', `rng(${min}, ${max})`)
            return () => rng(min, max)
        }
        if (hasMin) {
            return createFunction(`rngMin${min}_${globalMax}`, `rng(${min}, ${globalMax})`)
        }
        if (hasMax) {
            return createFunction(`rngMax${globalMin}_${globalMax}`, `rng(${globalMin}, ${max})`)
            return () => rng(globalMin, max)
        }
    }
----------------------------------

[parse.js 03-03-2023]:
function hashSplit(s) {

    function runner(s, n = 1) {
        const template = `^${"#".repeat(n)}(?=[ \\w]|$)`
        const r = RegExp(template, 'm')
        const base = s.split(r)
        const [top, items] =
            base[0].trim() == ""
                ? ["", base.slice(1)]
                : splitOnce(base)

        const children = items.map((x) => runner(x, n + 1))
        if (!exists(children)) {
            let [a,b] = splitOnce(top.trim(), '\\n')
            return {
                top: a,
                value: b,
            }
            //console.log('suppp', {s})
        }
        return {
            top: top.trim(), 
            children,
        }
        //return [top,
    }

    return runner(s.trim())
}
----------------------------------


[parse.js 03-03-2023]:
class ParserTree {
    constructor(options) {
        this.options = options
    }
    get({type, depth}) {
        /* cache options */
        return {
            title() {
                
            },

        }
    }
}
----------------------------------


[parse.js 03-03-2023]:
function smartStringParse(s) {
    /* dunno what this will be used for ... */
    const items = [/^#/, hashSplit]

    const runner = makeRunner(items)
    return runner(s)
}
----------------------------------


[parse.js 03-03-2023]:
function datagen(s, parseKey = "AB") {
    const dict = {
        AB(item) {
            let [a, b] = splitOnce(item).map(toNumber)
            return b ? [a, true] : [a, false]
        },
    }
    return smartLineGetter(s).map(dict[parseKey])
}
----------------------------------


[parse.js 03-03-2023]:
function defaultHashSplitHandler(top, children, depth, type) {
    let parserRef = hashSplitParserRef
        let [title, topText] = splitOnce(top, /\n+/)
        let extendedType = computeExtendedType(
            type, depth, title, topText
        )
        let titleParser = parserRef.title['h' + depth]
        let bodyParser = parserRef.body[extendedType]
        let childParser = parserRef.wrap[extendedType]
        let b = topText

        if (titleParser) title = titleParser(title)
        if (bodyParser) b = bodyParser(b)
        if (childParser) children = childParser(children)

        if (type == 'branch') {
            return {
                children,
                type,
                extendedType,
                depth,
                title,
                blurb: b,
            }
        }

        return {
            type,
            extendedType,
            depth,
            title,
            value: b,
        }
        //return [top,
}
----------------------------------


[parse.js 03-03-2023]:
function smartLineGetter(s) {
    return lineGetter(smartDedent(stringBreaker(s)))
}
----------------------------------


[parse.js 03-05-2023]:
function consumableParse(s, item) {
    objectWalk(item, (x) => {
        if (isObject(x) && x.hasOwnProperty('stop')) {
            x.stop = false
        }
    })
    /*---------------------------------*/
    const state = new ParseState2()
    s = s.trim()
    runner(item)
    return state.toJSON()
    /*---------------------------------*/

    function mget(r, s) {
        let match
        function parser(...a) {
            if (a.length == 3) {
                match = a[0]
            } else if (a.length == 4) {
                match = a[1]
            } else {
                match = a.slice(1, -2)
            }
            return ''
        }
        const value = s.replace(r, parser)
        return [value, match]
    }
    function eat({regex, fn, key}) {
        if (regex.test(s)) {
            //console.log({regex, s})
            let [text, match] = mget(regex, s)
            s = text

            if (!(isString(match) && !match.trim())) {
                state.add(match, key, fn)
            }
            return true
        }
    }

    function runner(item, reset = true) {
        if (!s) {
            return 
        }
        let touched = false

        for (let branch of item.branches) {
            if (branch.stop) {
                continue
            }
            let result = eat(branch)
            if (branch.once) {
                branch.stop = true
            }

            if (result) {
                touched = true
                if (branch.branches) {
                    runner(branch, false)
                    return 
                } 
                else {
                    /* 
                     * this break is crucial it seems.
                     * */
                    break
                }
            }
        }
        if (touched) {
            runner(item, reset)
        } else {
            state.add(s, null, item.default)
        }
    }
}
----------------------------------


[parse.js 03-08-2023]:
function blockParse0308(s) {
    
    const dict = ['katex']
    /* recursive regexification */
    
    const r = /\n+(?=\w)/
    function runner(s, context) {
        const items = split(s, r)
        const children = items.map((item, i) => {
            const m = item.match(/^(.*) *\n+([^]+)/)
            if (!m) {
                {value: item}
            }
            const [top, bottom] = m.slice(1)
                return {
                    top,
                    bottom: runner(bottom)
                }
            }
        })
        //console.log(items); throw "";
    }
    function runnerx(s, context) {
        breaker(5)
        const r = reWrap(dict, /^($1|.*?:) *\n+( [^]+)/)
        console.log(r); throw "";
        const m = search(r, s)
        if (m) {
            const [top, bottom] = m
            const blocks = split(bottom, /\n+(?=\w)/)
            console.log(blocks); throw "";
            const children = blocks.map((block) => {
                return runner(block)
            })
        } else {
            
        }
    }

        //console.log(blocks); throw "";

    const startingContext = {
        index: 0,
        count: 1,
        depth: 1,
    }
    return runner(s, startingContext)

}
----------------------------------


[parse.js 03-08-2023]:
function blockParse(s) {
    const lines = s.trim().split('\n')
    for (let i = 0; i < lines.length; i++) {
        let line = lines[i]

    }
}
----------------------------------


[parse.js 03-08-2023]:
let str0308 = `
    nest1 
        nest 1 child 1
        nest 1 child 2

        nest2
            nest 2 child 1
            nest 2 child 2

    nestparent2
        howdy
`
----------------------------------

app.get("/:student/:query", (req, res) => {
    const ref = {
        vincentchen: {
            scores: {
                week1: 100,
                week2: 100,
            }
        }
    }
    const {student, query} = req.params
    console.log(req.params)
    if (student && query) {
        return res.json(ref[student][query])
    }
    return res.sendFile(file)
})


[utils.js 03-08-2023]:
class QueryList {
    /** u **/
    constructor(fn) {
        this.store = []
        this.transform = fn || ((x) => x.name)
        this.add = this.add.bind(this)
        this.options = {
            limit: 1,
            threshold: -500,
            key: "name",
        }
    }

    add(el) {
        if (!el) return
        if (isArray(el)) {
            return el.forEach(this.add)
        }
        this.store.push(this.transform(el))
    }

    find(query) {
        //console.log(this.store); assert();
        let f = (x) => this.transform(x) === query
        let m
        console.log(this.store)
        if (m = this.store.find(f)) {
            console.log('sss')
            return m
        } else if (m = fuzzysort.go(query, this.store, this.options)) {
            console.log('h')
            console.log(m, 'hi')
            //return m[0].target
        }
    }

    //import fuzzysort from "fuzzysort"
    //const queryList = new QueryList()
    //queryList.add({name: 'sam'})
    //const f = queryList.find('sam')
    //console.log(f)
}
----------------------------------


[utils.js 03-09-2023]:
function foo(s) {
    const actions = map(10, (x, i, a) => {
        const delay = a.length * 100 - (100 * i)
        return {
            action: (() => console.log(delay)),
            delay: delay
        }
    })
    waterfall(actions)
}
----------------------------------


[run.py 03-09-2023]:
def googleAction(obj):
    raise Exception()
    template = f"Action2({dumpJson(obj)})"
    googleAppScript(template)
----------------------------------


[run.py 03-09-2023]:
def htmlBodyParser(s):
    import bs4
    import html

    store = []
    body = bs4.BeautifulSoup(s, "html.parser").body
    for item in body.find_all(recursive=True):
        name = item.name
        if name in ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6']:
            text = item.get_text()
            if isChinese(text) or isEnglish(text):
                store.append((name, text))
    return store
----------------------------------


[parse.js 03-09-2023]:
function quizBlockItem(s) {
    const chunks = split(s, /\n\n+/)

    const store = []
    for (let i = 0; i < chunks.length; i++) {
        const state = new CumulativeStorage()
        const lines = chunks[i].split('\n')
        const length = lines.length
        for (let j = 0; j < length; j++) {
            let line = lines[j]
            state.add(quizLineRunner(line, i, j, state, length))
        }
        store.push(state.toJSON())
    }
    return store
}
----------------------------------


[parse.js 03-09-2023]:
const quizBlockRunner = makeQuizBlockRunner([
    (s, i, length) => i == 0,
    (line, i, j, state, length) => {
        if (length == 1) {
            return {
                title: line
            }
        } else {
            return quizBlockRunner(lines, null, state)
        }
    },
    isCallable,
])
----------------------------------


[parse.js 03-09-2023]:
function makeQuizBlockRunner(items) {
    const runners = partition(items).map(atFirst(testf))
    return function lambda(lines, i, state) {
        for (let [a, b] of runners) {
            if (a(lines[0], i, lines.length)) {
                const param = a.toString().match(/\((\w+)/)[1]
                const item = param == 'lines' ? lines : lines[0]
                return b(item, i, state)
            }
        }
    }
}
----------------------------------


[parse.js 03-09-2023]:
const quizBranches = {
    branches: [
        //{
            //regex: /^.+/,
            //once: true,
            //key: "title",
            //fn(s) {
                //return 'title: ' + s
            //},
        //},

        {
            regex: /^@.+/,
            key: "at",
            fn(s) {
                return 'at: ' + s
            },
        },
        {
            regex: /^\w+(?:\.\w+)?\(.*?\) */,
            key: "callable",
            fn(s) {
                return 'callable: ' + s
            },
        },
        {
            regex: /.+/,
            key: 'prose',
            fn(s) {
                return 'prose: ' + s
            },
        },
            //regex: /^(.*):\s*\n +(\w[^]+?)(?=$|\n+(?:\[|\w+))/,
            //trimAfter: true,
    ]
}
----------------------------------


[vueData.js 03-10-2023]:
class PageBlock {
    constructor() {
        this.store = []
    }

    add2(x) {
        this.store.push(x)
    }
    add(
        columnNumber,
        height,
        fullWidth,
        secondColumnMaxHeight
    ) {
        this.store.push({
            columnNumber,
            height,
        })
        super.add(columnNumber)
    }

    toJSON() {
        return this.store
    }
}
----------------------------------


[vueData.js 03-10-2023]:
function xOnMeasure(measurements) {
    //this.measuredValue = true
    //return
    let count = 0
    let ref = this.computedValue
    //console.log('starting the remeasure')
    //console.log(type(ref))
    //console.log(len(ref))
    //console.log(type(measurements))
    let children = measurements.map((page, pageIndex) => {
        console.log('sdfsdfsdf')
        //console.log(page)
        const pageChildren = page.map((measurement) => {
            let element = copy(ref[count++])
            let pos = normalizeElementPosition(measurement)
            applyPosToElementOrSlot(element, pos)
            return element
        })
        console.log('got page childs')

        const padding = "0.5in"
        const footer = {
            component: "VMFooter",
            props: { pageNumber: pageIndex + 1 },
        }

        const grandChildren = [
            {
                style: getPageStyleFromPadding(padding),
                children: [
                    { children: pageChildren },
                    footer,
                ],
                tag: 'div',
            },
        ]

        return {
            staticClass: "document-page-container",
            style: {
                position: "relative",
                width: "8.5in",
                height: "11in",
                padding: padding,
            },
            children: grandChildren,
        }
    })
    //console.log('hi')
    //return

    const payload = {
        staticClass: "document-root-container",
        children,
    }
    //console.log(JSON.stringify(payload, null, 2))
    this.measuredValue = payload
}
----------------------------------


[vueData.js 03-10-2023]:
class ElementPageStorage2 {
    constructor({
        maxColumns = 2,
        maxHeight = "10in",
        marginBottom = "0.5in",
    } = {}) {
        this.store = []
        this.maxColumns = maxColumns
        this.marginBottom = calc(marginBottom)
        this.maxHeight = calc(maxHeight)
        this.count = 0
        this.addPageBlock()
    }

    addPageBlock() {
        this.currentColumnNumber = 1
        this.pageBlock = new PageBlock()
        this.store.push(this.pageBlock)
        this.extraHeight = 0
        this.currentHeight = 0
        this.touched = false
    }
    onHeightThreshold(fullWidth, height) {
        this.currentHeight = 0

        if (this.currentColumnNumber == this.maxColumns) {
            return this.addPageBlock()
        }

        if (this.extraHeight) {
            if (fullWidth) {
                return this.addPageBlock()
            } else if (
                this.extraHeight + height >
                this.maxHeight
            ) {
                return this.addPageBlock()
            } else {
                this.currentHeight = this.extraHeight
                this.touched = true
                this.currentColumnNumber++
                this.extraHeight = 0
            }
        } else {
            this.currentColumnNumber++
            this.currentHeight = this.extraHeight
            this.touched = true
        }
    }
    add(height, fullWidth /* boolean */, index) {
        const pos = this.currentHeight
        const mb = this.marginBottom
        const newPos = pos + height + mb

        if (newPos > this.maxHeight) {
            this.onHeightThreshold(fullWidth, height)
        }
        if (fullWidth) {
            this.extraHeight = newPos
        }

        this.pageBlock.add(
            this.currentColumnNumber,
            this.currentHeight,
            fullWidth,
            height
        )

        this.currentHeight += height + mb
    }
    toJSON() {
        return this.store.map((x) => x.toJSON())
    }

    getMaxHeight() {
        return this.currentColumnNumber == 1
            ? this.maxHeight
            : this.secondColumnMaxHeight
    }
}
----------------------------------


[vueData.js 03-10-2023]:
function testGetMeasurements(x, o = {}) {
    if (isObjectArray(x)) {
        //console.log(x)
        x = x.map(({ width, height }, i) => {
            width = parseInt(width)
            height = parseInt(height)
            //let fullWidth = options.fullWidth || width > 700
            let fullWidth = true
            return [height, fullWidth]
        })
    } else if (!isNestedArray(x)) {
        x = x.map(doublef(false))
    } else {
        console.log("asdfasdf")
        throw "error"
    }
    const ep = new ElementPageStorage2(o)
    x.forEach((item, i) => ep.add(...item))
    return ep.toJSON()
}
----------------------------------


[ec.js 03-10-2023]:
class DomTree {
    constructor() {
        const firstElement = document.body.children[0]
        this.root = new ECElement(firstElement)
        function runner(el) {
            el.nativeForEach((child) => {
                const childElement = new ECElement(child)
                el.appendChild(childElement)
                runner(childElement)
            })
        }
        runner(this.root)
    }
    forEach(obj, depth = 1) {
        function runner(el, depthIndex = 0) {
            el.forEach((child) => {
                if (depthIndex == depth) {
                    addElementProperties(child.$el, obj)
                } else if (depthIndex > depth) {
                    return
                }
                runner(child, depthIndex++)
            })
        }
        runner(this.tree)
    }
}
----------------------------------


[base.py 03-10-2023]:
class ErrorPass:
    def __init__(self):
        self.errors = []

    def __exit__(self, etype, value, traceback):
        self.errors.append([etype, value, traceback])
        return 1
----------------------------------


[base.py 03-10-2023]:
def allFiles(**kwargs):
    dirs = [rootdir, pubdir, cwfdir]
    store = []
    for dir in dirs:
        store.extend(ff(dir=dir, **kwargs))
    return store
----------------------------------


[base.py 03-10-2023]:
def runjs(a, b=""):
    if b:
        b = " " + b
    a = normDirPath(addExtension(a, "js"))
    os.system("node " + a + b)
----------------------------------


[base.py 03-10-2023]:
def sliceDict(d, n=10):
    import itertools

    if isObject(d):
        return dict(itertools.islice(d.items(), n))
    return d[:10]
----------------------------------


[base.py 03-10-2023]:
def prettyTable(a, title=""):
    longest = max(map(a, lambda x: len(x[0])))

    def delta(s):
        spaces = " " * (longest - len(s[0]) + 4)
        return s[0] + spaces + s[1]

    value = map(a, delta)

    deli = "-"
    return (
        title
        + "\n"
        + deli * 40
        + "\n"
        + "\n".join(value)
        + "\n"
        + deli * 40
        + "\n"
    )
----------------------------------


[base.py 03-10-2023]:
def review10(x):
    files = ff(x) if isString(x) else x
    for file in files:
        review11(file)
----------------------------------


[base.py 03-10-2023]:
def review11(file):
    e = getExtension(file)
    data = read(file)
    if not data:
        rfile(file)
        return 1

    length = len(data)
    dir = dirFromFile(file)

    if e == "json":
        data = sliceDict(data)
    elif length > 100_000:
        data = ""
        if e in utfe:
            ofile(file)

    a = prompt(data, file, "length : " + str(length))
    if a == "o":
        ofile(file)
        a = prompt(data, file, "length : " + str(length))

    if len(a) > 3:
        mfile(file, changeFileName(file, a, dir))

    elif a == "m":
        mfile(file, dir)
    elif a:
        rfile(file)
    return 1
----------------------------------


[base.py 03-10-2023]:
def removeFiles(files, small=0):
    for file in files:
        if not isfile(file):
            print("not a file", file)

        elif small:
            if fsize(file) < 50:
                rfile(file)
        else:
            rfile(file)

        files.remove(file)

    return files
----------------------------------


[vueData.js 03-13-2023]:
const CoverPage = (vob) => {
    const parent = new VObject(vob, true)
    const a = parent.firstChild.firstChild
    console.log(a.setClass('ssssssssss'))
    console.log(parent.toJSON())
}
----------------------------------


[vueData.js 03-13-2023]:
function fo(name, template = '$1 is wonderful') {
    const s = template ? templater(template, name) : name

    /*---------------------------------*/
    let count = 1
    const words = split(s.toUpperCase(), ' ')
    const groups = words.map((word, i) => {
        const letters = word.split('')
        const children = letters.map((letter, i) => {
            return {
                value: letter,
                count: count++,
            }
        })
        return children
    })
    /*---------------------------------*/

    const vob = new VObject()
    vob.addStyle('mw50')
    for (const group of groups) {

        const wordContainer = vob.appendChild()

        group.forEach((letter) => {
            const child = wordContainer.appendChild()
            child.value = letter.count
            container.addStyle('abs')
            child
        })
        contain
    }

    return groups
}
----------------------------------


[vueData.js 03-13-2023]:
function fo() {
    
        const runnerDebug = () => {
            return this.staticClass 
                ? `ClassName: ${this.staticClass}` 
                : this.component
                ? `ComponentName: ${this.component}`
                : `UidName: v-${this.uid}`
        }

}
----------------------------------


[vue-utils.js 03-13-2023]:
function toComponent(vob) {
    const vobJSON = isVob(vob) ? vob.toJSON() : vob
    return {
        name: vob.getComponentName() || 'VVob',
        render(h) {
            return vueRenderer(this, vobJSON)
        }
    }
    /* not in use */
}
----------------------------------


[vueData.js 03-13-2023]:
function toJSON(el) {
    if (!isDefined(el)) {
        return "NULL ELEMENT - NO TOJSON"
    }
    if (el.hasOwnProperty("toJSON")) {
        return el.toJSON()
    }
    return el
}
----------------------------------


[utils.js 03-13-2023]:
const sampVueObject2 = [
  {
    "staticClass": "child-1",
    "children": [
      { "component": "VMHeader" },
      { "component": "VMBody" },
      { "component": "VMFooter", children: [


      { "component": "VMBodyInner" },
      ]},
    ]
  },
  { "component": "VMHeaderTop" },
]
----------------------------------


[vueData.js 03-13-2023]:
function normalizePosition(x) {
    let top
    let left

    if (isObject(x)) {
        left = x.x
        top = x.y
    } else if (isArray(x)) {
        left = x[0]
        top = x[1]
    }

    top = top + "pt"

    return {
        top,
        left,
        position: "absolute",
    }
}
----------------------------------


[worksheet-components-2.js 03-13-2023]:
const CoverPage = (parent) => {
    const firstChild = parent.prependChild()
    firstChild.setComponent('VWonderfulStudentCoverPage')
    firstChild.addProps({
        name: 'felix',
    })
    return parent
}

This is an interesting piece of code.
The parent is a vobject initialized in vue-utils: vueSetup.
It is an empty Vobj able to consume new pieces of data.
You dont actually even need to return anything.
But you can.

----------------------------------


[parse.js 03-14-2023]:
function depquizParser(s) {
    console.log('hi not in use'); assert();
    /* not in use  */
    const runner = (s, i, j, innerLength) => {
        if (i == 0 && j == 0) {
            return {title: s}
        }

        if (i == 0) {
            return {error: 'no no'}
        }

        if (isBracketGroup(s)) {
            return {bracket: s}
        }

        if (isCallable(s)) {
            return {callable: s}
        }
        return splitKatexV1(s)
    }
    /* sometimes you dont want to split on the outer. You might split between the confines of a function. */
    /* sometimes you dont want to split on the inner. You might split between the confines of a table. */
    return split(s, /\n\n+/).map((x, i) => {
        if (isMultiLineBlock(x)) {
            return runner(x, i)
        }
        const lines = x.split('\n')
        const value = lines.map((y, j, a) => {
            return runner(y, i, j, a.length)
        })
        return smallify(value)
    })
}
let str0309 = `
The Title is Decimals

1.4 + 2.6 
1.4 + 2.6 is the answer.

Hi how are you

table(bar(), day, total distance)


boo {
    asdfasdf
}
`
----------------------------------


[vue-utils.js 03-15-2023]:
function foo123() {
    /* this works. */
    /* testing the Vobject String */
    const vob = new VObject(true).setClass('z')
    const block = vob.createBlockItem()
    block.add({component: 'a'})
    block.enter().setClass('bgc')
    block.add({component: 'ab'})
    block.add({component: 'ab'})
    block.add({component: 'ab'})
    block.exit()
    const newBlock = block.add({component: 'abc'})
    newBlock.enter()
    newBlock.add({component: 'ab'})
    console.log(vob.toString())
}
----------------------------------


[vue-utils.js 03-15-2023]:
function prepareForVueRenderer(o) {

    /* 
     * Implicitly creates an assignment header.
     * Ste
     * */
    const extra = {
        "staticClass": "block-item",
        "children": [
          {
            "component": "VMHeader",
            "props": {
                "title": "Grade 4 Decimals Quiz"
            }
          }
        ]
    }
    const children = o.map((el, i) => {

        const kids =  el.map((item, i) => {
        if (item.type) {
            item.component = 'V' + capitalize(item.type)
            delete item.type
        }
        if (item.hasOwnProperty('value')) {
            item.props = {value: item.value}
            delete item.value
        }
            return item
        })
        
        return {
            staticClass: 'block-item',
            children:kids  
        }
    })

    return [extra].concat(children)
}
----------------------------------


[vue-utils.js 03-15-2023]:
function fo() {
    header.appendComponent('VMHeader', {title: "Grade 4 Quiz"})
}
----------------------------------


[vue-utils.js 03-15-2023]:
const sampVueObject = [
  {
    "staticClass": "block-item item1",
    "children": [
      {
        "component": "VMHeader",
        "props": {
            "title": "Grade 4 Decimals Quiz"
        }
      }
    ]
  },
  {
    "staticClass": "block-item item-2",
    "slot": { "component": "VNumbered", "props": { "value": "123" } },
    "children": [
      {
        "component": "VTitle",
        "props": {
          "value": "Adding Decimals"
        }
      },
      {
        "component": "VLatex",
        "props": {
          "value": "1.9 + 2.4"
        }
      }
    ]
  },

  {
    "slot": { "component": "VNumbered", "props": { "value": "1" } },
    "staticClass": "block-item",
    "children": [
      {
        "component": "VTitle",
        "props": {
          "value": "Adding Decimals"
        }
      },
      {
        "component": "VLatex",
        "props": {
          "value": "1.9 + 2.4"
        }
      }
    ]
  },
]
----------------------------------


[parse.js 03-15-2023]:
class AbstractStartMiddleEndx {
    constructor(constructorArgs) {
        this.constructorArgs = constructorArgs
        this.options = {}

        this.valueKeys = map(['start', 'middle', 'end'], '_$1Value')
    }

    runLifeCycle() {
        const lifeCycleItems = [
            { method: 'beforeStart', save: true, inherit: false },
            { method: 'start', save: true, inherit: false },
            { method: 'afterStart', save: false, inherit: false },
            { method: 'middle', save: true, inherit: false },
            { method: 'beforeEnd', save: false, inherit: false },
            { method: 'end', save: true, inherit: false },
            { method: 'afterEnd', save: false, inherit: false },
        ]

        let value

        for (const item of lifeCycleItems) {
            const {save, method, inherit} = item

            if (!this[method]) {
                continue
            }

            const tempValue = inherit
                ? this[method](value)
                : this[method]()

            if (tempValue) {
                this.values.push(tempValue)
                value = tempValue
            }
        }
        return value
    }

    _init() {
        if (this.init) {
            this.init()
        }
    }
    _beforeStart() {
        if (this.beforeStart) {
            this.beforeStart()
        }
    }
    _afterStart() {
        if (this.afterStart) {
            this.afterStart()
        }
    }

    _beforeEnd() {
        if (this.beforeEnd) {
            this.beforeEnd()
        }
    }

    _afterEnd() {
        if (this.afterEnd) {
            this.afterEnd()
        }
    }
    run(...args) {
        this.args = args
        this._init()
        this._beforeStart()
        this._start()
        this._afterStart()
        this._middle()
        this._beforeEnd()
        this._end()
        this._afterEnd()
        return this.value
    }
    _end() { if (this.end) { this._endValue = this.end() } }
    _middle() { if (this.middle) { this._middleValue = this.middle() } }
    _start() { if (this.start) { this._startValue = this.start() } }

    get arg() {
        return this.args[0]
    }
    get value() {
        //return getLast(this.values)
        for (let i = this.valueKeys.length - 1; i >= 0; i--) {
            let key = this.valueKeys[i]
            if (this[key]) {
                return this[key]
            }
        }
    }
}
----------------------------------


[textEdit.js 03-15-2023]:
function parseTopAttrs() {
    const frontMatterRE = /^--.+([^]+?)\n--.+\n+/
    const [text, frontMatter] = mget(frontMatterRE, s.trim())
    /* taken care of somewhere else  */
}
----------------------------------


[ma.js 03-16-2023]:
function longestPrimeSequence() {
    //const store = []
    let longest = 0
    let index = 0
    for (let i = 0; i < PRIMES.length - 1; i++) {
        let p = PRIMES[i]
        let n = PRIMES[i + 1]
        let diff = n - p
        if (diff >= longest) {
            index = i
            longest = diff
        }
    }
    return range(index - 1, index + longest).map((x) => {
        return getFactors(x)
        return getInterestingFactors(x)
    })
}
----------------------------------


[worksheet-components-2.js 03-17-2023]:
function latex1() {
    //return { component: 'VLatex', props: { value: 'x^2' } }
    //return { tag: 'p', value: 'hi', }

    //return {
    //component: 'VLatex',
    //slot:{ component: 'VNumbered', value: 1, },
    //value: 'x^2 + 3 \\text{.   abc abc is the answer. But }',
    //}

    return {
        component: "VMarkdown",
        value: gptSugar,
    }

    return {
        component: "VLatex",
        slots: [
            { component: "VNumbered", props: { value: 0 } },
            {
                component: "VShadedBackground",
                props: { value: 11000 },
            },
        ],
        props: {
            value: "x^2 + 3 \\newline \\text{.   abc abc is the answer. But }",
        },
    }
}
----------------------------------


[vue-utils.js 03-17-2023]:
function vueSetup(keys) {
    const watcher = new Watcher()

    //const functionalComponents = VueComponents.functionalComponents()
    //for (let [k, v] of Object.entries(functionalComponents)) {
        //const parent = new VObject(true)
        //const value = v(parent)
        //const vobJSON = parent.toJSON()
        //const component = {
            //name: k,
            //render(h) { return vueRenderer(this, vobJSON) },
        //}
        //vuetify(component)
        //const keys = vobCollectComponentKeys(vobJSON)
        //console.log({keys}, 'cccc')
        //keys.forEach(runner)
    //}


    keys.forEach(runner)

    function runner(key) {
        if (!isString(key)) {
            let name = key.name || Object.keys(key)
            //console.log('not a string - going straight to vuetify', name)
            return vuetify(key)
        }

        if (!watcher.isFresh(key)) {
            return
        }
        const x = getComponent(key)

        if (!exists(x)) {
            console.log("no x", key)
            throw ''
        }
        if (x.template) {
            editVueComponent(x)
            const kids = getChildren(x)
            kids.forEach(runner)
        } else if (isObject(x.render)) {
            runnerObject(x.render)
        } else if (isArray(x.render)) {
            x.render = { children: x.render }
            runnerObject(x.render)
        } 
        vuetify(x)
    }

    function runnerObject(o) {
        if (o.component) {
            runner(o.component)
        }
        if (o.slot) {
            runner(o.slot.component)
        }
        if (o.slots) {
            o.slots.map((x) => runner(x.component))
        }
        if (o.children) {
            o.children.map(runnerObject)
        }
    }

    function getChildren(x) {
        return findall(/<(v[-\w]+)/g, x.template).map(pascalCase)
    }
}
----------------------------------


[test.js 03-21-2023]:
function foo123(s) {
    const speakers = ['Hammy', 'Ivy', 'Sandy']
    const dialogue = new Dialogue()
    dialogue.setSpeakers(speakers)
    dialogue.add('Hammy', 'Hi $$!')
    dialogue.add('Hi $prev')
    dialogue.add('Hi $prev')
    dialogue.add('Hi $prev')
    console.log(dialogue.run().toJSON())
}


//$$ = everyone
//$ means previous.
----------------------------------


[compileRE.js 03-21-2023]:
function regexTemplater(r, ref) {
    /* depped because rewrap2 @utils */
    const regex = reWrap(ref, /\$($1)/g)
    const source = r.source.replace(regex, (_, key) => {
        const y = ref[key]
        return parens(y.source)
    })
    return RegExp(source, r.flags)
}
----------------------------------


[googleAppConnector.js 03-22-2023]:
async function googleAppConnector(data) {
    if (data.earlyReturn) {
        return 
    }
    const action = stringCall('Action2', data)
    const prev = read(env.GOOGLE_APPSCRIPT_FILE)
    const code = join(prev, action)
    return await post(env.GOOGLE_URL, code)
}

export {
    googleAppConnector
}
----------------------------------


[consumableParse.js 03-22-2023]:
function startMyLog() {
    const original = console.log
    console.log = identity
    const store = []
    function myLog(s) {
        store.push(s)
    }
    myLog.open = () => {
        console.log = original
        store.forEach((item, i) => {
            console.log(item)
        })
    }
    return myLog
}
----------------------------------


[changelog.md 03-23-2023]:
+ Cleaned up Downloads
    moved files to root/TODO 
        - parse chinese files
        - the moment i feel hungry ... the nausea starts
        - npm init everything all at once

+ Wrote a jsoner for puppeteer @runScrape
    runScrape( "view-source:https://www.schools.nyc.gov/learning/testing/testing-calendar", {clip: true, q:})
[bug] dont know why a datestamp is popping up for puppeteer
[bug] i keep having to reinstall node/npm

12-28-2022 

+ Started using git

01-11-2023 

+ remove non-essential files from git.
+ Puppeteer requires fs/promises. This requires Node > V14.
+ Puppeteer 17 uses stackTrace instead of _stackTraceLocations
+ autofile for markdown.vim
+ Puppeteer requires going first into the terminal


[02-03-2023] "/home/kdog3682/.vimrc" MarkCode
[02-05-2023] "/home/kdog3682/JAVASCRIPT/app-main.js" ActionRef3



02-07-2023:

    javascript also escapes ...
    it is a bunch of flimsy code ...
    but everything works

    todo: connect 
    Node2:
        app-main= gac (instantly choose from a series of gac items)
        worksheet-components = visual('vt') (runs htmlBuilder)
        else runs puppetrunner ... ???? which shud be cleaned up TODO
            
    Node10:
        if exists('g:activejsfile')
            call Node(g:activejsfile)
        else
            call JavascriptAppController('puppetMaster', 'clip.html')

        activejsfile is created thru anythinghandler.set


02-10-2023 

fixed GoFile (added ./ capabilities)
made a textEdit bashAliasParser (foo0210)
added pydict[i] capability (does * better)
added unit-test to OX3
added chl to VisualAction
nnoremap 'A :call GoLastTouchedFile()<CR>
nnoremap X :call GoLastTouchedFile()<CR>
cant map it to A because ... yeah
RegistratarDollarTemplater is a stronger version of regular templater

02-12-2023 
printRepo and openLink()

02-22-2023 

@vim.open "Go" is useful sometimes. (automatic insertion-mode)
@vim.open "G"   is also useful sometimes. (stay in normal-mode)
@appscript Every function call needs to be wrapped with Finish()

+ vim.execRef q = :bd
+ vim.execRef e = :Explore

@appscript

Everything is tied to Finish()
This removes the need for ActionRef2 and ActionRef3.
Every function is a little more standalone.

@codeItem.pop() [codeOrganizer.js]

What gets popped is ... a codeItem. To get the actual thing, need a body.


Some students are never happy. You don't know what they are going through. You don't know what life at home is like. You don't know what they are dealing with. In New York, a land of ruthless competition, I have emerged as someone who wants to pass. 

Playing with me, it feels like the stakes increase. For some reason, people want to beat me. 
When you don't play with the spirit of the game, your development becomes stmied.



math.txt holds the main
active = Decimals and Averages
m.txt holds scraps and leftovers.

To teach all of the elements.
Passing knowledge.

The available happiness of a child is a function of his or her parent.

My relationships never work.
To have favoritism.
When it benefits me ...

The exam didn't go that well.
I gave everyone some extra points.

A 2 hour class is too long when the children are stuffed like sardines.
To go to higher distances.


Pick your favorite pictures.
To come earlier.
Very quickly, the happiness of a young child disappears, and you are left wondering, am I ever going to see it again?

I remember it was Robin before.
And then Nikki. 
And now Fiona.

Fiona will be ... 

Writing good report cards is very important.
I always feel like I am behind.

But I am making incremental progress.
Write now, the linebreaks matter.



Finish() connects appscript to python. The final return value must be wrapped in Finish.

The nature is to borrow fr


There are so many different parsing architectures.
Likewise, there must be so many different machine-learning architectures. 
These architectures aggregrate data in intelligent ways.

02-23-2023 parse.js
----------------------------------


[consumableParse.js 03-23-2023]:
function setupBranchesDep(branches, obj) {
    if (!branches) {
        return
    }
    branches.forEach((branch, i) => {
        if (branch.dict) {
            const dict = obj[branch.dict]
            branch.regex = reWrap(dict, branch.regex)

            /* @bookmark.1679575606 branch.fn */

            function branchDictLambda([a, b], ...args) {
                return dict[a](b, ...args)
            }

            branch.fn = branchDictLambda
            function deprecatedlambda([a, b], ...args) {
                let value = dict[a](b, ...args)
                //console.log(value); assert();
                if (branch.wrapFn) {
                    value = branch.wrapFn(value, a)
                }
                if (
                    obj.options &&
                    obj.options.wrapWithType &&
                    !value.type
                ) {
                    return {
                        type: a,
                        value,
                    }
                } else {
                    return value
                }
            }
            if (!branch.key) {
                branch.key = branch.dict.replace(
                    /dict$/i,
                    ""
                )
            }
        } else if (branch.key && !branch.fn) {
            branch.fn = obj.methods[branch.key] || identity
        } else if (isString(branch.fn)) {
            branch.key = branch.fn
            branch.fn = obj.methods[branch.fn]
        }

        /* not doing wrapWithType */
        return 
        if (
            !branch.dict &&
            obj.options &&
            obj.options.wrapWithType
        ) {
            let fn = branch.fn
            /* @bookmark.1679575606 branch.fn */
            branch.fn = (...args) => {
                /* 
                 * 
                 *
                 * */
                const newValue = fn(...args)
                //console.log(newValue); throw "";
                if (newValue.type) {
                    return newValue
                }
                return {
                    type: branch.key,
                    value: newValue,
                }
            }
        }
    })
    return branches
}
----------------------------------


[consumableParse.js 03-23-2023]:
function handleAdd(cp, item, match, indentation, newlines) {
    const {fn, enter} = item
    if (enter) {
        if (isArray(match)) {
            const matchIndex = isDefined(item.matchIndex)
                ? item.matchIndex
                : match.length - 1

            const value = cp.main(match[matchIndex], item)
            const key = match[0]
            cp.state.add({ key, value, indentation, newlines })
        } else {
            const value = cp.parse(match, item)
            const key = item.key
            cp.state.add({ key, value, indentation, newlines })
        }
        return TERMINAL
    } 
    else {
        const key = item.key
        const value = fn(match)
        cp.state.add({
            key,
            value,
            indentation,
            newlines,
        })
    }
}
----------------------------------


[consumableParse.js 03-23-2023]:
function createContext(item, state) {
    const context = {}
    context.is = 'ContextObject'
    if (item.indentation) {
        context.indentation = item.indentation
    }
    if (item.newlines > 1) {
        context.newlines = item.newlines - 1
    }
    context.index = state.index
    context.lastValue = state.output[state.index - 1]
    context.nextValue = state.peek().match
    //context.state = state
    return context
}

main(str0321)
/* @bookmark.1679573573 this.state.add */
/* @bookmark.1679575606 branch.fn */
----------------------------------


[scratchpad.js 03-23-2023]:
function tableParser(s) {
    const [_, args, kwargs] = callableArgsKwargs(s)
    if (
        args.length == 3 ||
        (args.length == 1 && exists(kwargs))
    ) {
        const data = isCallable(args[0])
            ? eval(parens(args[0]))
            : args[0]

        if (isPrimitiveArray(data)) {
            return {
                type: "table",
                rowHeaders: args
                    .slice(1)
                    .map(capitalizeTitle),
                body: [range(1, data.length + 1), data],
            }
        }
    } else {
    }
}
----------------------------------


[utils.js 03-23-2023]:
class ObjectManager {
    constructor(item) {
        if (isObject(item)) {
            this.object = item
            this.array = Object.entries(item).map(([a, b], i) => {
                if (!b.key) {
                    b.key = a
                }
                return b
            })
            this.current = this.object
        } else if (isArray(item)) {
            this.array = item
            this.object = item.reduce((acc, item, i) => {
                acc[item.key] = item
                return acc
            }, {})
            this.current = this.array
        }
    }
    get(mode) {
        if (mode == Array) {
            return this.array
        } else if (mode == Object) {
            return this.object
        } else {
            return this.current
        }
    }

    //const om = new ObjectManager({abc: {a:1}})
    //console.log(om.current.abc)
    //console.log(om.get(Array)[0] === om.current.abc)
    //console.log(om.get(Array)[0] === om.get(Object).abc === om.current.abc)
    // The objects are simply being passed back and forth
}
----------------------------------
[teaching 03-24-2023]:

function makeName(i) {
    return range(i).map(n2char).join('')
}
function makeStore(a, b) {
    const store = {}
    for (let i = a; i <= b; i++) {
        const name = makeName(i)
        const fn = (x) => x - i
        store[name] = fn
    }
    return store
}
range(4)

//console.log(makeStore(2, 4).abcd(4))
//console.log(store)
//console.log(Object.keys(store))

//let expr = stackCall(123, Object.keys(store))
//console.log(expr)
//console.log(evaluate(expr, store))
function stackCall(input, ...args) {
    let s = input
    args = reverse(flat(args))

    for (let i = 0; i < args.length; i++) {
        s = args[i] + parens(s)
    }
    return s
}
----------------------------------
[ma.js 03-24-2023]:

const makeZeroes = (data, operators, i) => {
    const reduce = (fn) => {
        let value
        return data.reduce((acc, item) => {
            value = fn(item.zeroes, operators, value, i)
            if (value) {
                acc[item.name] = value
            }
            return acc
        }, {})
    }
    if (i <= 2) {
        return reduce(sameZeroes)
    }
    else if (i <= 4) {
        return reduce(sameHorizontalZeroes)
    }
    else {
        return reduce(randomZeroes)
    }
}
----------------------------------
[ma.js 03-24-2023]:

const ref = {
    "zeroes": {
      "3": { a: [-1, 1], b: [-1, 1], },
      "4": { a: [-1, 1], b: [-1, 1], },
    },
    "numberRequirements": {
      "1": [
        "2 < a < 10",
        "2 < b < 10"
      ],
    }
}
----------------------------------
[ma.js 03-24-2023]:

function getBase10(number) {
  if (!isNumber(number)) {
      return {}
  }
  const exponent = Math.floor(Math.log10(Number(number)))
  const mantissa = number / Math.pow(10, exponent)
  return {
      exponent, mantissa,
  }
}
----------------------------------

[ma.js 03-24-2023]:
function repeat(s) {
    for (let i = 0; i < 10; i++) {
        console.log(eval(s))
    }
}
----------------------------------


[ma.js 03-24-2023]:
function addZeroes(n, x) {
    if (isArray(x)) {
        x = rng(...smallBig(x))
    }
    if (x == 0) return n
    let s = String(n)
    if (x < 0) {
        s = '0.' + '0'.repeat(Math.abs(x) - 1) + s.replace(/0+$/, '')
    } else {
        s = s.replace(/0+$/, '') + '0'.repeat(Math.abs(x))
    }
    return Number(s)
}
----------------------------------


[ma.js 03-24-2023]:
function getInterestingFactors(n) {
    const factors = getFactors(n).slice(1, -1)
    if (factors.length == 0) return null
    return factors
}
----------------------------------


[ma.js 03-24-2023]:
function iter(s, n) {
    const tally = new Tally()
    for (let i = 0; i < n; i++) {
        const value = eval(s)
        if (isNumber(value)) {
            tally.add(value)
        }
    }
    console.log(tally.store)
}
//console.log(fixFloatingPoint('0.000383999999999999'))
//iter('rng(1,4)', 100)
----------------------------------
[ec.js 03-24-2023]:

        //const data = await apiWrapper("binaryPDFData", {
            //file: "/home/kdog3682/CWF/public/test.pdf",
        //})
        //console.log(data)
        //this.pdfData = data
        //viewPDF(data)
        //console.log(data, 'gto it')
        //const blob = new Blob([data], { type: 'application/pdf' });
        //const url = URL.createObjectURL(blob);
        //window.open(url);


var VElementController = {
    name: "VElementController",
    mounted() {
        new VueWindowListener(this, VueElementControllerState)
    },
    template: `

        transition
            .left :style = style.left
                v-codeframe :url = url ref = "codeframe"

        transition
            .right :style = style.right
                .foo {
                .voice-button @activateVoice
                .statistics

        .bottom
            .active-element {activeElement}
            .input {input}

    `,
}


        //.element-controller
            //if pdfData
                //v-pdf :value = pdfData
            //else
                vm-header
                //v-render :value = value

                /* value comes from props ... */
                //v-render :value = data
                //.bottom
                    //.active-element {activeElement}
                    //.input {input}
-----------------------------------

[class.js 03-25-2023]:
    return reduce(items, (a, b) => {
        let bodyA = `return this._${a}`
        let bodyB = `this._${a} = arg\n${b}`
        let get = toStringFunction(a, '', bodyA, opts)
        let set = toStringFunction(a, 'arg', bodyB, opts)
        return [a, { get, set }]
    })
----------------------------------


[ec.js 03-25-2023]:
    touched() {
        const name = this.context.name
        if (!name) {
            return false
        }

        if (this.seenContexts.has(name)) {
            if (this.context.options.onlyInitOnce) {
                return true
            }
        }

        this.seenContexts.add(name)
        return false
    }
----------------------------------


[ec.js 03-25-2023]:
class xGroupIndexed {
    constructor() {
        this.store = {}
        this.keys = []
        this.index = 0
    }
    add(key, values) {
        this.keys.push(key)
        this.store[key] = new Indexed(values)
    }
    moveTo(key) {
        let newIndex = findIndex(key, this.keys)
        if (newIndex < 0) {
            return 
        }
        this.index = newIndex
        return this.store[this.keys[this.index]]
    }

    prev() {
        this.index = modularIncrement(this.keys, this.index, -1)
        return this.store[this.keys[this.index]]
    }

    next() {
        this.index = modularIncrement(this.keys, this.index, 1)
        return this.store[this.keys[this.index]]
    }
}
----------------------------------


[ec.js 03-25-2023]:
const a = new GroupIndexed()
//a.add('a', ['a', 'b', 'c', 'd', 'e'])
//a.add('b', ['a', 'b', 'c', 'd', 'e'])
//console.log(a.moveTo('b').moveTo('c'))
//console.log(a.toJSON()); assert();
//console.log(a)
----------------------------------


[utils.js 03-25-2023]:
let a = {a:1}
let c = a
let b = {b: 1}
a = Object.assign(a, b)
What is c?
----------------------------------


[utils.js 03-26-2023]:
class Fo {
    constructor() {
    }
    sayhi() {
        
    }
}
let a = new Fo
console.log(a.hasOwnProperty(('sayhi')))
console.log('sayhi' in a)
----------------------------------

[utils.js 03-27-2023]:
const abco = {a:1, b:2, c:3}
const nobj = {a:1, b:2, c:{a: 1, d:{e: [{a:1,  g: 1}]}}}
const anobj = [nobj, copy(nobj)]
objectEditor(anobj, (k, v) => {
    if (k == 'a') {
        return null
    }
})
console.logg(anobj)
----------------------------------


[utils.js 03-27-2023]:
const nobj = {a:1, b:2, c:{a: 1, ddd:{a: 1, e: [{a:1,  g: 1}]}}}
const axa = objectEditor(nobj, (k, v, parentKey) => {
    console.log({parentKey, k})
    if (k == 'a') {
        return 123
    }
})
console.log(nobj == axa)
----------------------------------


[Puppeteer.js 03-28-2023]:
    onError(e) {
        //console.log(Object.keys(e))
        //console.log(e)
        //console.log(e.stackTrace())
        console.log({ JAVASCRIPT_ERROR: e.toString() })
        //console.log('@puppeteer.onError: usually a syntax error')
        this.status = PUPPETEER_ERROR_STATUS
    }
----------------------------------


[Puppeteer.js 03-28-2023]:
function editPuppeteerConfigWithSysArgs(config) {
    console.log(
        "editing productionConfig.puppeteer with sysArgs"
    )
    const args = sysArgs()
    const seen = new Set()
    const find = (input, fallback) => {
        const ref = flat(input)
        return args.find((x) => ref.includes(x)) || fallback
    }
    return objectEditor(obj, (k, v, parentKey) => {
        if (seen.has(k)) {
            return
        }
        if (k == "action") {
            seen.add(k)
            const actions = [
                "screenshot",
                "print",
                "clipHTML",
            ]
            return find(actions, "screenshot")
        }
        if (k == "finalDraft") {
            seen.add(k)
            return find(k)
        }
    })
}
----------------------------------


[Puppeteer.js 03-28-2023]:
const PuppeteerOptions = {
    Publisher: PuppeteerBrowserOptions,
    Publisher2: PuppeteerBrowserOptions,
    Previewer: PuppeteerPreviewerOptions,
    preview: PuppeteerPreviewerOptions,
    scrape: PuppeteerScraperOptions,
    default: PuppeteerScraperOptions,
}
----------------------------------


[Puppeteer.js 03-28-2023]:
function describePuppeteer(j) {
    return j.executionContext().evaluate((o) => {
        const customs = ["DOMRect", "Storage"]

        if (o == null) {
            return `[null]`
        } else if (customs.includes(o.constructor.name)) {
            return JSON.stringify(o, null, 2)
        } else {
            return o
        }
    }, j)
}
----------------------------------


[Puppeteer.js 03-28-2023]:
async function runPuppeteer({
    fn,
    windowData,
    printConfig = {},
    config = {},
    css,
    file,
} = {}) {
    const o = arguments[0]
    const p = new Puppeteer(config || PreviewPageConfig)
    if (file) {
        p.file = fixPuppeteerFile(file)
    }
    await p.init(windowData, css)
    const value = await p.run(fn)
    await p.terminate()
    if (o.exit === false) {
    } else {
        await exit()
    }

    if (o.clip || config.clip) {
        clip(value)
    }
    return value
}
----------------------------------


[Puppeteer.js 03-28-2023]:
function fixPuppeteerFile(file) {
    if (/^\w+\S*?\.html$/.test(file)) {
        file = "/home/kdog3682/2023/" + file
        assert(isFile(file))
        return "file://" + file
    }
    file = fixUrl(file)
    //console.log(file)

    assert(
        isFile(file.replace("file://", "")) ||
            /localhost/i.test(file)
    )
    return file
}

//runPuppeteer(PuppeteerMathchaConfig)
//"javascriptApps.js"

//let url = 'https://mtsknn.fi/blog/coin-combinations-puzzle/'
//runScrape(url, {q: 'pre'})
----------------------------------


[serve_html_file.js 03-28-2023]:
const pdfjsItems = [
'/home/kdog3682/2023/pdfjs',
 '/home/kdog3682/2023/pdfjs/web',
 '/home/kdog3682/2023/pdfjs/web/viewer.html',
]
----------------------------------


[main.js 03-28-2023]:
function defineVariablxxe(name, value) {
    let check = `typeof ${name} == 'undefined'`
    if (eval(check)) {
        (1, eval)(`${name} = ${JSON.stringify(value)}`)
    }
}
----------------------------------


[vimrc 03-28-2023]:
function CycleServerFileCommand()
    
endfunction
----------------------------------


[consumableParse.js 03-28-2023]:
function extractClasses(obj) {
    const seen = new Set()
    const f = (k, v) => {
        if (k == 'staticClass') {
            seen.add(v)
        }
    }
    objectEditor(obj, f)

    let t = Array.from(seen).map((item, i) => {
        return `.${item} {\n    \n}\n\n`
    }).join('')
    t = indent(t, 8)
    appendSelf(t)
}
----------------------------------


[parse.js 03-29-2023]:
function getKwargs(s) {
    const r = /(\S+) *= *(\S.*?),?(?= [$\w-]+ *=|$)/g
    const items = findall(r, s)
    return dict(items, toArgument)
}
----------------------------------


[parse.js 03-29-2023]:
function getCallableAndArgs(s) {
    const callableRE = /(\w+)\((.*)\)/
    const m = search(callableRE, s.toString())
    if (!m) {
        return []
    }
    const items = split(m[1], /, */).map(getFirstWord)
    return [m[0], items]
}
console.log(getKwargs('sdfsdf = "sdfsdf" dfgdfg = {a:1} cxv-332 = "asdasd" _$g = $$$' ))
----------------------------------


[parse.js 03-29-2023]:
function prepareForVueRenderer(o) {

    const extra = {
        "staticClass": "block-item",
        "children": [
          {
            "component": "VMHeader",
            "props": {
                "title": "Grade 4 Decimals Quiz"
            }
          }
        ]
    }
    const children = o.map((el, i) => {

        const kids =  el.map((item, i) => {
        if (item.type) {
            item.component = 'V' + capitalize(item.type)
            delete item.type
        }
        if (item.hasOwnProperty('value')) {
            item.props = {value: item.value}
            delete item.value
        }
            return item
        })
        
        return {
            staticClass: 'block-item',
            children:kids  
        }
    })

    return [extra].concat(children)
    //return changeKeysRecursive(o, {
        //type: (x) => {
            //return ['component', aliases[x] || x]
        //},
        //value: (x) => {
            //return ['props', {value: x}]
        //}
    //})
}
----------------------------------


[production.config.js 03-29-2023]:
function getConfig2(args) {
    //console.log(args)
    if (!exists(args)) {
        return 
    }
    const ref = {
        build,
    }
    const g = (x, i, a) => {
        if (i == 0 && a.length == 3) {
            return addExtension(x, 'html')
        }
        return x
    }

    args = flat(xsplit(args).map((x) => x.split('.').map(g)))
    const find = (input) => {
        const fn = isFunction(input)
            ? input
            : (arg) => list(input).includes(arg)

        return args.find(fn)
    }

    const file = find((x) => getExtension(x) == 'html')
    console.log({file})
    const key = find(ref) || 'build'
    const debug = find('debug')
    const config = ref[key]
    const actions = ['screenshot', 'print', 'html', 'dryRun', 'clip', 'runWindowString', 'runLocalHost']
    const action = find(actions)
    const propKey = find(props[key])
    const finalDraft = find('finalDraft') || action == 'print'
    const componentGroupKey = search(/hammy/i, key)

    if (propKey) {
        let propValue = props[key][propKey]
        config.props.value = propValue
    }
    if (finalDraft) config.window.puppeteer.finalDraft = true
    if (componentGroupKey) {
        config.window.puppeteer.componentGroupKey = componentGroupKey
    }
    if (file) config.file = file
    if (action) config.action = action
    if (debug) config.window.debug = debug

    config.window.puppeteer.component = {
        key: config.key,
        props: config.props,
    }
    config.window.isPuppeteerEnvironment = true

    delete config.key
    delete config.props

    return config
}
----------------------------------


[production.config.js 03-29-2023]:
const build = {
    action: "screenshot",
    window: {
        debug: false,
        fooseball: 'hiya',
        puppeteer: {
            isFinalDraft: false, 
            componentGroupKey: 'default',
        },
    },

    key: "VBuild",
    props: {
        value: '200f 400 600',
        pageSettings: {
            maxHeight: 10,
            marginBottom: 0.5,
            fullWidth: false,
        },
    }
}
----------------------------------


[utils.js 03-29-2023]:
//KeyError('abc', 'def')
//console.log(deepEqual({a:1, b:[2, 1], c:3}, {a:1, c:3, b:[2,1]}))
----------------------------------


[changelog.md 03-29-2023]:
Today is Saturday.
Start with the number 0.001.
Every evening, double it.
What is the number on Wednesday morning?
----------------------------------


[changelog.md 03-29-2023]:
Sammy the snail buys 0.02 pounds of premium chocolate.
Each pound costs 7 dollars. How much money does Sammy spend?

Sammy the snail buys 0.003 pounds of gold.
Each pound costs 174 dollars. How much money does Sammy spend?
----------------------------------


[consumableParse.js 03-29-2023]:
function mcontainer(children, staticClass = "container") {
    return {
        staticClass,
        children: children.map(defaultComponentTransformer),
    }
}
----------------------------------


[Puppeteer.js 03-30-2023]:
        for (let resolution of resolutions) {
            const arg = await resolution
            if (hasError(arg)) {
                console.log('has error', [arg])
                this.setError(true)
                break
            } else {
                args.push(arg)
            }
        }
----------------------------------


[generateMultipleChoice.js 03-30-2023]:
function shiftZeros(n, i, index) {

    let s = n.toString().replace(/^0\.0*/, '')
    let {mantissa, exponent} = getBase10(n)
    //console.log(exponent)
    let ms = mantissa.toString()
    if (/9{5}/.test(ms.slice(s.length))) {
        let last = Math.round(Number(ms)).toString()[0]
        mantissa = ms.slice(0, s.length) + last
        mantissa = Number(mantissa)
        console.log({mantissa})
        //console.log(last, s)
        //console.log(ms)
        //mantissa = ms + last
        //console.log(mantissa); throw "";
    }
    let computedExponent = exponent - 1

    if (exponent < 0) {
        if (i < index) {
            computedExponent += i + 2
        } else {
            computedExponent -= i 
        }
    } else {
        if (i < index) {
            computedExponent -= i
        } else {
            computedExponent += i
        }
    }
    const value =  mantissa * Math.pow(10, computedExponent)
    return value.toString().replace(/(\d)9{7+}[1-8]?$/, (_, x) => {
        return Number(x) + 1
    })
}
----------------------------------


[worksheet-components-2.js 03-30-2023]:
function getStatement(s = 'vincent', template = '$1 is wonderful') {
    if (template) {
        s = templater(template, s)
    }
    return s
}
----------------------------------


[ma.js 03-30-2023]:
function parse(s) {
    /* done */
    const r = /([<>]=?|[|&]|=+|!=)/
    const tokens = split(s, r)
    const store = []

    let temp = []
    let count = 0

    for (let i = 0; i < tokens.length; i++) {
        let item = tokens[i]

        if (controlDelimiters.includes(item)) {
            store.push(temp)
            store.push(item)
            temp = []
        } else if (opDelimiters.includes(item)) {
            if (isEven(count)) {
                count++
                store.push(temp)
                temp = [getLast(temp), item]
            } else {
                temp.push(item)
            }
        } else {
            count++
            temp.push(item)
        }
    }
    if (exists(temp)) {
        store.push(temp)
    }
    return store
}
----------------------------------


[serve_html_file.js 04-01-2023]:
const css = {
    base:`
            * {
                box-sizing: border-box; margin: 0; padding: 0;
                outline: none;
            }
            body, html {
                height: 100%; width: 100%;
                font-family: sans;
            }
            html {
                font-size: 12pt;
            }
            body {
                 position: relative;
            }

    `
}
----------------------------------


[serve_html_file.js 04-01-2023]:
const ref = {
    build: `

        <link rel="stylesheet" href="base.css"/>
        <link rel="stylesheet" href="katex.min.css"/>
        <script src="katex.min.js"></script>
        <script src="vue.min.js"></script>
        <script type="module" src="main.js"></script>

    `,
    ham: `

        use katex
        use vue
        use vuex (by definition, vue will be imported)
        use nerdSolver
        use nerdamer
        css locals

        import { main } from "./vueSetup.js"
        import * as hammyComponents from "./hammyComponents.js"
        main('VHam', hammyComponents)

    `,
    ec: `

        <script type="module" src="ec.js"></script>
        <script src="nerdamer.min.js"></script>
        <script type="module" src="nerdSolver.js"></script>

    `
}
----------------------------------


[elementObjects.js 04-03-2023]:
mixinStyleSetters(VObject, ['padding', 'background'])
const value = new VObject()
value.setPadding(24)
value.component = 'asdfasdf'
value.attrs.foo = 'hi'
value.props.gd = 'aaa'
value.setBackground('red3')
value.staticClass = 'hi'
const child = value.appendChild()
child.value = 'yo'
console.log(value.toString())
----------------------------------


[elementObjects.js 04-03-2023]:
function templateStrategy(...args) {
    let dict
    let fn
    let mode
    let replacer
    if (isObject(args[0]) && isFunction(args[1])) {
        dict = args[0]
        fn = args[1]
        mode = 'dictWithFn'
        replacer = dictWithFn
    }
    const regex = mode == 'a'
        ? /sdfsdf/
        : mode == 'b'
        ? /asdfsadf/
        : mode == 'dictWithFn'
        ? reWrap(dict, /\b(?:$1)\b/g)
        : null


    function dictWithFn(arg) {
        return fn(dict[arg])
    }
    return [
        regex,
        replacer
    ]
}
----------------------------------


[elementObjects.js 04-03-2023]:
function calc(s, ref) {
    const fn = curryEnd(cssAddUnit, 'pt')
    s = s.replace(...templateStrategy(ref, fn))
    s = s.replace(/(\d+)%/g, (_, x) => {
        return Number(x) * 
    })
}
----------------------------------


[clock.js 04-03-2023]:
var GoldStarReport = {
    name: 'GoldStarReport',
    props: ['value'],
    template: `
        v-animation value = scenes
    `,
    mounted() {
    },
}
var VAnimation = {
    name: 'VAnimation',
    props: ['value'],
    template: `
        
    `,
    mounted() {
        this.anime = new VueAnimation(this)
    },
}







var VFourCorners = {
    name: 'VFourCorners',
    props: ['value'],
    template: `
        
    `,
}
----------------------------------


[clock.js 04-03-2023]:
class VueBaseClock extends AbstractClock {
    constructor(vue) {
        super()
        this.vue = vue

        const methods = ['onTick', 'onStart', 'onEnd']
        methods.forEach((method) => {
            if (method in this.vue) {
                this[method] = this.vue[method].bind(this.vue)
            }
        })
    }
}
    
----------------------------------


[base.py 04-03-2023]:
def _twilio(*args):
    body = join(args)
    to = env.selfphone
    from twilio.rest import Client

    client = Client(env.twiliosid, env.twilioauthtoken)
    message = client.messages.create(
        body="-\n\n\n" + body, from_=env.twiliophone, to=to
    )
    print(message)
----------------------------------


[base.py 04-03-2023]:
def sendTwilio(body="hi from twilio", to=env.selfphone):
    from twilio.rest import Client

    client = Client(env.twiliosid, env.twilioauthtoken)
    message = client.messages.create(
        body="-\n\n\n" + body, from_=env.twiliophone, to=to
    )
    print("success", message.sid)
----------------------------------


[run.py 04-03-2023]:
def gitPush(file=None, dir=dir2023):
    if file and isfile(file):
        print("this only happens if there is a file")
        if getExtension(file) == 'py':
            dir = pydir
        message = prompt('running gitPush', pydir, file, "upload message: ")

        a, b = os.path.split(file)
        if not a or len(a) < 2:
            a = dir2023

        mainCommand = f"""
            cd {a}
            git add {b}
            git commit -m "{message}"
            git push
        """
    else:
        fallbackMessage = 'howdy autopush'
        message = None
        if file:
            message = file

        if dir == dir2023 or dir == pydir:
            cleandir(dir2023)
            time.sleep(1)

        nameObject = gitNames(dir)

        time.sleep(1)
        mainCommand = f"""
            cd {dir}
            git add .
            git commit -m "'{message or fallbackMessage }'"
            git push
        """

    response = SystemCommand(mainCommand, dir=dir)
    gitData = {
        'success': response.success,
        'error': response.error,
    }
    logger(**nameObject, action='gitpush', message=message, gitData=gitData)
----------------------------------


[run.py 04-03-2023]:
def gitPushObject(obj):

    return 
    if obj['ext'] != 'js':
        print('only pushing js at the moment')
        return 

    message = obj['line'].strip()
    dir = dir2023
    mainCommand = f"""
        cd {dir}
        git add .
        git commit -m "{message}"
        git push
    """

    success = SystemCommand(mainCommand, dir=dir).success
    if success and not test('nothing to commit', success, flags=re.I):
        ofile(gitUrl(dir))

    print(obj)
----------------------------------


[elementObjects.js 04-03-2023]:
----------------------------------


[elementObjects.js 04-03-2023]:
        if (payload.component && !payload.props && value) {
            payload.props = {value}
        } else if (isDefined(value)) {
            payload.value = value
        }
        return payload
----------------------------------


[vueSetup.js 04-04-2023]:
    const f = (x) => {
        if (isString(x)) {
            return x
        }
        else {
            return x.name || JSON.stringify(x)
        }
    }
----------------------------------


[worksheet-components-2.js 04-04-2023]:
var VEmpty = {
    name: 'VEmpty',
    template: `
        span hi
            white
    `,
}
/* @bookmark 1680222315 VEmpty */
----------------------------------


[base.py 04-04-2023]:
with BeforeAfter() as ba:
    after = ba.get('after') or 3
    items = [1,2]
    ba.set('after', after)
    ba.set('items', items)
----------------------------------


[ec.js 04-04-2023]:
const PuppeteerCommandString = `
    
    /*---------------------------------*/

    Start at SimpleHandle 
    Activate paddingBottom   (pb)
    


    BREAKER ---------------------

    Goto MenuHandle           (m)
    Goto CssHandle            (c)
    Goto PaddingHandle        (p)

    Activate paddingBottom   (pb)
    Activate alignContent    (ac)
    Toggle alignContent      (ac)
    Toggle alignContent      (ac)
    Enter                 (enter)

    /*---------------------------------*/

`


let window = lorem.window
let typer = createTyper(window.keydown.bind(window))
let ex = new StyleElement()
let vuewin = new VueWindowListener(lorem.vue)
----------------------------------


[ec.js 04-04-2023]:
function initActions2(state) {
            if (!state.context.actions) {
                return 
            }
            announce()

                if (!state.context.methods) {
                    state.context.methods = {}
                } else {
                    console.log('binding methods!')
                    edit(state.context.methods, (k, v) => {
                        state.context[k] = v.bind(state.context)
                    })

                    //you dont want this because it means
                    // everything is accessible from everywhere 
                    // u want it to be self contained the way vue does it
                }

        const actions = state.context.actions
        if (isObject(actions)) {
            return map(actions, (k, v) => {
                    const fn = v.bind(state.context)
            state.context.methods[name] = fn
            })
        }
                if (!state.context.aliases) {
                    state.context.aliases = {}
                }

        actions.forEach((item, i) => {
            const {name, aliases, action} = item 
            const fn = (action || state.context[name]).bind(state.context)
            //console.log(fn)
            /* each function in this manner is bound to state */
            if (!fn) {
                console.log('error no fn')
                return 
            }

            state.context.methods[name] = fn
            if (aliases) {
                aliases.forEach((alias, i) => {
                    state.context.aliases[alias] = name
                })
            }
            //console.log(state.context)
        })
}

/* @bookmark.1678504832 ecVueState */
/* @bookmark.1678510184 listener */
/* @bookmark 1679715452 MainHandle */
//console.log(vuewin.foobar_getter_test2.toString())
//run()
----------------------------------


[ec.js 04-04-2023]:
function test_local_post() {
    if (isNode()) {
        return 
    }
    return 

    let url = "http://localhost:3000/"
    localPost(url, {action: 'sayhi', args: 'tom'}).then(console.log)

}
export {
    localPost
}

//run()
----------------------------------


[vimrc 04-05-2023]:
function GetCurrentWordOrBinding()
    
endfunction
----------------------------------


[ham.html 04-05-2023]:
<!DOCTYPE html><html lang="en">
    <head>
        <script src="vue.min.js"></script>

        <style>
            * {
                box-sizing: border-box; margin: 0; padding: 0;
                outline: none;
            }
            body, html {
                height: 100%; width: 100%;
                font-family: sans;
            }
            html {
                font-size: 12pt;
            }
            body {
                 position: relative;
            }

        </style>

        <script type="module">

            import { main } from "./vueSetup.js"
            import * as hammyComponents from "./hammyComponents.js"
            const app = main('VHam', hammyComponents)
            export {app}

        </script>
    </head>

    <body>
        <div id="app"></div>
    </body>
</html>
----------------------------------


[vimrc 04-05-2023]:
function RunServerFileOld(action, ...)
    if exists('g:fastvue')
        return RunFastVue()
    endif
    let file = '/home/kdog3682/2023/serve_html_file.js'
    let action = a:action
    let propKey = a:0 >= 1 ? a:1 : g:server_html_commands[g:server_html_index]
    let html_file = g:server_html_file
    let debug = g:server_debug
    call Node(file, propKey, action, html_file, debug)
endfunction
----------------------------------


[build.html 04-05-2023]:
<!DOCTYPE html><html lang="en">
    <head>
        <link rel="stylesheet" href="base.css"/>
        <link rel="stylesheet" href="katex.min.css"/>
        <script src="katex.min.js"></script>
        <script src="vue.min.js"></script>
        <script type="module" src="main.js"></script>
    </head>

    <body>
        <div id="app"></div>
    </body>
</html>
----------------------------------


[serve_html_file.js 04-05-2023]:
function main2(x, fn) {
    const getUrl = "/foo"
    const postUrl = "/"
    const port = 8000
    const dir = "/home/kdog3682/2023"
    const url = `http://localhost:${port}${getUrl}`

    const app = express()
    app.use(express.static(dir))
    app.use(express.json())
    app.get(getUrl, mainGet)
    app.post(postUrl, mainPost)
    app.listen(port, mainListen)

    async function mainListen(e) {
        console.log("Running Server on port", port)
        console.log(new Date().toLocaleString())
        console.log(url)
        console.log("/*---------------------------------*/")
        if (fn) {
            await fn(url)
        }
    }

    function mainGet(req, res) {
        if (isFile(x)) {
            return res.sendFile(file)
        } else {
            const html = buildServerHTML(x)
            res.send(html)
        }
    }
}
----------------------------------


[utils.js 04-05-2023]:
let str0405 = `
no
        v-svg-circle bind = circle
        //button {name} click = emit('click', name)
        //no
                        fs9
                        //top = 4
                        //left = 4
                                    
                            top = 2
                        left = 2
`
//console.log(removeComments(smarterIndent(str0405)))
----------------------------------


[serve_html_file.js 04-05-2023]:
function main({
    getUrl = "/foo",
    postUrl = "/",
    port = 8000,
    dir = "/home/kdog3682/2023",
    items = null,
    file = "ec.html",
    puppeteer = true,
} = {}) {
    file = addExtension(file, "html")

    const puppeteerConfig = arguments[0]
    if (puppeteerConfig.action == "earlyReturn") {
        console.logg(puppeteerConfig)
        return
    }
    const app = express()

    if (items) {
        app.use(express.urlencoded({ extended: true }))
        items.forEach((item, i) => {
            if (isFile(item)) {
                file = item
            } else if (isDir(item)) {
                app.use(express.static(item))
            }
        })
    } else {
        app.use(express.static(dir))
        assert(isFile(file))
    }

    app.use(express.json())
    app.get(getUrl, mainGet)
    app.post(postUrl, mainPost)
    app.listen(port, mainListen)

    async function mainListen(e) {
        console.log("Running Server on port", port)
        console.log(new Date().toLocaleString())

        const url = `http://localhost:${port}${getUrl}`
        if (puppeteer) {
            const p = new Puppeteer(url)
            if (puppeteer === true) {
                await p.init(puppeteerConfig)
                await p.run()
            } else {
                await p.run(puppeteer)
            }
        }
    }

    function mainGet(req, res) {
        if (file) {
            console.log("Serving", file)
            return res.sendFile(npath(dir, file))
            const html = read(file)
            res.send(html)
        } else {
            console.log("no file")
        }
    }
}
----------------------------------


[serve_html_file.js 04-05-2023]:
function mainPost(req, res) {
    const kwargs = req.body
    try {
        const fn = serverApps[kwargs.action]
        if (!fn) {
            const message = `${kwargs.action} is not a serverApp`
            return res.json({ error: message })
        }
        const args = toArray(kwargs.args) || []
        const value = fn(...args)
        return res.json({ success: value || true })
    } catch (e) {
        return res.json({
            error: { ...kwargs, stack: e.stack },
        })
    }
}
----------------------------------


[serve_html_file.js 04-05-2023]:
function fixProps(options) {
    let props = options.window.puppeteer.component.props
    if (!isPrimitive(props)) {
        return options
    }

    let val

    if (props == "clip") {
        val = clip()
    }
    if (
        props == "1" ||
        props == "default" ||
        props == "string"
    ) {
        val = ws2(1)
    } else if (props == "2") {
        val = ws2(2)
    } else if (props == "test-1" || props == "t1") {
        val = ws2(1, read("quiz.txt"))
    }

    options.window.puppeteer.component.props = {
        value: val,
    }
    //console.log(val); assert();
    return options
}
----------------------------------


[worksheet-components-2.js 04-06-2023]:
var VMeasure = {
    name: "VMeasure",
    props: ["value", "pageSettings"],
    async mounted() {
        this.measure()
    },
    render(h) {
        const options = {
            staticClass: "v-measure-container",
            attrs: {
                "data-id": "v-measure-data-id",
                "data-foo": [1, 2],
            },
        }
        return h("div", options, this.$slots.default)
    },
    methods: {
        measure: onMeasure,
    },
}
----------------------------------


[worksheet-components-2.js 04-06-2023]:
var VBuildManager = {
    name: 'VBuildManager',
    props: ['value'],
    render(h) {
        console.log(this.value,  'this.value')
        const key = 'booga'
        const ref = {
            //booga:
        }
        const value = isString(key)
            ? ref[key] || key
            : key
        return h(VBuild, propIt(value))
    },
}
----------------------------------


[vueData.js 04-06-2023]:
function onMeasureOld(childRects) {

    let elements = this.computedValue
    if (isObject(elements)) {
       elements = elements.children 
    }

    const measurements = getMeasurements(
        childRects,
        elements,
    )
    console.log(...measurements)

    const vob = new VObject()
    vob.setClass("document-root-container")

    measurements.forEach((pageMeasurements, pageIndex) => {
        const [page, body] = vob.createPageAndBody()

        pageMeasurements.forEach((measure) => {
            
            const element = elements[measure.index]
            const bodyItem = body.appendChild(element)
            bodyItem.setPosition(measure.position)
            bodyItem.setYellow()

            if (bodyItem.fullWidth) {
                //bodyItem.setWidth('100%')
                bodyItem.setWidth(540)
            } else {
                //bodyItem.setWidth("45%")
                bodyItem.setWidth(250)
            }
        })

        const footer = {
            component: "VMFooter",
            props: { pageNumber: pageIndex + 1 },
        }
        page.appendChild(footer)
    })
    this.measuredValue = vob.toJSON()
    return 

    measurements.forEach((pageMeasurements, pageIndex) => {
        const page = vob.appendChild()
        page.wrapInPageContainer()

        const body = page.appendChild()
        body.setClass("block-item-body")

        pageMeasurements.forEach((position) => {
            i++
            const element = elements.shift()
            const bodyItem = body.appendChild(element)
            try {
                bodyItem.setPosition(position)
                bodyItem.setYellow()
            } catch(e) {
                console.log("ERRORRRRRRRR", e.stack)
                throw ''
            }
            if (i > 0) {
                bodyItem.setWidth("45%")
                //bodyItem.setPaddingBottom("45%")
            } else {
                bodyItem.setWidth("100%")
            }
        })

        const footer = {
            component: "VMFooter",
            props: { pageNumber: pageIndex + 1 },
        }

        page.appendChild(footer)
    })

    const measuredValue = vob.toJSON()
    //console.log(measuredValue)
    this.measuredValue = measuredValue
}
----------------------------------


[vueData.js 04-06-2023]:
function xgetMeasurements(rects, options) {
    const ep = new ElementPageStorage3(options)
    return ep.measure(rects)
}
----------------------------------


[htmlBuilder.js 04-06-2023]:
main(`

            div .v-build
                if measuredValue
                    v-render :value = measuredValue
                else
                    v-measurement @onMeasure :pageSettings
                        v-render :value = computedValue
                            p hi from kdog3682@gmail.com
breaker
no


    v-markdown value = """
    color = yellow
    tricolor scheme
    once it gets up ...
    it will get going ...
    give my email ...

    An interface to reply to emails
    ----------------
    Hi everyone,
    Mr. Lee is still working on Hammy's website, but it is not ready yet.
    Hopefully a few more days, and everything will be ready.

    Hammy, Sammy the snail, and Mr. Lee are going to work hard.

    An announcement from Sammy: Sometimes, it's not how fast you go. It's how far you go.
    An announcement from Hammy: Remember to eat cake!

    """
`)

//snail
----------------------------------


[htmlBuilder.js 04-06-2023]:
var Vndy = {
    name: 'Vndy',
    props: ['fullName', 'firstName', 'files'],
    css: `
        * {
            //ored
        }
    `,
    template: `

        div
            p = 40
            bgb3

            div
                bg = white
                rel
                //h = 60vh
                p20
                br10

                div
                    flex-between
                    //border(1, b7, b = 1)
                    p10

                    h1 {fullName}

                    h2 Hammy Math
                        px20
                        fcb3

                div
                    my = 24
                    p10

                    .text-container
                        p Hi everyone,
                        p Mr. Lee is still working on Hammy's website, but it is not ready yet.
                        Hopefully a few more days, and everything will be ready.
                    div .flexer
                        flex
                        gap20
                        aic 

                        div .flexer
                            flexcol
                            bold

                            p Hammy
                                fcg3
                            p Sammy the snail
                                fcy7

                            p and Mr. Lee 

                            .flexer
                                center
                                fs16
                                bold
                                fcb3
                                p are going to work hard to build a wonderful math website!

                v-list :value = computedFiles
                    template slot = {item}
                        .file-tab
                            border(b7, 0.5, y = 1)
                            fitc
                            flex
                            aic
                            gap12


                            p {item.date}
                                fcb7
                                bold

                            p {item.name}

/* @bookmark 1680323981 filetab */
                            button .open-url @click = openUrl(item.url) open
                                br5
                                px10
                                py3
                                white
                                bold
                                bgb3

        v-contact-fourth-grade
            h = 50vh
                    
    `,
    methods: {
        openUrl(url) {
            //console.log(url)
        }
    },
    computed: {
        computedFiles() {
            return this.files
        }
    },
}
//main(Vndy)
//
//
----------------------------------


[ga.py 04-06-2023]:
def create_doc_from_json(data): # doesnt work
    gdoc = GoogleDocs()
    document = gdoc.create()

    requests = []

    for element in data:
        if element['type'] == 'heading':
            requests.append({
                'createHeader': {
                    'sectionBreakLocation': {
                        'index': element['index']
                    },
                    'type': element['headingType']
                }
            })
        elif element['type'] == 'paragraph':
            requests.append({
                'insertText': {
                    'location': {
                        'index': element['index']
                    },
                    'text': element['text']
                }
            })
        elif element['type'] == 'table':
            table = {
                'tableRows': []
            }
            for row in element['rows']:
                table_row = {
                    'tableCells': []
                }
                for cell in row:
                    table_row['tableCells'].append({
                        'content': cell
                    })
                table['tableRows'].append(table_row)
            requests.append({
                'insertTable': {
                    'location': {
                        'index': element['index']
                    },
                    'table': table
                }
            })

    result = gdoc.batchUpdate(document, requests)
    pprint(result)
    url = get_doc_url(document)
    ofile(url)
----------------------------------


[routers.pdfgen.js 04-06-2023]:
function get() {
    const response = await axios.get('https://example.com/api/getAssignments', {
      params: {
        work,
        student
      }
    })

    const assignments = response.data
}

router.get('/:student/:work', async (req, res) => {
  const { student, work } = req.params



    let htmlContent = ''
    assignments.forEach(assignment => {
      htmlContent += `<p>${assignment.title}: ${assignment.description}</p>`
    })





    res.send('PDF Generated!')
  } catch (error) {
    console.error(error)
    res.status(500).send('Error generating PDF')
  }
})
----------------------------------


[routers.pdfgen.js 04-06-2023]:
async function updateSheet(req, res, next) {
  try {
    const { student } = req.params

    await axios.post('https://example.com/api/updateSheet', {
      student
    })
    next()
  } catch (error) {
    console.error(error)
    res.status(500).send('Error updating Excel sheet')
  }
}

router.get('/:work/:student', updateSheet, async (req, res) => {
  const { work, student } = req.params

  try {

    const response = await axios.get('https://example.com/api/getAssignments', {
      params: {
        work,
        student
      }
    })

    const assignments = response.data


    let htmlContent = ''
    assignments.forEach(assignment => {
      htmlContent += `<p>${assignment.title}: ${assignment.description}</p>`
    })





    res.send('PDF Generated!')
  } catch (error) {
    console.error(error)
    res.status(500).send('Error generating PDF')
  }
})

module.exports = router
----------------------------------

[vco.js 04-07-2023]:
class VueComponentObject {
    constructor() {
        this.data = new Storage()
        this.computed = {}
        this.name = 'ComponentObject'
    }

    createVob() {
        function get() {
            return this._vue || (this._vue = new VueBlockWrapper(this))
        }
        mixin(VObject, {vue: {get}})
        this.vob = new VObject()
        this.vob.$component = this
        return this.vob
    }
    toJSON() {
        const template = this.vob.toString()
        const data = merge(this.data, this.storage.toJSON())
        const mounted = function mounted() {
            new VueWindowListener(this) 
        }

        return {
            name,
            data,
            template,
            mounted,
        }
    }
    createApp() {
        appWrapper(this.toJSON())
    }
}
----------------------------------

[vco.js 04-07-2023]:
class VueBlockWrapper {
    constructor(BlockItem) {
        this.state = BlockItem
    }
    setAttribute(key, ...variations) {
        const comp = this.state.root.$component
        const pluralKey = pluralize(key)
        const keyIndex = key + 'Index'

        this.state.setAttribute(':' + key, key)
        variations.forEach((variation, i) => {
            comp.data.add(pluralKey, variation)
        })
        function computed() {
            return this[pluralKey][this[keyIndex]]
        }

        comp.computed[key] = computed
        comp.data.set(keyIndex, 0)
    }
}
----------------------------------

[vco.js 04-07-2023]:
function dumb(s) {
    let temp = [1,2]
    
    const vco = new VueComponentObject()
    const vob = vco.createVob()
    //console.log(vob.vue)
    for (let item of temp) {
        const page = vob.createPageItem()
        page.setBackground('y1')
        page.inner.setBackground('b3')
        page.body.setBackground('y7')
        page.body.vue.setAttribute('height', 'auto', '50%', '100%')
        page.appendChild(box(10, 10))
        //page.appendFooter('hi')
        break
    }
    
    console.log(vob.$component.toJSON())
    //console.log(vob.toString())
    /* @bookmark 1680894178 this.appendChild */
}
----------------------------------

[base.py 04-08-2023]:
def deepEqual(_v1, _v2):
    import operator
    import types

    def _deep_dict_eq(d1, d2):
        k1 = sorted(d1.keys())
        k2 = sorted(d2.keys())
        if k1 != k2:  # keys should be exactly equal
            return False
        return sum(
            deepEqual(d1[k], d2[k]) for k in k1
        ) == len(k1)

    def _deep_iter_eq(l1, l2):
        if len(l1) != len(l2):
            return False
        return sum(
            deepEqual(v1, v2) for v1, v2 in zip(l1, l2)
        ) == len(l1)

    op = operator.eq
    c1, c2 = (_v1, _v2)

    for t in [str]:
        if isinstance(_v1, t):
            break
    else:
        if isinstance(_v1, dict):
            op = _deep_dict_eq
        else:
            try:
                c1, c2 = (list(iter(_v1)), list(iter(_v2)))
            except TypeError:
                c1, c2 = _v1, _v2
            else:
                op = _deep_iter_eq

    return op(c1, c2)
    # print(deepEqual([{'a':1}, 1], [1, {'a': 1}]))
    # fails because of the type ordering
----------------------------------

[base.py 04-08-2023]:
def deleteFiles(files, save=0, title=0):
    map(files, mfile, trashdir)
    if save:

        def infoRunner(f):
            return [tail(f), datestamp(f)]

        info = map(files, infoRunner)
        payload = prettyTable(info, title=title)
        happend(save, payload)
        print("Finished deleting files")
----------------------------------

[base.py 04-08-2023]:
def rnl():  # name: renameLastFile
    f = glf()
    print(f)
    s = input("new name: ")
    mfile(f, changeFileName(f, s))
----------------------------------

[base.py 04-08-2023]:
def smartRead(file):
    dirs = unique(list(dirdict.values()))
    for dir in dirs:
        f = os.path.join(dir, file)
        if isfile(f):
            return pprint(read(f))
----------------------------------

[base.py 04-08-2023]:
def moveFilesByTimeStamp():
    return map(getFilesByTimeStamp(), mfile, jsdir)
----------------------------------

[base.py 04-08-2023]:
def filePicker(dir, key="open"):
    items = (
        dir
        if isArray(dir)
        else sorted(absdir(dirdict.get(dir)), key=mdate)
    )
    files = choose(items)

    if key == "open":
        map(files, ofile)
    elif key == "rename":
        for file in files:
            mfile(
                file,
                changeFileName(
                    file, input(file + "\nnew name? ")
                ),
            )

    else:
        print(files[0])
        return files[0]
----------------------------------

[base.py 04-08-2023]:
def h(data=0):
    hfile = normpath(jsondir, "temp.json")
    if data:
        write(hfile, data, open=1)
    else:
        return read(hfile)
----------------------------------

[base.py 04-08-2023]:
def normFactory(fn):
    def lambdaNorm(file, *args, **kwargs):
        return fn(normDirPath(file), *args, **kwargs)

    return lambdaNorm

normOpen = normFactory(openBrowser)
normWrite = normFactory(write)
normRead = normFactory(read)
normAppend = normFactory(append)

----------------------------------

[base.py 04-08-2023]:
localfiledict = {}
localfiledict["t2"] = "test2.html"
localfiledict["tt"] = "temp.html"
urldict = {}

urldict[
    "cle"
] = "https://newyork.craigslist.org/search/edu#search=1~list~0~0"

urldict[
    "cwt"
] = "https://docs.google.com/spreadsheets/d/1Y3KRa7m3Nc8Z9ZGnKDFflGl5mldGBcosY1XIBYMF_Uo/edit#gid=1470853595"

urldict[
    "wea"
] = "https://www.google.com/search?q=weather&rlz=1CACCBQ_enUS943US943&oq=weather&aqs=chrome.0.69i59j35i39j46i131i199i433i465i512j0i131i433i512j0i67i131i433i457j0i402l2j69i61.541j1j7&sourceid=chrome&ie=UTF-8"

urldict["r"] = "reddit"
urldict["mc"] = "https://www.mathcha.io/editor"
urldict["gmail"] = "gmail.com"
urldict["red"] = "reddit"
----------------------------------

[base.py 04-08-2023]:
def rename_file():
    f = glf(dir2023)
    mfile(f, changeExtension(f, 'js'))
----------------------------------

[variables.js 04-09-2023]:
//function f(o) {
    //return dict(map(o, (k, v) => [v.toLowerCase(), k]))
//}
//appendVariable('ColorBrewerAliases', f(ColorBrewerAliases))
----------------------------------

[pdfgen.components.document.js 04-09-2023]:
    buildPageTooComplicated(pageMeasure, pageIndex) {
        const page = this.vob.createPageItem()
        page.style.zIndex = 1
        const body = page.body 
        //body.style.zIndex = 2
        page.setBackground(incrementColor())
        body.setBackground(incrementColor())
        body.setDisplay('inline-block')

        for (let [k, v] of Object.entries(pageMeasure)) {
            if (empty(v)) continue
            const container = body.appendChild()
            container.style.zIndex = 3
            const first = v[0]
            container.setClass(k)
            container.setPosition(first.position)
            container.setDisplay('inline-block')
            container.setBackground(incrementColor())

            for (let data of v) {
                const ref = this.htmlElements[data.index]
                const child = container.appendChild()
                child.setPosition(data.position)
                const message = sayhi(`Element ${data.index + 1}`)
                child.setValue(message)
                child.setWidth(ref.width)
                child.setHeight(ref.height)
            }
            /* @bookmark 1681068266 ElementMessage */
        }
    }
----------------------------------

[elementObjects.js 04-10-2023]:
    createFullPageBlockItem(mode) {
        return this.createBlockItem("fullPage")
    }
    createBlockItem(mode) {
        const block = new BlockItem(null, this)
        this.appendChild(block)

        if (mode == "fullPage") {
            //block.setWidth(VOB.dimensions.fullWidth)
            //block.setHeight(VOB.dimensions.fullHeight)
            block.setWidth("100%")
            block.setHeight("100%")
        } else if (mode == "fullWidth") {
            block.setWidth(VOB.dimensions.fullWidth)
        }
        return block
    }

----------------------------------
const _lut = [ '00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff' ];

function uid() {

	const d0 = Math.random() * 0xffffffff | 0;
	const d1 = Math.random() * 0xffffffff | 0;
	const d2 = Math.random() * 0xffffffff | 0;
	const d3 = Math.random() * 0xffffffff | 0;
	const uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
			_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
			_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
			_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

	// .toLowerCase() here flattens concatenated strings to save heap memory space.
	return uuid.toLowerCase();

}
//console.log(uid())
[pdfgen.components.document.js 04-12-2023]:
var VBuild = {
    name: "VBuild",
    templatex: `
        if isMultipleVobObjects
            v-build :value = item for = value
        else
            div .v-build
                if measuredValue
                    v-render :value = measuredValue
                else
                    v-measurement @onMeasure :pageSettings = pageSettings
                        v-render :value = computedValue
    `,
    render(h) {
        if (isArray(this.value)) {

            const children = this.value.map((item, i) => {
                return h(VBuild, {props: {value: item}})
            })
            return simpleWrapper(h, 'build-container', children)
        }

        if (this.measuredValue) {

            return h(VRender, {props: {value: this.measuredValue}})
        }

        assert(isVob(this.computedValue))
        const slot =  h(VRender, {props: {value: this.computedValue}})
        return h(VMeasurement, {
            on: { onMeasure: this.onMeasure.bind(this) },
            props: {
                pageSettings: this.pageSettings
            }
        }, [slot])
    },
    computed: {
        computedValue() {
            if (isString(this.value)) {
                return vobFromString(this.value)
            }
            return this.value
        },
    },
    props: ["value", "pageSettings"],
    data() {
        return { measuredValue: null }
    },
    methods: {
        onMeasure,
    },
}
----------------------------------

[pdfgen.components.document.js 04-12-2023]:
var xDocument = {
    name: 'Document',
    props: ['items'],
    data() {
        return {
            measuredItems: null
        }
    },
    methods: {
        //onMeasure,
    },
    render(h) {
        const onMeasure = this.onMeasure.bind(this)
        const finalDraftOptions = {props: {items: this.measuredItems}}
        const roughDraftOptions = {
            props: {items: this.items},
            on: { onMeasure },
        }
        const options =  this.measuredItems
            ? finalDraftOptions
            : roughDraftOptions

        return vueRenderer(this, options)
    },
}
----------------------------------

[pdfgen.components.document.js 04-12-2023]:
var Page = {
    name: 'Page',
    props: ['background', 'header', 'footer', 'blocks'],
    template: `
        
        svg-background :bind = background
        .page-outer-container
            .page-inner-container
            
                page-header :bind = header
                .page-body 
                    .block-item for = blocks
                page-footer :bind = footer 
                    
            
    `,
}
----------------------------------

[pdfgen.components.document.js 04-12-2023]:
var Document = {
    name: "Document",
    render(h) {
        if (this.measuredItems) {
            return vueRenderer(this, this.measuredItems)
        }

        const options = {
            on: { 
                onMeasure(measuredItems) {
                    self.measuredItems = measuredItems
                },
            },
            props: { 
                pageSettings: this.pageSettings,
                value: this.items,
            }
        }
        return h(Measurement, options)
    },
    props: ["items", "pageSettings"],
    data() {
        return { measuredItems: null }
    },
}
----------------------------------

[pdfgen.components.document.js 04-12-2023]:
var Measurement = {
    name: "Measurement",
    props: ["pageSettings", "value"],
    mounted: doMeasure,
    render(h) {
        if (this.value) {
            return vueRenderer(this, this.value)
        }
        return h('div', this.$slots.default)
    },
}
----------------------------------

[pdfgen.components.document.js 04-12-2023]:
function doMeasure() {
    const isSlot = this.$slots.default.length
    const htmlElements = isSlot
        ? this.$el.children[0].children
        : this.$el.children

    /* if slot children exist
     * that means this is wrapper
     * this.$el is VMeasure
     * this.$el.children[0] is the wrapped item.
     * And so the children is the child of children[0]
     * */

    const propElements = isArray(this.value)
        ? this.value
        : this.value.children /* usually this */

    const pages = new Pages(
        this.pageSettings, 
        htmlElements,
        propElements,
    )

    const measuredItems = pages.toJSON()
    this.$emit('onMeasure', measuredItems)
}
----------------------------------

[serve_html_file.js 04-12-2023]:
    function mainGet(req, res) {
        console.log('this should not active when dynamicRouting is active')
        return res.send('nonono')
        return 
        if (isFile(html)) {
            res.sendFile(html)
        } else {
            res.send(html)
            console.log("sending html")
        }
    }

    function mainPost(req, res) {
        try {
            return res.json(
                successWrap(post(req.body, req.params))
            )
        } catch (e) {
            return res.json(errorWrap(e))
        }
    }
----------------------------------

[today.js 04-14-2023]:
function colorComponentByHandNogo() {
    entries(colors).forEach(([a,b]) => {
        const group = groups.appendChild()
        group.setWidth('100vw')
        group.setHeight('100vh')
        const title = group.appendChild('h2')
        title.setValue(a)
        const colorColumn = group.appendChild()
        entries(b).forEach(([k, v]) => {
            const columnName = aliases[k] || k
        })
    })
}
----------------------------------

[scratchpad.js 04-15-2023]:
function renderSlot(h, name, value, options = {}) {
    return h('template', {
        slot: name,
        ...options,
    }, [value])
}
----------------------------------

[scratchpad.js 04-15-2023]:
function num_tex_symbols(tex) {
  /*
  This function attempts to estimate the number of symbols that
  a given string of tex would produce.

  Warning, it may not behave perfectly
  */
  // First, remove patterns like \begin{align}, \phantom{thing},
  // \begin{array}{cc}, etc.
  const pattern = new RegExp(
    ["begin", "end", "phantom", "text"]
      .map(
        (s) =>
          `(\\\\${s})(\\{\\w+\\})?(\\{\\w+\\})?(\\[\\w+\\])?`
      )
      .join("|"),
    "g"
  );
  tex = tex.replace(pattern, "");

  // Progressively count the symbols associated with certain tex commands,
  // and remove those commands from the string, adding the number of symbols
  // that command creates
  let total = 0;

  // Start with the special case \sqrt[number]
  for (const substr of tex.match(/\\sqrt\[[0-9]+\]/g) || []) {
    total += substr.length - 5; // e.g. \sqrt[3] is 3 symbols
    tex = tex.replace(substr, " ");
  }

  const general_command = /\\[a-zA-Z!,-/:;<>]+/g;
  for (const substr of tex.match(general_command) || []) {
    total += TEX_TO_SYMBOL_COUNT[substr] || 1;
    tex = tex.replace(substr, " ");
  }

  // Count remaining characters
  total += Array.from(tex).filter(
    (c) => !"^{} \n\t_$\\&".includes(c)
  ).length;
  return total;
}

//console.log(num_tex_symbols('\\frac{2}{3}'))
----------------------------------

[scratchpad.js 04-15-2023]:
class GPTRunner {
    constructor() {
        this.instructions = []
        this.$input = elementGetter('input')
        this.chunks = textChunks
        this.chunkIndex = 0
        this.clock = new Clock()
        this.clock.onTick = this.onTick.bind(this.onTick)
    }
    instruction(key) {
        const instruction = instructions[key] || key
        this.instructions.push(instruction)
    }
    run() {
        this.clock.start()
    }
    onTick() {
        if (this.sleeping) {
            this.sleeping--
            return 
        }
        const pos = this.getPageHeight()
        if (!this.lastPos || pos == this.lastPos) {
            this.ask()
            this.sleep(20)
        }
        this.lastPos = pos
    }
    getPageHeight() {
        
    }
    sleep(n) {
        this.sleeping = n
    }
    ask() {
        const textChunk = this.chunks[this.chunkIndex++]
        if (!textChunk) {
            this.clock.stop()
            downloadGPT()
        }
        const question = join(this.instructions, textChunk)
        this.$input.value = question
        /* if this doesnt work ... */
        /* overriding the limits ... */
        /* how many questions are you allowed to ask per day */
        /*  */
    }
}
----------------------------------

[notepad.txt 04-16-2023]:
imapclear <buffer>
inoreab <buffer> <expr> ds strftime('%m-%d-%Y')
inoremap <buffer> ;l --------------------------------
inoremap <buffer> <silent> <expr> 2 TextTwo()
inoremap <buffer> <silent> <expr> 3 TextThree()
nnoremap <buffer> qw A<CR><TAB>
inoremap <buffer> qw <CR><TAB> 
inoremap <buffer> <silent> <expr> \ TextBackSlash(0)
nnoremap <buffer> <silent> \ :call TextBackSlash(1)<CR>
inoremap qe <ESC>:call SetCursorAtDedent()<CR>A


asdf
sdfsdfsdfsd
----------------------------------

[today.js 04-18-2023]:
function makeComputedFromComputedValue(fn, ...args) {
    /* not being used */
    const data = fn(...args)
    //console.log({data})
    const keys = Object.keys(data)
    //console.log(keys)
    const rest = keys.reduce((acc, key, i) => {
        acc[key] = function () {
            return this.computedValue[key]
        }
        return acc
    }, {})
    const store = {
        computedValue() {
            return fn(this.value)
        },
        ...rest
    }
    return store
}
----------------------------------

[today.js 04-19-2023]:
const jsKeys = [
  "color",
  "font-size",
  "font-family",
  "font-style",
  "font-weight",
  "background-color",
  "background-image",
  "background-position",
  "background-repeat",
  "border",
  "border-radius",
  "box-shadow",
  "cursor",
  "display",
  "height",
  "width",
  "margin",
  "margin-top",
  "margin-right",
  "margin-bottom",
  "margin-left",
  "padding",
  "padding-top",
  "padding-right",
  "padding-bottom",
  "padding-left",
  "position",
  "top",
  "right",
  "bottom",
  "left",
  "text-align",
  "text-decoration",
  "text-overflow",
  "white-space",
  "vertical-align",
  "list-style",
  "outline",
  "outline-offset",
  "outline-style",
  "outline-width",
  "visibility",
  "z-index"
]

const jsKeyAliases = {
  color: ["color"],
  fontSize: ["font-size", "fs"],
  fontFamily: ["font-family", "ff"],
  fontStyle: ["font-style", "fst"],
  fontWeight: ["font-weight", "fw"],
  backgroundColor: ["background-color", "bg-color"],
  backgroundImage: ["background-image", "bg-image"],
  backgroundPosition: ["background-position", "bg-position"],
  backgroundRepeat: ["background-repeat", "bg-repeat"],
  border: ["border"],
  borderRadius: ["border-radius", "border-r"],
  boxShadow: ["box-shadow", "shadow"],
  cursor: ["cursor"],
  display: ["display"],
  height: ["height"],
  width: ["width"],
  margin: ["margin"],
  marginTop: ["margin-top", "mt"],
  marginRight: ["margin-right", "mr"],
  marginBottom: ["margin-bottom", "mb"],
  marginLeft: ["margin-left", "ml"],
  padding: ["padding"],
  paddingTop: ["padding-top", "pt"],
  paddingRight: ["padding-right", "pr"],
  paddingBottom: ["padding-bottom", "pb"],
  paddingLeft: ["padding-left", "pl"],
  position: ["position"],
  top: ["top"],
  right: ["right"],
  bottom: ["bottom"],
  left: ["left"],
  textAlign: ["text-align", "align"],
  textDecoration: ["text-decoration", "text-deco"],
  textOverflow: ["text-overflow", "text-ov"],
  whiteSpace: ["white-space", "whitespace"],
  verticalAlign: ["vertical-align", "va"],
  listStyle: ["list-style", "ls"],
  outline: ["outline"],
  outlineOffset: ["outline-offset", "outline-off"],
  outlineStyle: ["outline-style", "outline-st"],
  outlineWidth: ["outline-width", "outline-w"],
  visibility: ["visibility", "vis"],
  zIndex: ["z-index", "z"]
};

const jsKeysTypes = {
  color: "color",
  fontSize: "number|string",
  fontFamily: "string",
  fontStyle: "string",
  fontWeight: "number|string",
  backgroundColor: "color",
  backgroundImage: "string",
  backgroundPosition: "string",
  backgroundRepeat: "string",
  border: "string",
  borderRadius: "number|string",
  boxShadow: "string",
  cursor: "string",
  display: "string",
  height: "number|string",
  width: "number|string",
  margin: "number|string",
  marginTop: "number|string",
  marginRight: "number|string",
  marginBottom: "number|string",
  marginLeft: "number|string",
  padding: "number|string",
  paddingTop: "number|string",
  paddingRight: "number|string",
  paddingBottom: "number|string",
  paddingLeft: "number|string",
  position: "string",
  top: "number|string",
  right: "number|string",
  bottom: "number|string",
  left: "number|string",
  textAlign: "string",
  textDecoration: "string",
  textOverflow: "string",
  whiteSpace: "string",
  verticalAlign: []
  outline: "color",
  visibility: "boolean",
  opacity: 'number',
  zIndex: "number"
};

{
  "flexProperties": {
    "align-items": {
      "type": "string",
      "values": ["flex-start", "center", "baseline", "flex-end", "stretch"]
    },
    "justify-content": {
      "type": "string",
      "values": ["flex-start", "center", "space-between", "space-around", "space-evenly"]
    },
    "flex-direction": {
      "type": "string",
      "values": ["row", "row-reverse", "column", "column-reverse"]
    },
    "flex-wrap": {
      "type": "string",
      "values": ["nowrap", "wrap", "wrap-reverse"]
    },
    "flex-grow": {
      "type": "number",
      "default": 0
    },
    "flex-shrink": {
      "type": "number",
      "default": 1
    },
    "flex-basis": {
      "type": "string|number",
      "default": "auto"
    }
  },
  "gridProperties": {
    "grid-template-columns": {
      "type": "string",
      "default": "none"
    },
    "grid-template-rows": {
      "type": "string",
      "default": "none"
    },
    "grid-template-areas": {
      "type": "string",
      "default": "none"
    },
    "grid-template": {
      "type": "string",
      "default": "none"
    },
    "grid-column-start": {
      "type": "string|number",
      "default": "auto"
    },
    "grid-column-end": {
      "type": "string|number",
      "default": "auto"
    },
    "grid-row-start": {
      "type": "string|number",
      "default": "auto"
    },
    "grid-row-end": {
      "type": "string|number",
      "default": "auto"
    },
    "grid-column": {
      "type": "string",
      "default": "auto"
    },
    "grid-row": {
      "type": "string",
      "default": "auto"
    },
    "grid-area": {
      "type": "string",
      "default": "auto"
    }
  }
}

----------------------------------

[temp.js 04-20-2023]:
function multiples(n, a, b) {
    assert((a - b) % n === 0)
    const store = []
    let c = a
    while (true) {
        breaker(30)
        store.push(c)
        if (c == b) {
            return store
        }
        c += n
    }
}
----------------------------------

[today.js 04-21-2023]:
class SayHi {
    constructor() {
        this.greeting = 'Hi'
        this.suffix = ''
    }
    sayhi(person) {
        return `${this.greeting} ${person}${this.suffix}`
    }
}
const a = new SayHi()
methodWrap(a, 'sayhi',  {
    before(state, a, b) {
        console.log('before is active')
        state.suffix = '!!!'
    },
    once: true,
    after(state, a, b) {
        state.suffix = ''
    },
})
console.log(a.sayhi('Tom'))
console.log(a.sayhi('Bob'))
----------------------------------

[foo.html 04-21-2023]:
paper.html
<style>
.paper-container {
    background: -webkit-linear-gradient(#f0f0f0, #fff);
    padding: 3%;
    height: 94%;
    font: normal 14px "Lucida Grande", arial, sans-serif;
}
 
.paper {
        margin: 0 auto;
        padding: 6px 5px 4px 42px;
        position: relative;
        color: #444;
        line-height: 20px;
        border: 1px solid #d2d2d2;
        background: #fff;
        background: -webkit-gradient(linear, 0 0, 0 100%, from(#d9eaf3), color-stop(4%, #fff)) 0 4px;
        background: -webkit-linear-gradient(top, #d9eaf3 0%, #fff 8%) 0 4px;
        background: -moz-linear-gradient(top, #d9eaf3 0%, #fff 8%) 0 4px;
        background: -ms-linear-gradient(top, #d9eaf3 0%, #fff 8%) 0 4px;
        background: -o-linear-gradient(top, #d9eaf3 0%, #fff 8%) 0 4px;
        background: linear-gradient(top, #d9eaf3 0%, #fff 8%) 0 4px;
        -webkit-background-size: 100% 20px;
        -moz-background-size: 100% 20px;
        -ms-background-size: 100% 20px;
        -o-background-size: 100% 20px;
        background-size: 100% 20px;
        -webkit-border-radius: 3px;
        -moz-border-radius: 3px;
        border-radius: 3px;
        -webkit-box-shadow: 0 1px 2px rgba(0,0,0,0.07);
        -moz-box-shadow: 0 1px 2px rgba(0,0,0,0.07);
        box-shadow: 0 1px 2px rgba(0,0,0,0.07);
}
 
.paper::before {
        content: '';
        position: absolute;
        width: 4px;
        top: 0;
        left: 30px;
        bottom: 0;
        border: 1px solid;
        border-color: transparent #efe4e4;
}
 
textarea {
        display: block;
        width:94%;
        margin:0 auto;
        padding:3.8% 3%;
        border: none;
        outline: none;
        height: 94%;
        background: transparent;
        line-height: 20px;
}

</style>

<div class="paper" contenteditable style="font-size:2rem;line-height:1.4;max-width:60rem;margin:0 auto;padding:4rem;" spellcheck="false" autofocus></div>
----------------------------------

[foo.html 04-21-2023]:
<script src="https://cdnjs.cloudflare.com/ajax/libs/vue/2.5.16/vue.js"></script>

<div id="app">
  {{ categories }}
  <category-component
    v-for="(category, index) in categories"
    :key="index"
    v-model="categories[index]"
  />
</div>

<script>
  Vue.component("category-component", {
    template: `
          <div class="hello">
            <input type="text" v-model="innerTitle">
            <br>
            <textarea v-model="innerSummary"></textarea>
          </div>
        `,
    props: {
      value: {
        default: () => {
          return {};
        },
        type: Object,
      },
    },
    computed: {
      innerTitle: {
        get: function () {
          return this.value.title;
        },
        set: function (val) {
          this.$emit("input", { summary: this.value.summary, title: val });
        },
      },
      innerSummary: {
        get: function () {
          return this.value.summary;
        },
        set: function (val) {
          this.$emit("input", { title: this.value.title, summary: val });
        },
      },
    },
  });

  new Vue({
    el: "#app",
    data() {
      return {
        categories: [
          {
            title: "Cat 1",
            summary: "description",
          },
          {
            title: "Cat 2",
            summary: "description",
          },
          {
            title: "Cat 3",
            summary: "description",
          },
        ],
      };
    },
  });
</script>

This is super interesting.
We are not supposed to mutate the prop directly.
So instead, we do it through computed getters and setters.
It is a little bit trippy. 
But this is definitely the correct pattern.
----------------------------------

[Phi.pde 04-21-2023]:

float PHI = (1+sqrt(5))*0.5;
color BG = color(128);

float prevX = 125,
  prevY = 150,
  prevW = 150,
  prevH = prevW*(PHI-1);
int prevD = 0;
color prevC = color(128,128,128,64);
float prevAmp = 0.5;
// PSound zin, zout;

void setup() 
{
  size(400, 400);
  ellipseMode(RADIUS);
  background(BG);
  //zin = loadSound("bottle-open.wav");
  //zout = loadSound("whistle.wav");
  //framerate(10);
}

color perturb(color c, int d) {
  return color(red(c)+random(-d,d),green(c)+random(-d,d),
    blue(c)+random(-d,d),alpha(c));
}

void next() {
  if(random(2)<1) {
    //print("SHRINK"+prevD+"\n");
    if(prevD==0||prevD==2) {
      if(prevD==0)
        prevX += prevH;
      prevW = prevH*(PHI-1);
    }
    else {
      if(prevD==1)
        prevY += prevW;
      prevH = prevW*(PHI-1);
    }
    prevD++;
    if(prevD==4)
      prevD=0;
    prevAmp = constrain(prevAmp-0.1,0,1);
  }
  else {
    //print("GROW"+prevD+"\n");
    if(prevD==0||prevD==2) {
      if(prevD==2)
        prevY -= prevW;
       prevH = prevW*PHI;
    }
    else {
      if(prevD==1)
        prevX -= prevH;
      prevW = prevH*PHI;
    }
    prevD--;
    if(prevD==-1)
      prevD=3;
    prevAmp = constrain(prevAmp+0.1,0,1);
  }
}

void draw() 
{
  stroke(0);
  noFill();
  rect(prevX,prevY,prevW,prevH);
  next();
  if(prevW>width||prevH>height) {
    copy(0,0,width,height,width/4,height/4,width/2,height/2);
    noStroke();
    fill(BG);
    rect(0,0,width,height/4);
    rect(0,height/4,width/4,3*height/4);
    rect(3*width/4,height/4,width/4,3*height/4);
    rect(width/4,3*height/4,width/2,height/4);
    prevX=width/4+prevX*0.5;
    prevY=height/4+prevY*0.5;
    prevW*=0.5;
    prevH*=0.5;
    prevC = color(random(255),random(255),random(255),alpha(prevC));
    prevAmp = constrain(prevAmp-0.1,0,1);
  }
  else if(prevW<5||prevH<5) {
    copy(round(prevX-width/4),round(prevY-height/4),width/2,height/2,0,0,width,height);
    prevX=width/2;
    prevY=height/2;
    prevW*=2;
    prevH*=2;
    prevC = color(random(255),random(255),random(255),alpha(prevC));
    prevAmp = constrain(prevAmp+0.1,0,1);
  }
  else
    prevC = perturb(prevC, 20);
  //zout.stop();
  //zout.volume(max(prevW/width,prevH/height));
  //zout.play();
  noStroke();
  fill(prevC);
  rect(prevX,prevY,prevW,prevH);
  stroke(0);
  noFill();
  if(prevD==0)
    arc(prevX+prevH,prevY+prevH,prevH,prevH,PI,3*HALF_PI);
  else if(prevD==1)
    arc(prevX,prevY+prevW,prevW,prevW,3*HALF_PI,TWO_PI);
  else if(prevD==2)
    arc(prevX+prevW-prevH,prevY,prevH,prevH,0,HALF_PI);
  else if(prevD==3)
    arc(prevX+prevW,prevY+prevH-prevW,prevW,prevW,HALF_PI,PI);
  stroke(random(255),random(255),random(255));
  rect(prevX,prevY,prevW,prevH);
}


----------------------------------

function plotQuadraticBezier(a, b, c, w) {
  // Define the control points of the Bezier curve
  let P0 = [0, c];
  let P1 = [w/2, (a/4)*w**2 + (b/2)*w + c];
  let P2 = [w, a*w**2 + b*w + c];

  // Define the Bezier curve function
  function bezier(t) {
    return [
      (1-t)**2 * P0[0] + 2*(1-t)*t * P1[0] + t**2 * P2[0],
      (1-t)**2 * P0[1] + 2*(1-t)*t * P1[1] + t**2 * P2[1]
    ];
  }

  // Evaluate the Bezier curve at 100 points
  let t = new Array(100).fill(0).map((_, i) => i/99);
  let curve = t.map(bezier);

  // Plot the Bezier curve and the quadratic equation using Chart.js
  let ctx = document.getElementById('myChart').getContext('2d');
  let chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: new Array(100).fill(0).map((_, i) => i),
      datasets: [
        {
          label: 'Quadratic equation',
          data: new Array(100).fill(0).map((_, i) => a*i**2 + b*i + c),
          borderColor: 'red',
          fill: false
        },
        {
          label: 'Bezier curve',
          data: curve,
          borderColor: 'blue',
          fill: false
        }
      ]
    },
    options: {
      responsive: false,
      scales: {
        xAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'x'
          }
        }],
        yAxes: [{
          scaleLabel: {
            display: true,
            labelString: 'y'
          }
        }]
      }
    }
  });
}

[index.js 04-21-2023]:
async function init01() {
     console.log('nono')
     return 
    initializeApp(firebaseConfig)
    const db = getFirestore()
    const collectionKey = "books"
    const collectionRef = collection(db, collectionKey)
    const { docs } = await getDocs(collectionRef)
    const books = docs.map((doc, i) => {
        return {
            ...doc.data(),
            id: doc.id,
        }
    })
    let itemId = books[0].id
    console.log(JSON.stringify(books, null, 2))
    console.log("-------------------------------")
    console.log("sleeping")
    await sleep(1000)
    console.log("wake")
    const value = {
        title: "aaaa",
        author: "bbbb",
        date: "cccc",
    }
    let response
    response = await addDoc(collectionRef, value)
    console.log("adding doc")
    console.log(response)
    console.log("sleeping")
    await sleep(1000)
    console.log("-------------------------------")

    const docRef = doc(db, collectionKey, itemId)
    response = await deleteDoc(docRef)
    console.log("deleting doc")
    console.log(response)
    console.log("sleeping")
    await sleep(1000)
    console.log("-------------------------------")
    console.log("look at collection again")

    await getCollection(db, collectionKey)
}
----------------------------------

[index.js 04-21-2023]:
async function init() {
    /* works */
    const fs = new FireStore('books')
    fs.listen()
    fs.add(1423)
}
----------------------------------

[vimrc 04-22-2023]:
function! PuppetRunner()
    let file = Basename(CurrentFile())
    let dict = {
        \'app2.js': '!node app2.js',
        \'mc.js': '!node print.js',
        \'appscript.js': '!node app-main.js',
    \}
    if has_key(dict, file)
        execute dict[file]
        return 
    endif
    let line = CurrentLine()
    let arg = WindowMatch('kt: \zs\w+')
    if Exists(arg)
        return  Node('/home/kdog3682/CWF/public/puppet.js', CurrentFile(), arg)
    endif
    call Node('/home/kdog3682/CWF/public/puppet.js', CurrentFile())
endfunction
function! Node3Old()
    "Node3 is the eval js runner. You press the key and something happens.
    let file = CurrentFile()
    let name = Basename(file)

    let dict = {
        \'m.txt': 'print.js',
        \'class.js': 'print.js',
        \'mc.js': 'print.js',
        \'app.js': 'print.js',
        \'base.css': 'print.js',
    \}
    let cmd = has_key(dict, name) ? dict[name] : '/home/kdog3682/CWF/public/TextEditor.js ' . file
    execute "!clear;node " . cmd
endfunction


----------------------------------

[new.py 04-22-2023]:
# super(ff('~/', name='viminf[a-z].tmp'))
----------------------------------

[new.py 04-22-2023]:
def get_item_info(item):
    try:
        item_type = type(item).__name__
        item_length = len(item)
        item_constructor = item.__class__.__name__
        item_parent = item.__class__.__base__.__name__
        item_child_types = [
            child.__name__
            for child in item.__class__.__subclasses__()
        ]

        info = f"Type: {item_type}\nLength: {item_length}\nConstructor: {item_constructor}\nParent: {item_parent}\nChild Types: {item_child_types}"
        return info

    except Exception as e:
        return f"Error: {str(e)}"
----------------------------------

[fb.py 04-22-2023]:
def isCollection(x):
    return isObject(x) and x.get('type') == 'collection'

def isPureData(x):
    return x.get('type') == 'data'

def isPureData(x):
    return x.get('type') == 'data'

def create_firestore_from_json(db, data):
    # doesnt work
    def runner(data, parent):
        
        children = data.get('children')

        if isCollection(children): # Array of Documents
            name = data.get('name')
            collection = parent.collection(name)
            for child in children:
                runner(child, collection)

        elif isPureData(data):
            parent.document(data.get('value'))


    with db.batch() as batch:
        runner(db)

----------------------------------

[fb.py 04-22-2023]:
        {'name': 'add', 'args': 123},
        {'name': '__json__'},
        {'name': 'delete', 'args': 0},
        {'name': '__json__'},
        {'name': 'deleteAll'},
        {'name': '__json__'},
        {'name': '__json__'},
----------------------------------

[fb.py 04-22-2023]:
s = """
type document | collection | data
name str
value list

n books
t c
v
n harry
t d
v
    a = 1
    b = 1
    c = 1

n danny
t d
v
    d = 1
    e = 1
    f = 1

    n danny-sub-collection
    t c
    v
"""
----------------------------------

[index.js 04-23-2023]:
class Auth {
    constructor() {
        this.auth = getAuth();
        connectAuthEmulator(this.auth, 'http://localhost:3000')
    }
    async login(email, password) {
        try {
            this.userCredential = await signInAnonymously(this.auth)
            //this.userCredential = await createUserWithEmailAndPassword(this.auth, email, password)
            console.log({a: this.userCredential})
        } catch(e) {
            console.log("ERRORRRRRRRR", e.stack, e.toString())
        }
    }
}
init()
----------------------------------

[index.js 04-23-2023]:
async function init() {
    const vfs = new VueFireStore()


    vfs.login(...me())



    //const auth = new Auth()
    //await auth.login(...me)
    //return
    //vfs.authenticate()
    //vfs.setCollection(key)
    
    //const js = await vfs.getDocData('javascript', 'js1')
    //console.log({js})
    //try {
        //let a = eval('console.log(len(Object.keys(window)))')
        //console.log(a, 'hh')
        //javascript('console.log((Object.keys(window).length))')
        //javascript(_js())
        //eval(_js())
        //console.log((bop(), 'cccccccc'))
    //} catch(e) {
        //console.log("ERRORRRRRRRR", e.stack, 'STRING', e.toString())
    //}
    //console.log(html())
}
----------------------------------

[WindowStorage.js 04-24-2023]:
const ws = new WindowStorage('abcd')
const wsat = ws.module('accToken', {
    set: (k, v) => k + '###' + v,
    get: (s) => s.toString().split('###'),
})
wsat.set('a', 'b')
console.log(ws)
console.log(wsat.get())
----------------------------------

[loadResources.js 04-24-2023]:
//console.log(decodeURIComponent(encodeURIComponent('hello world')))
----------------------------------

[WindowStorage.js 04-24-2023]:
    module(key, {get, set, immediate = true} = {}) {
        const self = this
        const module = {
            get(k) {
                return get(self.get(key))
            },
            set(...args) {
                self.set(key, set(...args))
                if (immediate) {
                    self.upload()
                }
            }
        }
        return module
    }
----------------------------------

[fire.js 04-24-2023]:
var firebase = "00591a0b12301e025941593a32011a280238342f1a0c310814151615560f3618013a0c15421a21182117320b170c2b4f0d145957591a0e0f133f14161a1215594159131a16160256161a0f135618171a0808551d12091e191a081e1a0b0b551814165957590b0914111e180f321f594159131a16160256161a0f135618171a0808595759080f14091a1c1e390e18101e0f594159131a16160256161a0f135618171a0808551a0b0b080b140f55181416595759161e08081a1c12151c281e151f1e09321f594159484c48424c4e4a4a424d485957591a0b0b321f5941594a41484c48424c4e4a4a424d48410c1e1941434a42491f1d4d181f19194c4d4c494b184d4a1f191e595759161e1a080e091e161e150f321f5941593c563031214d214f2b3631385906"
----------------------------------

[fire.js 04-24-2023]:
const {
    getFirestore,
    doc,
    collection,
    getDocs,
    onSnapshot,

    addDoc,
    getDoc,
    updateDoc,
    deleteDoc,

    serverTimestamp,
    increment,

    where,
    limit,
    query,
    orderBy,
}
----------------------------------
#gpt

<svg width="200" height="200">
  <defs>
    <linearGradient id="myGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#F7F7F7" />
      <stop offset="20%" stop-color="#F2F2F2" />
      <stop offset="40%" stop-color="#EDEDED" />
      <stop offset="60%" stop-color="#E8E8E8" />
      <stop offset="80%" stop-color="#E3E3E3" />
      <stop offset="100%" stop-color="#F2F2F2" />
    </linearGradient>
  </defs>
  <rect x="0" y="0" width="200" height="200" fill="url(#myGradient)" />
</svg>

<svg width="200" height="200">
  <defs>
    <linearGradient id="myGradient" x1="0%" y1="0%" x2="100%" y2="100%">
      <stop offset="0%" stop-color="#F7F7F7" />
      <stop offset="20%" stop-color="#F2F2F2" />
      <stop offset="40%" stop-color="#EDEDED" />
      <stop offset="60%" stop-color="#E8E8E8" />
      <stop offset="80%" stop-color="#E3E3E3" />
      <stop offset="100%" stop-color="#DEDEDE" />
    </linearGradient>
  </defs>
  <line x1="0" y1="0" x2="200" y2="200" stroke="url(#myGradient)" stroke-width="5" />
</svg>

<svg width="200" height="200">
  <defs>
    <radialGradient id="myGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#E6B8B2" />
      <stop offset="20%" stop-color="#F8DBB7" />
      <stop offset="40%" stop-color="#F9F3B0" />
      <stop offset="60%" stop-color="#B7E3B3" />
      <stop offset="80%" stop-color="#A4C2C4" />
      <stop offset="100%" stop-color="#D4A4A4" />
    </radialGradient>
  </defs>
  <rect x="0" y="0" width="200" height="200" fill="url(#myGradient)" />
</svg>

<svg width="200" height="200">
  <defs>
    <radialGradient id="myGradient" cx="50%" cy="50%" r="50%" fx="50%" fy="50%">
      <stop offset="0%" stop-color="#E6B8B2" />
      <stop offset="20%" stop-color="#F8DBB7" />
      <stop offset="40%" stop-color="#F9F3B0" />
      <stop offset="60%" stop-color="#B7E3B3" />
      <stop offset="80%" stop-color="#A4C2C4" />
      <stop offset="100%" stop-color="#D4A4A4" />
    </radialGradient>
    <filter id="myFilter">
      <feGaussianBlur stdDeviation="5" />
    </filter>
  </defs>
  <rect x="0" y="0" width="200" height="200" fill="url(#myGradient)" filter="url(#myFilter)" />
</svg>


[fire.js 04-24-2023]:
class Robot {
    constructor() {
    }
    defineActionSequence() {
        
    }
}
class ChatRobot extends Robot {
    constructor() {
    }
}
----------------------------------

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>JS Bin</title>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet">
  <link rel="stylesheet"
          href="https://fonts.googleapis.com/css2?family=Cutive+Mono&family=Tangerine&family=Crimson+Pro&family=Noto+Emoji">
    <style>
      body {
        /* font-family: 'Crimson Pro', 'Tangerine', serif; */
        /* font-size: 48px; */
        /* font-weight: 800; */
      }
      .emoji {
        font-family: 'Cutive Mono';
      font-size: 24px;
        font-weight: 500;
        color: yellow;
        background: blue;
        padding: 10px;
      }
    </style>

</head>
<body>

    <div class="div">
   <p>hi howdy.</p>
    </div>
  <span class="emoji">
    hi how are you nihao niha你好
  </span>
</body>
</html>

#fontExample

[fire.js 04-24-2023]:
class ChatClient {
    constructor(vfc) {
        this.vfc = vfc
    }
    sendMessage() {
        
    }

    // Slack is a chat client
    // Messenger is a chat client
    // Whatsapp is a chat client
}
----------------------------------

[fb.py 04-24-2023]:
    old_actions = [
        {"name": "json"},
        {"name": "delete_everything"},
        {"name": "get_all_docs_v2"},
        {'name': 'add', 'args': 123},
        {'name': 'add', 'args': 123},
        {'name': 'add', 'args': 123},
        {"name": "get_all_docs"},     # gets as typed dict
    ]
----------------------------------

[cm.js 04-26-2023]:

const { Compartment } = CM["@codemirror/state"]
const { completeAnyWord } = CM["@codemirror/autocomplete"]
const { javascript, javascriptLanguage } =
    CM["@codemirror/lang-javascript"]
const { EditorState, EditorView, basicSetup } =
    CM["@codemirror/basic-setup"]

const { syntaxTree } = CM["@codemirror/language"]

const completePropertyAfter = ["PropertyName", ".", "?."]
const dontCompleteIn = [
    "TemplateString",
    "LineComment",
    "BlockComment",
    "VariableDefinition",
    "PropertyDefinition",
]

function completeFromGlob(context) {
    let nodeBefore = syntaxTree(context.state).resolveInner(
        context.pos,
        -1
    )

    if (
        completePropertyAfter.includes(nodeBefore.name) &&
        nodeBefore.parent?.name == "MemberExpression"
    ) {
        let object =
            nodeBefore.parent.getChild("Expression")
        if (object?.name == "VariableName") {
            let from = /\./.test(nodeBefore.name)
                ? nodeBefore.to
                : nodeBefore.from
            let variableName = context.state.sliceDoc(
                object.from,
                object.to
            )
            if (typeof window[variableName] == "object")
                return completeProperties(
                    from,
                    window[variableName]
                )
        }
    } else if (nodeBefore.name == "VariableName") {
        return completeProperties(nodeBefore.from, window)
    } else if (
        context.explicit &&
        !dontCompleteIn.includes(nodeBefore.name)
    ) {
        return completeProperties(context.pos, window)
    }
    return null
}

const globalJavaScriptCompletions =
    javascriptLanguage.data.of({
        autocomplete: completeAnyWord,
    })

function autoFocus(editor, delay = 750) {
    setTimeout(() => editor.focus(), delay)
}

function createEditor() {

    const BaseExtensions = [
        EditorView.inputHandler.of(cmInputHandler)
        //BaseTheme,
        handler,
        basicSetup,
        javascript(),
        globalJavaScriptCompletions,
    ]

    return EditorState.create({
        doc,
        extensions: BaseExtensions,
    })
    const parent = qs('codemirror')
    const editor = new EditorView({state, parent})
    autoFocus(editor)
    return editor
}


function cmCursor(cm) {
    return cm.state.selection.main.head
}

function cmText(cm) {
    return cm.state.doc.toString().trim()
}

function cmInsert(cm, text) {
    let c = cmCursor(cm)
    cm.dispatch({
        changes: {
            from: c,
            insert: text.toString(),
        },
        selection: {
            anchor: c + text.length,
        },
    })
}

function cmSet(cm, s) {
    cm.dispatch({
        changes: {
            from: 0,
            to: cm.state.doc.length,
            insert: s,
        },
    })
}

function cmClear(cm) {
    cmSet(cm, "")
}
function cmReplace(cm, s) {
    cm.dispatch(cm.state.replaceSelection(s))
}

function cmLine(cm) {
    return cm.state.doc.lineAt(cmCursor(cm)).text
}

function cmDispatch(cm, fn) {
    cm.dispatch({ effects: fn })
}

function cmLength(cm) {
    return cm.state.doc.lines
}
function cmLastLine(cm) {
    return cm.state.doc.lineAt(cmLength(cm)).text
}

function cmFirstLine(cm) {
    return cm.state.doc.lineAt(1).text
}

const EditorCommands = {
    set: cmSet,
    pretty: cmPretty,
    cursor: cmCursor,
    line: cmLine,
    text: cmText,
    indent: cmIndent,
    lineNumber: cmLineNumber,
    context: cmContext,
    empty: cmEmpty,
}

function cmEmpty(cm) {
    return cm.line.trim().length == 0
}
function cmContext(cm) {
    if (cm.indent == 0) return
    const cursor = cm.doc.iterLines(n - 1, 0)
    while (cursor.next()) {
        let i = getIndent(cursor.value)
        if (i == 0) {
            return getFirstWord(cursor.value)
        }
    }
}

function cmBlock(cm) {
    if (cm.indent == 0) return
    let n = cm.lineNumber
    const cursor = cm.doc.iterLines(n - 1, 0)
    while (cursor.next()) {
        let i = getIndent(cursor.value)
        if (i == 0) {
            return
        }
    }
}
function cmLineNumber(cm) {
    return cm.state.doc.lineAt(cmCursor(cm)).number
}

function cmIndent(cm) {
    return getIndent(cmLine(cm))
}

const EmptyDictionary = {
    "-": "-------------------------\n",
    r: "return ",
}
// can do some pretty radical things...

function cmWordSpiral(cm) {
    return
    const word = cmWordUnderCursor(cm)
    while (true) {
        break
    }
}
function cmInputHandler(cm, from, to, key) {
    if (cm.empty && EmptyDictionary.hasOwnProperty(key)) {
        cmReplace(cm, EmptyDictionary[key])
        return 1
    }
    if (key == "Tab") {
        console.log(from, to, key)
        if (cmWordSpiral(cm)) {
            return 1
        }
    }
}


const CodeMirrorComponent = {
    data() {
        return {
            displays: {
                codemirror: true,
                html: false,
            },
            html: '<div class="jsxgraph" id="jsxgraph"></div>',
            js: "",
        }
    },
    template: `
        <div class="app">
            <div class="codemirror-component" 
                v-show="displays.codemirror">
            </div>

            <div class="html-component"
                v-html="html"
                v-show="displays.html">
            </div>
        </div>
    `,
    mounted() {
        this.editor = createEditor()
        this.displayManager = new VueDisplayManager(
            this,
            VueDisplayCallbacks
        )
        this.keylistener = new KeyListener(
            this,
            VueCodemirrorCallbacks
        )

        this.editor.set("console.log(   foo)")
        this.editor.pretty()
        console.log(this.editor.text)
    },
}
const VueDisplayCallbacks = {
    html: {
        onEnter() {},
        onExit() {},
    },
    codemirror: {
        onEnter() {
            setTimeout(
                this.editor.requestMeasure.bind(
                    this.editor
                ),
                50
            )
            autoFocus(this.editor)
        },
        onExit() {
            this.editor.contentDOM.blur()
        },
    },
}

function cmGetSet(cm, fn) {
    setTimeout(() => cmSet(cm, fn(cmText(cm))), 250)
}

function cmPrettier(cm) {
    cmGetSet(cm, prettier)
}
----------------------------------

[cms.js 04-27-2023]:
function insert(from, insert) {
    view.dispatch({
        changes: {from, insert},
        select: {anchor: insert.length + from}
    })
    //view.dispatch(view.state.replaceSelection("★"))
}
function foo1682612501() {
    v.setSelection(0, 3)
    v.getSelectionText()
    view.dispatch(view.state.replaceSelection("★"))
}

function wrapSelectionsWithDash(view) {
    view.setSelection(0, 1, 2, 3)
    view.dispatch(
        view.state.changeByRange((range) => ({
            changes: [
                { from: range.from, insert: "_" },
                { from: range.to, insert: "_" },
            ],
            range: EditorSelection.range(
                range.from,
                range.to + 2
            ),
        }))
    )
    /* a b c d e --> _a_ _b_ c d e */
}


function startOfDocInsertion(s) {
    return {from: 0, insert: s + "\n"}
}
----------------------------------

[clip.js 04-27-2023]:
{
  "@codemirror/text": [
    "Line",
    "Text",
    "codePointAt",
    "codePointSize",
    "countColumn",
    "findClusterBreak",
    "findColumn",
    "fromCodePoint"
  ],
  "@codemirror/state": [
    "Annotation",
    "AnnotationType",
    "ChangeDesc",
    "ChangeSet",
    "CharCategory",
    "Compartment",
    "EditorSelection",
    "EditorState",
    "Facet",
    "MapMode",
    "Prec",
    "SelectionRange",
    "StateEffect",
    "StateEffectType",
    "StateField",
    "Transaction",
    "combineConfig",
    "Text"
  ],
  "@codemirror/rangeset": [
    "Range",
    "RangeSet",
    "RangeSetBuilder",
    "RangeValue"
  ],
  "@codemirror/view": [
    "BidiSpan",
    "BlockInfo",
    "BlockType",
    "Decoration",
    "Direction",
    "EditorView",
    "MatchDecorator",
    "PluginField",
    "PluginFieldProvider",
    "ViewPlugin",
    "ViewUpdate",
    "WidgetType",
    "__test",
    "drawSelection",
    "dropCursor",
    "highlightActiveLine",
    "highlightSpecialChars",
    "keymap",
    "logException",
    "placeholder",
    "runScopeHandlers",
    "scrollPastEnd",
    "Range"
  ],
  "@codemirror/language": [
    "IndentContext",
    "LRLanguage",
    "Language",
    "syntaxHighlighting",
    "LanguageDescription",
    "LanguageSupport",
    "ParseContext",
    "TreeIndentContext",
    "continuedIndent",
    "defineLanguageFacet",
    "delimitedIndent",
    "ensureSyntaxTree",
    "flatIndent",
    "foldInside",
    "foldNodeProp",
    "foldService",
    "foldable",
    "getIndentUnit",
    "getIndentation",
    "indentNodeProp",
    "indentOnInput",
    "indentService",
    "indentString",
    "indentUnit",
    "language",
    "languageDataProp",
    "syntaxParserRunning",
    "syntaxTree",
    "syntaxTreeAvailable"
  ],
  "@codemirror/commands": [
    "copyLineDown",
    "copyLineUp",
    "cursorCharBackward",
    "cursorCharForward",
    "cursorCharLeft",
    "cursorCharRight",
    "cursorDocEnd",
    "cursorDocStart",
    "cursorGroupBackward",
    "cursorGroupForward",
    "cursorGroupLeft",
    "cursorGroupRight",
    "cursorLineBoundaryBackward",
    "cursorLineBoundaryForward",
    "cursorLineDown",
    "cursorLineEnd",
    "cursorLineStart",
    "cursorLineUp",
    "cursorMatchingBracket",
    "cursorPageDown",
    "cursorPageUp",
    "cursorSubwordBackward",
    "cursorSubwordForward",
    "cursorSyntaxLeft",
    "cursorSyntaxRight",
    "defaultKeymap",
    "deleteCharBackward",
    "deleteCharForward",
    "deleteGroupBackward",
    "deleteGroupForward",
    "deleteLine",
    "deleteToLineEnd",
    "deleteToLineStart",
    "deleteTrailingWhitespace",
    "emacsStyleKeymap",
    "indentLess",
    "indentMore",
    "indentSelection",
    "indentWithTab",
    "insertBlankLine",
    "insertNewline",
    "insertNewlineAndIndent",
    "insertTab",
    "moveLineDown",
    "moveLineUp",
    "selectAll",
    "selectCharBackward",
    "selectCharForward",
    "selectCharLeft",
    "selectCharRight",
    "selectDocEnd",
    "selectDocStart",
    "selectGroupBackward",
    "selectGroupForward",
    "selectGroupLeft",
    "selectGroupRight",
    "selectLine",
    "selectLineBoundaryBackward",
    "selectLineBoundaryForward",
    "selectLineDown",
    "selectLineEnd",
    "selectLineStart",
    "selectLineUp",
    "selectMatchingBracket",
    "selectPageDown",
    "selectPageUp",
    "selectParentSyntax",
    "selectSubwordBackward",
    "selectSubwordForward",
    "selectSyntaxLeft",
    "selectSyntaxRight",
    "simplifySelection",
    "splitLine",
    "standardKeymap",
    "transposeChars"
  ],
  "@codemirror/panel": [
    "getPanel",
    "panels",
    "showPanel"
  ],
  "@codemirror/tooltip": [
    "closeHoverTooltips",
    "getTooltip",
    "hasHoverTooltips",
    "hoverTooltip",
    "repositionTooltips",
    "showTooltip",
    "tooltips"
  ],
  "@codemirror/history": [
    "history",
    "historyField",
    "historyKeymap",
    "invertedEffects",
    "isolateHistory",
    "redo",
    "redoDepth",
    "redoSelection",
    "undo",
    "undoDepth",
    "undoSelection"
  ],
  "@codemirror/gutter": [
    "GutterMarker",
    "gutter",
    "gutterLineClass",
    "gutters",
    "highlightActiveLineGutter",
    "lineNumberMarkers",
    "lineNumbers"
  ],
  "@codemirror/collab": [
    "collab",
    "getClientID",
    "getSyncedVersion",
    "receiveUpdates",
    "sendableUpdates"
  ],
  "@codemirror/fold": [
    "codeFolding",
    "foldAll",
    "foldCode",
    "foldEffect",
    "foldGutter",
    "foldKeymap",
    "foldedRanges",
    "unfoldAll",
    "unfoldCode",
    "unfoldEffect"
  ],
  "@codemirror/matchbrackets": [
    "bracketMatching",
    "matchBrackets"
  ],
  "@codemirror/closebrackets": [
    "closeBrackets",
    "closeBracketsKeymap",
    "deleteBracketPair",
    "insertBracket"
  ],
  "@codemirror/search": [
    "RegExpCursor",
    "SearchCursor",
    "SearchQuery",
    "closeSearchPanel",
    "findNext",
    "findPrevious",
    "getSearchQuery",
    "gotoLine",
    "highlightSelectionMatches",
    "openSearchPanel",
    "replaceAll",
    "replaceNext",
    "search",
    "searchConfig",
    "searchKeymap",
    "selectMatches",
    "selectNextOccurrence",
    "selectSelectionMatches",
    "setSearchQuery"
  ],
  "@codemirror/lint": [
    "closeLintPanel",
    "diagnosticCount",
    "forceLinting",
    "lintGutter",
    "lintKeymap",
    "linter",
    "nextDiagnostic",
    "openLintPanel",
    "setDiagnostics",
    "setDiagnosticsEffect"
  ],
  "@codemirror/highlight": [
    "HighlightStyle",
    "Tag",
    "classHighlightStyle",
    "defaultHighlightStyle",
    "highlightTree",
    "styleTags",
    "tags"
  ],
  "@codemirror/stream-parser": [
    "StreamLanguage",
    "StringStream"
  ],
  "@codemirror/autocomplete": [
    "CompletionContext",
    "acceptCompletion",
    "autocompletion",
    "clearSnippet",
    "closeCompletion",
    "completeAnyWord",
    "completeFromList",
    "completionKeymap",
    "completionStatus",
    "currentCompletions",
    "ifIn",
    "ifNotIn",
    "moveCompletionSelection",
    "nextSnippetField",
    "pickedCompletion",
    "prevSnippetField",
    "selectedCompletion",
    "snippet",
    "snippetCompletion",
    "snippetKeymap",
    "startCompletion"
  ],
  "@codemirror/comment": [
    "blockComment",
    "blockUncomment",
    "commentKeymap",
    "lineComment",
    "lineUncomment",
    "toggleBlockComment",
    "toggleComment",
    "toggleLineComment"
  ],
  "@codemirror/rectangular-selection": [
    "rectangularSelection"
  ],
  "@codemirror/basic-setup": [
    "basicSetup",
    "EditorView",
    "EditorState"
  ],
  "@codemirror/lang-javascript": [
    "esLint",
    "javascript",
    "javascriptLanguage",
    "jsxLanguage",
    "snippets",
    "tsxLanguage",
    "typescriptLanguage"
  ],
  "@codemirror/lang-java": [
    "java",
    "javaLanguage"
  ],
  "@codemirror/lang-json": [
    "json",
    "jsonLanguage",
    "jsonParseLinter"
  ],
  "@codemirror/lang-cpp": [
    "cpp",
    "cppLanguage"
  ],
  "@codemirror/lang-php": [
    "php",
    "phpLanguage"
  ],
  "@codemirror/lang-python": [
    "python",
    "pythonLanguage"
  ],
  "@codemirror/lang-css": [
    "css",
    "cssCompletion",
    "cssCompletionSource",
    "cssLanguage"
  ],
  "@codemirror/lang-html": [
    "autoCloseTags",
    "html",
    "htmlCompletion",
    "htmlCompletionSource",
    "htmlLanguage"
  ],
  "@codemirror/lang-sql": [
    "Cassandra",
    "MSSQL",
    "MariaSQL",
    "MySQL",
    "PLSQL",
    "PostgreSQL",
    "SQLDialect",
    "SQLite",
    "StandardSQL",
    "keywordCompletion",
    "schemaCompletion",
    "sql"
  ],
  "@codemirror/lang-rust": [
    "rust",
    "rustLanguage"
  ],
  "@codemirror/lang-xml": [
    "completeFromSchema",
    "xml",
    "xmlLanguage"
  ],
  "@codemirror/lang-markdown": [
    "commonmarkLanguage",
    "deleteMarkupBackward",
    "insertNewlineContinueMarkup",
    "markdown",
    "markdownKeymap",
    "markdownLanguage"
  ],
  "@codemirror/lang-lezer": [
    "lezer",
    "lezerLanguage"
  ],
  "@codemirror/lang-wast": [
    "wast",
    "wastLanguage"
  ],
  "@codemirror/theme-one-dark": [
    "oneDark",
    "oneDarkHighlightStyle",
    "oneDarkTheme"
  ],
  "@lezer/lr": [
    "ContextTracker",
    "ExternalTokenizer",
    "InputStream",
    "LRParser",
    "Stack"
  ],
  "@lezer/common": [
    "DefaultBufferLength",
    "MountedTree",
    "NodeProp",
    "NodeSet",
    "NodeType",
    "Parser",
    "Tree",
    "TreeBuffer",
    "TreeCursor",
    "TreeFragment",
    "parseMixed"
  ],
  "crelt": [
    "default"
  ]
}
----------------------------------

[uglify.js 04-27-2023]:
const options = {
    parse: {
        // parse options
    },
    compress: {
        // compress options
    },
    mangle: {
        toplevel: true
    },
    output: {
        //beautify: true,
    },
    sourceMap: {
        // source map options
    },
    nameCache: null, // or specify a name cache object
    toplevel: false,
    warnings: false,
}
----------------------------------

[variables.js 04-27-2023]:
const cmkeys665 = [
  "defaults",
  "optionHandlers",
  "defineInitHook",
  "defineOption",
  "Init",
  "helpers",
  "registerHelper",
  "registerGlobalHelper",
  "inputStyles",
  "defineMode",
  "defineMIME",
  "defineExtension",
  "defineDocExtension",
  "fromTextArea",
  "off",
  "on",
  "wheelEventPixels",
  "Doc",
  "splitLines",
  "countColumn",
  "findColumn",
  "isWordChar",
  "Pass",
  "signal",
  "Line",
  "changeEnd",
  "scrollbarModel",
  "Pos",
  "cmpPos",
  "modes",
  "mimeModes",
  "resolveMode",
  "getMode",
  "modeExtensions",
  "extendMode",
  "copyState",
  "startState",
  "innerMode",
  "commands",
  "keyMap",
  "keyName",
  "isModifierKey",
  "lookupKey",
  "normalizeKeyMap",
  "StringStream",
  "SharedTextMarker",
  "TextMarker",
  "LineWidget",
  "e_preventDefault",
  "e_stopPropagation",
  "e_stop",
  "addClass",
  "contains",
  "rmClass",
  "keyNames",
  "version"
]
----------------------------------

[variables.js 04-27-2023]:
const cmKeys = [
  "@codemirror/text",
  "@codemirror/state",
  "@codemirror/rangeset",
  "@codemirror/view",
  "@codemirror/language",
  "@codemirror/commands",
  "@codemirror/panel",
  "@codemirror/tooltip",
  "@codemirror/history",
  "@codemirror/gutter",
  "@codemirror/collab",
  "@codemirror/fold",
  "@codemirror/matchbrackets",
  "@codemirror/closebrackets",
  "@codemirror/search",
  "@codemirror/lint",
  "@codemirror/highlight",
  "@codemirror/stream-parser",
  "@codemirror/autocomplete",
  "@codemirror/comment",
  "@codemirror/rectangular-selection",
  "@codemirror/basic-setup",
  "@codemirror/lang-javascript",
  "@codemirror/lang-java",
  "@codemirror/lang-json",
  "@codemirror/lang-cpp",
  "@codemirror/lang-php",
  "@codemirror/lang-python",
  "@codemirror/lang-css",
  "@codemirror/lang-html",
  "@codemirror/lang-sql",
  "@codemirror/lang-rust",
  "@codemirror/lang-xml",
  "@codemirror/lang-markdown",
  "@codemirror/lang-lezer",
  "@codemirror/lang-wast",
  "@codemirror/theme-one-dark",
  "@lezer/lr",
  "@lezer/common",
  "crelt"
]
----------------------------------

[yaml.js 04-27-2023]:
let jsonGrammar = `
@top JsonText { value }

value { True | False | Null | Number | String | Object | Array }

String { string }
Object { "{" list<Property>? "}" }
Array  { "[" list<value>? "]" }

Property { PropertyName ":" value }
PropertyName { string }


@tokens {
  True  { "true" }
  False { "false" }
  Null  { "null" }

  Number { '-'? int frac? exp?  }
  int  { '0' | $[1-9] std.digit* }
  frac { '.' std.digit+ }
  exp  { $[eE] $[+\-]? std.digit+ }

  string { '"' char* '"' }
  char { $[\\u{20}\\u{21}\\u{23}-\\u{5b}\\u{5d}-\\u{10ffff}] | "\\\\" esc }
  esc  { $["\\\\\\/bfnrt] | "u" hex hex hex hex }
  hex  { $[0-9a-fA-F] }

  whitespace { $[ \\n\\r\\t] }

  "{" "}" "[" "]"
}

@skip { whitespace }
list<item> { item ("," item)* }

@external propSource jsonHighlighting from "./highlight"

@detectDelim
`
let jsonSample = `
    //{"a":{"b":{"c":{"d": 1}}}}

    [1,2,3]

`
let yamlSample = `
    
name: Trigger CI
on: push

`

let yamlGrammar = `

@top Document { document }

@skip { space | newlineEmpty | Comment }

document { DocStart newline property* DocEnd }

property { Key value newline }

value { scalar | MultiLine | Mapping | Sequence }

scalar { Boolean | Null | Number | String }
String { plain | string }

MultiLine {
  (quote lineSkip newline multiline quote) |
  (FoldOp newline multiline)
}

@skip { newlineEmpty } {
  multiline { indent (lineSkip newline)+ dedent }
}

Mapping { "{" commaSep<scalar>? "}" }

Sequence { "[" commaSep<scalar>? "]" }

Boolean { @specialize<plain, "true" | "false" > }
Null { @specialize<plain, "null" | "~" > }

@context trackIndent from "./tokens.js"

@external tokens indentation from "./tokens" { indent, dedent }

@tokens {
  DocStart { "---" }
  DocEnd { "..." }
  colon { ": " }
  FoldOp { $[|>] $[+\\-]? }

  Key { keyChar (std.digit | keyChar)* space? colon }
  keyChar { std.asciiLetter | "_" }

  Number { "-"? (int | int? frac) exp? }
  int { "0" | $[1-9] std.digit* }
  frac { "." (std.digit+ | "nan" | "inf") }
  exp { $[eE] $[+\\-]? std.digit+ }

  string { quote line quote }
  plain { ![{}[\\]&*#?|\\-<>=!%@:" \\t\\f] line }
  lineSkip { (!["\\n\\r] | "\\\\" _)+ }
  line { (![#"\\n\\r] | "\\" _)+ }

  quote { '"' }
  Comment { "#" ![\\n\\r]* }
  space { ($[ \\t\\f] | "\\\\" $[\\n\\r])+ }

  "{" "}" "[" "]"

  @precedence { Number, plain }
  @precedence { lineSkip, space }
  @precedence { lineSkip, Comment }
}

commaSep<expr> { expr ("," expr)* }

@external tokens newlines from "./tokens" { newline, newlineEmpty }

@external propSource yamlHighlighting from "./highlight"

@detectDelim
`



function render(tree) {
  let lists = ''
  tree.iterate({
    enter({type, from, to}) {
      lists += `<ul><li>${type.name} (${from}→${to})</li>`
    },
    leave() {
      lists += '</ul>'
    }
  })
  return lists
}

let jsonResult = `

<ul>
  <li>JsonText (0→14)</li>
  <ul>
    <li>Array (5→12)</li>
    <ul>
      <li>[ (5→6)</li>
    </ul>
    <ul>
      <li>Number (6→7)</li>
    </ul>
    <ul>
      <li>Number (8→9)</li>
    </ul>
    <ul>
      <li>Number (10→11)</li>
    </ul>
    <ul>
      <li>] (11→12)</li>
    </ul>
  </ul>
</ul>


`



//import { removeComments } from "./utils.js"
//import { pretty } from "./Prettier.js"
import { writeUnitTest, read, clip, appendVariable, write, rpw, isFile, sysget, } from "./node-utils.js"
//import {buildParser, buildParserFile} from "@lezer/generator"
//const parser = buildParser(yamlGrammar)
//const parser = buildParser(jsonGrammar)
//const tree = parser.parse(removeComments(yamlSample))
//console.log((render(tree)))
//buildParserFile(read('yaml.grammar'), {
    //fileName: ''
//})

import {
    parser as yamlParser
} from "./lang.js"
clip(render(yamlParser.parse(yamlSample)))


----------------------------------

[StateContext2.js 04-29-2023]:
function foo1682779730() {
    const a = new StateContext()
    a.add('hi')
    a.add('hi')
    a.add('hi')
    let b = a.enter('bye')
    b.add('ccc')
    b.add('ccc')
    b.add('ccc')
    let c = b.exitAndEnter()
    c.add('aa')
    c.add('aa')
    c.add('aa')
    console.log(a.toString())
}
----------------------------------

[today.js 04-29-2023]:
class MathPlane {
    color(color) {
        this._color = color || "black"
    }
    get height() {
        return this.pos.y + 10
    }
    normalizeCoordinates() {
        const offsetY = Math.max(
            ...this.coordinates.map(([b, [x, y]]) => y)
        )

        let lastX = 0
        let lastY = 0
        this.coordinates = this.coordinates.map(([v, [x, y], color], i) => {
                let gapX = 10
                let gapY = 10
                gapX = 0
                gapY = 0
                const normalizedY = Math.abs(y - offsetY)
                if (normalizedY == lastY) {
                    /* do something */
                } else {
                    //gapY
                }
                lastY = normalizedY
                return [
                    v,
                    [
                        gapX + x * this._kfactor,
                        gapY + normalizedY * this._kfactor,
                    ],
                    color,
                ]
            }
        )
    }

    constructor() {
        this.matrix = new Matrix()
        this._kfactor = 50
        this._color = "black"
        this.pos = new PositionTracker()
        this.coordinates = []
        this.calculateLength = len
    }
    get value() {
        return this.coordinates
        return this.coordinates.map(([a, b]) => {
            return { value: a, pos: b }
        })
    }

    add(a, b, c, color) {
        if (a == null) return
        if (b == null && c == null) {
            this.coordinates.push([
                a,
                this.pos.value,
                color,
            ])
            this.pos.increment(this.calculateLength(a))
        } else {
            let pos = [b, c]
            if (color == null) color = this._color
            this.coordinates.push([a, pos, color])
        }
    }
    addMultiple(answers, x, y, color) {
        answers = isArray(answers)
            ? answers
            : split(answers)
        for (let i = 0; i < answers.length; i++) {
            let answer = answers[i]
            this.add(answer, x + i, y, color)
        }
    }
}
----------------------------------

[LineEdit2.js 04-29-2023]:
            //const parent = this.context.data.value || ''
            //const appendAfter = parent.startsWith('@')
            //if (appendAfter) {
                //console.log('appendAfter starting with', parent)
            //}
----------------------------------

[compileRE.js 04-29-2023]:
async function fa(x) {
    const jsCompiler = compileREFactory(javascriptRef)

    const collectingSnippetsRE = jsCompiler('collectingSnippetsRE', 'gm')
    const nameRE = jsCompiler('nameRE')

    const matches = findall(collectingSnippetsRE, textGetter(x))
    const tally = new Tally(matches)
    const items = tally.filter((x) => x > 1).toJSON()
    const mappedItems = items.map(async (item, i) => {
        const name = search(nameRE, item)
        const [a, b] = [name, item]
        const template = `let g:pydict["${a}"] = "${b}"`
        return template
    })
    //console.log(mappedItems); assert();
    append('/home/kdog3682/.vimrc', mappedItems)
    fa('utils.js')
}
----------------------------------

[LineEdit2.js 04-29-2023]:
function postParse1(x) {
    x.iterate((node) => {
        const value = node.data.value
        const payload = gatherData(value)
        if (payload) {
            node.data = payload
        }
    })
    return x
}
----------------------------------

[StateContext2.js 04-29-2023]:
function foo1682779730() {
    const a = new StateContext2()
    a.appendChild('hi')
    a.appendChild('hi')
    a.appendChild('hi')
    let b = a.enter('bye')
    b.appendChild('ccc')
    b.appendChild('ccc')
    b.appendChild('ccc')
    let c = b.exit().appendChild('')
    c.appendChild('aa')
    c.appendChild('aa')
    c.appendChild('aa')
    console.log(a.toString())
}
//console.log(foo1682779730())
----------------------------------

[LineEdit2.js 04-30-2023]:
function postParse2(state) {

    /* 
     * Recursive functions are very trippy.
     * The lookaheads are very strange.
     * */

    const children = state.children.map(postParse)
    const isLeaf = empty(children)
    const value = state.data.value
    const payload = gatherData(value, state) || {}

    if (payload.style) {
        if (!state.parent.data.style) {
            state.parent.data.style = {}
        }
        Object.assign(state.parent.data.style, payload.style)
        return 
    }

    if (payload.introducerTag) {
        state.data.tag = 'introducer-container'
        state.data.children = [
            {
                tag: payload.introducerTag,
                value: payload.value
            },
            {
                tag: 'items',
                children: children
            }
        ]
    }

    else if (false) {
        /* this will never happen */
        /* because a false statement can never be true */
        /* this block can never be entered */
    }

    else {
        state.data.children = children
    }
    return state.data
}

console.logg(demo(s1, o1))
/* @bookmark 1682807662 foo */
/* @bookmark 1682813620 import contextParsers */
//import contextParsers from "./contextParsers.js"
----------------------------------

[LineEdit2.js 04-30-2023]:
const o1 = {
    parser(s, spaces, context) {
        let block = this.getBlock(s, spaces)
        let value = block || s
        return { value }
        /* this value gets appended to the main stream */
    },
    config: {
        tabWidth: 2,
    },
    __preparse__: smartDedent,
    __postparse__: postParse,
}
----------------------------------

[github.temp.js 04-30-2023]:
function toFrac(r) {
    let a = 1,
        b = 0

    for (let i = r.length - 1; i >= 0; i--) {
        let c = r[i],
            d = a

        a = a * c + b
        b = d
    }

    return [a, b]
}
----------------------------------

[github.temp.js 04-30-2023]:
function toContFrac(a, b) {
    /* source: https://codepen.io/rookie1024/pen/eJqqod */

    let r = []

    while (a && b) {
        let c = Math.floor(a / b)

        r.push(c)

        c = a - b * c
        a = b
        b = c
    }

    return r
}
console.log(toContFrac(83, 34))
console.log(toFrac(toContFrac(83, 34)))
----------------------------------

[clip.js 05-02-2023]:
[
    "@codemirror/view",
    "@codemirror/lang-json",
    "@codemirror/theme-one-dark",
    "@codemirror/lang-javascript",
    "@codemirror/lang-python",
    "@codemirror/matchbrackets",
    "@codemirror/state",
    "@codemirror/search",
    "@codemirror/lang-html",
    "@codemirror/lang-markdown",
    "@codemirror/autocomplete",
    "@codemirror/lang-css",
    "@codemirror/language"
]
----------------------------------

[clip.js 05-02-2023]:
{
  "view": [
    "BidiSpan",
    "BlockInfo",
    "BlockType",
    "Decoration",
    "Direction",
    "EditorView",
    "GutterMarker",
    "MatchDecorator",
    "RectangleMarker",
    "ViewPlugin",
    "ViewUpdate",
    "WidgetType",
    "__test",
    "closeHoverTooltips",
    "crosshairCursor",
    "drawSelection",
    "dropCursor",
    "getPanel",
    "getTooltip",
    "gutter",
    "gutterLineClass",
    "gutters",
    "hasHoverTooltips",
    "highlightActiveLine",
    "highlightActiveLineGutter",
    "highlightSpecialChars",
    "highlightTrailingWhitespace",
    "highlightWhitespace",
    "hoverTooltip",
    "keymap",
    "layer",
    "lineNumberMarkers",
    "lineNumbers",
    "logException",
    "panels",
    "placeholder",
    "rectangularSelection",
    "repositionTooltips",
    "runScopeHandlers",
    "scrollPastEnd",
    "showPanel",
    "showTooltip",
    "tooltips"
  ],
  "langJson": ["json", "jsonLanguage", "jsonParseLinter"],
  "themeOneDark": ["color", "oneDark", "oneDarkHighlightStyle", "oneDarkTheme"],
  "langJavascript": [
    "autoCloseTags",
    "completionPath",
    "esLint",
    "javascript",
    "javascriptLanguage",
    "jsxLanguage",
    "localCompletionSource",
    "scopeCompletionSource",
    "snippets",
    "tsxLanguage",
    "typescriptLanguage"
  ],
  "langPython": [
    "globalCompletion",
    "localCompletionSource",
    "python",
    "pythonLanguage"
  ],
  "matchbrackets": ["bracketMatching", "matchBrackets"],
  "state": [
    "Annotation",
    "AnnotationType",
    "ChangeDesc",
    "ChangeSet",
    "CharCategory",
    "Compartment",
    "EditorSelection",
    "EditorState",
    "Facet",
    "Line",
    "MapMode",
    "Prec",
    "Range",
    "RangeSet",
    "RangeSetBuilder",
    "RangeValue",
    "SelectionRange",
    "StateEffect",
    "StateEffectType",
    "StateField",
    "Text",
    "Transaction",
    "codePointAt",
    "codePointSize",
    "combineConfig",
    "countColumn",
    "findClusterBreak",
    "findColumn",
    "fromCodePoint"
  ],
  "search": [
    "RegExpCursor",
    "SearchCursor",
    "SearchQuery",
    "closeSearchPanel",
    "findNext",
    "findPrevious",
    "getSearchQuery",
    "gotoLine",
    "highlightSelectionMatches",
    "openSearchPanel",
    "replaceAll",
    "replaceNext",
    "search",
    "searchKeymap",
    "searchPanelOpen",
    "selectMatches",
    "selectNextOccurrence",
    "selectSelectionMatches",
    "setSearchQuery"
  ],
  "langHtml": [
    "autoCloseTags",
    "html",
    "htmlCompletionSource",
    "htmlCompletionSourceWith",
    "htmlLanguage",
    "htmlPlain"
  ],
  "langMarkdown": [
    "commonmarkLanguage",
    "deleteMarkupBackward",
    "insertNewlineContinueMarkup",
    "markdown",
    "markdownKeymap",
    "markdownLanguage"
  ],
  "autocomplete": [
    "CompletionContext",
    "acceptCompletion",
    "autocompletion",
    "clearSnippet",
    "closeBrackets",
    "closeBracketsKeymap",
    "closeCompletion",
    "completeAnyWord",
    "completeFromList",
    "completionKeymap",
    "completionStatus",
    "currentCompletions",
    "deleteBracketPair",
    "ifIn",
    "ifNotIn",
    "insertBracket",
    "insertCompletionText",
    "moveCompletionSelection",
    "nextSnippetField",
    "pickedCompletion",
    "prevSnippetField",
    "selectedCompletion",
    "selectedCompletionIndex",
    "setSelectedCompletion",
    "snippet",
    "snippetCompletion",
    "snippetKeymap",
    "startCompletion"
  ],
  "langCss": [
    "css",
    "cssCompletionSource",
    "cssLanguage",
    "defineCSSCompletionSource"
  ],
  "language": [
    "HighlightStyle",
    "IndentContext",
    "LRLanguage",
    "Language",
    "LanguageDescription",
    "LanguageSupport",
    "ParseContext",
    "StreamLanguage",
    "StringStream",
    "TreeIndentContext",
    "bracketMatching",
    "bracketMatchingHandle",
    "codeFolding",
    "continuedIndent",
    "defaultHighlightStyle",
    "defineLanguageFacet",
    "delimitedIndent",
    "ensureSyntaxTree",
    "flatIndent",
    "foldAll",
    "foldCode",
    "foldEffect",
    "foldGutter",
    "foldInside",
    "foldKeymap",
    "foldNodeProp",
    "foldService",
    "foldState",
    "foldable",
    "foldedRanges",
    "forceParsing",
    "getIndentUnit",
    "getIndentation",
    "highlightingFor",
    "indentNodeProp",
    "indentOnInput",
    "indentRange",
    "indentService",
    "indentString",
    "indentUnit",
    "language",
    "languageDataProp",
    "matchBrackets",
    "sublanguageProp",
    "syntaxHighlighting",
    "syntaxParserRunning",
    "syntaxTree",
    "syntaxTreeAvailable",
    "toggleFold",
    "unfoldAll",
    "unfoldCode",
    "unfoldEffect"
  ]
}
----------------------------------

[clip.js 05-02-2023]:
{
  "view": [
    "EditorView",
    "keymap"
  ],
  "langJavascript": [
    "javascript",
    "snippets",
  ],
  "langPython": [
    "globalCompletion",
    "localCompletionSource",
    "python",
    "pythonLanguage"
  ],
  "state": [
    "Compartment",
    "EditorSelection",
    "EditorState",
    "Facet",
    "Line",
    "Prec",
    "SelectionRange",
    "StateEffect",
    "StateField",
    "Text",
  ],
  "langHtml": [
    "html",
  ],
  "langMarkdown": [
    "commonmarkLanguage",
    "deleteMarkupBackward",
    "insertNewlineContinueMarkup",
    "markdown",
    "markdownKeymap",
    "markdownLanguage"
  ],
  "langCss": [
    "css",
  ],
  "language": [
    "HighlightStyle",
    "IndentContext",
    "LRLanguage",
    "Language",
    "LanguageSupport",
    "indentNodeProp",
    "indentOnInput",
    "indentRange",
    "indentService",
    "indentString",
    "indentUnit",
    "language",
    "syntaxHighlighting",
    "syntaxTree",
    "syntaxTreeAvailable",
    "toggleFold",
  ],

  "autocomplete": [
    "CompletionContext",
    "acceptCompletion",
    "autocompletion",
    "clearSnippet",
    "closeBrackets",
    "closeBracketsKeymap",
    "closeCompletion",
    "completeAnyWord",
    "completeFromList",
    "completionKeymap",
    "completionStatus",
    "currentCompletions",
    "deleteBracketPair",
    "ifIn",
    "ifNotIn",
    "insertBracket",
    "insertCompletionText",
    "moveCompletionSelection",
    "nextSnippetField",
    "pickedCompletion",
    "prevSnippetField",
    "selectedCompletion",
    "selectedCompletionIndex",
    "setSelectedCompletion",
    "snippet",
    "snippetCompletion",
    "snippetKeymap",
    "startCompletion"
  ]
}
----------------------------------

[cm.esm.js 05-02-2023]:
const CM = {};
CM["view"] = view
CM["langJson"] = langJson
CM["themeOneDark"] = themeOneDark
CM["langJavascript"] = langJavascript
CM["langPython"] = langPython
CM["state"] = state
CM["search"] = search$1
CM["langHtml"] = langHtml
CM["langMarkdown"] = langMarkdown
CM["autocomplete"] = autocomplete
CM["langCss"] = langCss
CM["language"] = language$2

export default CM
export {
    Annotation,
    ChangeSet,
    ChangeDesc,
    CharCategory,
    Compartment,
    CompletionContext,
    Direction,
    EditorSelection,
    EditorView,
    EditorState,
    Facet,
    HighlightStyle,
    IndentContext,
    Line,
    LRLanguage,
    Language,
    LanguageSupport,
    NodeProp,
    Prec,
    StateField,
    StateEffect,
    SelectionRange,
    Transaction,
    Text,
    acceptCompletion,
    autocompletion,
    combineConfig,
    countColumn,
    commonmarkLanguage,
    css,
    clearSnippet,
    closeBrackets,
    closeBracketsKeymap,
    closeCompletion,
    completeAnyWord,
    completeFromList,
    completionKeymap,
    completionStatus,
    currentCompletions,
    deleteMarkupBackward,
    deleteBracketPair,
    findClusterBreak,
    getIndentation,
    getIndentUnit,
    globalCompletion,
    html,
    indentString,
    indentUnit,
    insertNewlineContinueMarkup,
    indentNodeProp,
    indentOnInput,
    indentRange,
    indentService,
    ifIn,
    ifNotIn,
    insertBracket,
    insertCompletionText,
    javascript,
    keymap,
    localCompletionSource,
    matchBrackets,
    markdown,
    markdownKeymap,
    markdownLanguage,
    moveCompletionSelection,
    nextSnippetField,
    python,
    pythonLanguage,
    pickedCompletion,
    prevSnippetField,
    syntaxTree,
    snippets,
    syntaxHighlighting,
    syntaxTreeAvailable,
    selectedCompletion,
    selectedCompletionIndex,
    setSelectedCompletion,
    snippet,
    snippetCompletion,
    snippetKeymap,
    startCompletion,
    toggleFold
}
----------------------------------

[cm.js 05-02-2023]:
function abc(x) {
    function runner(x) {
        if (isObject(x)) {
            return Object.entries(x).map(([k,v], i) => {
                return [k, runner(v)]
            })
        }
        else if (isFunction(x)) {
            return x.name
        }
    }
    return runner(x)
}
----------------------------------

[cm.js 05-02-2023]:
class CodeEditor {
    constructor(parent) {
        
        this.buffers = new IndexedCache()
        this.ws = new WindowStorage('CodeMirror')

        const wsValue = this.ws.toJSON()
        const serializedStates = this.ws.buffers || [indexjs()]

        sortByIndex(serializedStates)
        serializedStates.map((state) => {
           this.createBuffer(state.name, state.data)
        })

        const state = this.buffers.get(0)
        this.cm = new EditorView({state, parent})
        this._mixin(codemirrorFunctions)

    }

    createBuffer(buffer, data) {
        const extensions = this._get_extensions(buffer)
        const selection = this._get_selection()
        const doc = data.text || ''

        const state = EditorState.create({
            doc,
            extensions,
            selection, 
        })

        this.buffers.set(buffer, state)
        return state
    }
    
    openBuffer(buffer) {
        const state = this.cm.state.toJSON()
        this.buffers.set(this.currentBuffer, state)
        this.cm.setState(this.getBuffer(buffer))
        this.currentBuffer = buffer
    }
    getBuffer(buffer) {
        const fallback = (buffer) => {
            return this.createBuffer(buffer, null)
        }
        return this.buffers.get(buffer, fallback)
    }

    /*---------------------------------*/
    /*----- Privates ------------------*/
    /*---------------------------------*/

    _get_selection(text) {
        
        const selection = exists(text) ?
            {anchor: text.length} : null
            //EditorSelection.single(0)

        return selection
    }

    _get_extensions(buffer) {
        const e = getExtension(buffer)
        //const extensions = this.baseExtensions
        return [
            //vim(),
            basicSetup,
        ]
    }

    _mixin(codemirrorFunctions) {
        map(codemirrorFunctions, (k, v) => {
            if (k.startsWith('cm')) {
                const f = (_, x) => x.toLowerCase()
                const method = k.replace(/^cm(\w)/, f)
                this[method] = curry2(this.cm, v)
            }
        })
    }

    _change_theme(newTheme) {
        this.cm.dispatch({
            effects: this.themeConfig.reconfigure([newTheme])
        })
    }
}
----------------------------------

[today.js 05-03-2023]:
function classToClasses(x) {
    if (x.hasOwnProperty('class')) {
        if (x.classes) {
            x.classes.push(x.class)
        } else {
            x.classes = [x.class]
        }
        delete x.class
    }
}
----------------------------------

[today.js 05-03-2023]:
function setClipboard1(s) {
    return navigator.clipboard.writeText(s)
}

/* @bookmark 1681583276 DomTree */

/* @bookmark 1681582283 DomElement */

/*******************************
 * 04-15-2023 documentation:
 * visual.mkpy is pretty cool
 * using vim for github ... doesnt work well.
 * to create repo remotely, need to first use githubscript.py
 * created a lot of second versions of util functions in today.js (insert, remove, indexGetter)
 * push2 was not created because it was already created
 * insert does not presently have the ability to create new elements.
 * Current Files:
 * today.js | elementObjects.js (should maybe merge with htmlBuilder.js)
 *
 *******************************/
----------------------------------

[cm.js 05-04-2023]:
function createTheme(s) {
    /* a reactive element */
    const styles = {}
    return EditorView.baseTheme(styles)
}

function createPanelFactory(dom, fn) {

    return function wordCountPanel(cm) {
      fn(dom, cm)
      return {
        dom,
        update(update) {
          if (update.docChanged) {
            fn(dom, update)
          }
        }
      }
    }
}

const helpTheme = EditorView.baseTheme({
  ".cm-help-panel": {
    padding: "5px 10px",
    backgroundColor: "#fffa8f",
    fontFamily: "monospace"
  }
})

export function helpPanel() {
  return [helpPanelState, keymap.of(helpKeymap), helpTheme]
}


function countWords(doc) {
  let count = 0
  let iter = doc.iter()

  while (!iter.next().done) {
    let inWord = false
    for (let i = 0; i < iter.value.length; i++) {
      let word = /\w/.test(iter.value[i])
      if (word && !inWord) count++
      inWord = word
    }
  }
  return count
}


const toggleHelp = StateEffect.define()

const helpPanelState = StateField.define({
  create: () => false,
  update(value, tr) {
    for (let e of tr.effects) {
        if (e.is(toggleHelp)) {
            value = e.value
        }
    }
    return value
  },
  provide: f => showPanel.from(f, on => on ? createHelpPanel : null)
})
----------------------------------

[hammy.js 05-06-2023]:
async function generateText(prompt, maxTokens, apiKey) {
    if (!maxTokens) maxTokens = 1024
  const url = 'https://api.openai.com/v1/completions'
  const response = await fetch(url, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      prompt,
      model: "text-davinci-003",
      max_tokens: maxTokens,
      n: 1,
      stop: '\n',
      temperature: 0.5,
      stream: true,
    })
  });

  const data = await response.json()
  console.log(data)
  return data.choices[0].text.trim()
}
----------------------------------

[utils.js 05-07-2023]:
# Teaching
async function promiseAllExample1() {
    const items = [1,2,3]
    const store = []
    for (let item of items) {
        await sleep(100)
        store.push(item)
    }
    console.log(store)
    return store
}
async function promiseAllExample2A() {
    const items = [1,2,3]
    const store = items.map(async (item, i) => {
        await sleep(100)
        return item
    })
    console.log(store)
    return store
    /* doesnt work */
}

async function promiseAllExample2B() {
    const items = [1,2,3]
    const promises = items.map(async (item, i) => {
        await sleep(100)
        return item
    })
    const store = await Promise.all(promises)
    console.log(store)
    return store
}

async function promiseAllExample3A() {
    const items = [1,2,3]
    const store = items.reduce(async (acc, item) => {
        await sleep(100)
        acc[item] = item
        return acc
    }, {})

    return store
    /* doesnt work */
}

async function promiseAllExample3B() {
    const items = [1,2,3]
    const promises = items.reduce(async (acc, item) => {
        await sleep(100)
        acc[item] = item
        return acc
    }, {})

    const store = await Promise.all(promises)
    /* doesnt work */
}

async function promiseAllExample3C() {
    const items = [1,2,3]
    const promises = items.reduce(async (acc, item) => {
        await sleep(100)
        acc = await acc
        acc[item] = item
        return acc
    }, Promise.resolve({}))

    console.log(await promises)
}
promiseAllExample3C()
----------------------------------

[parse.config.js 05-08-2023]:
function f(data) {
    //outpath: "css-data.cleaned.json"
    const ignore = [
        "normal",
        "auto",
        "none",
    ]
    return data.properties.map((property) => {
        let {name, status, values, restrictions} = property

    const experimentalStatuses = [
        "nonstandard",
        "experimental",
    ]

        if (experimentalStatuses.includes(status)) {
            return 
        }
        if (/^-ms|^-o-|^-webkit|\w+-\w+-\w+-/.test(name)) {
            return null
        }
        if (!restrictions) restrictions = []

        if (values) values = values.map((value) => {
            return value.name
        }).filter((x) => {
            return !ignore.includes(x)
        })

        const rl = restrictions.includes('length')
        const rp = restrictions.includes('percentage')
        const rc = restrictions.includes('color')
        const rn = restrictions.includes('number')
        const rlength = restrictions.length
        const type = rlength == 1 && rn 
            ? 'number'
            : rc
            ? 'color'
            : rl 
            ? 'pmwh'
            : ''
            
        const payload = {
            name,
        }
        if (exists(type)) payload.type = type
        if (exists(values)) payload.values = values
        return payload
    }).filter(isDefined)
}
----------------------------------

[run.py 05-09-2023]:
def imagePrompt(prompt= 'hamster snail baking cake', size=512):
    #openai

    raise Exception('the images suck. and are creepy no go')
    
    if isNumber(size):
        size = f"{size}x{size}"

    response = openai.Image.create(
      prompt=prompt,
      size=size,
      response_format='url'
    )

    url = response['data'][0]['url']
    downloadImage(url, 'gpt.png', openIt=True)

env.basepyref['gpw'] = 'gitPushWorking'
----------------------------------

[LineEdit2.js 05-09-2023]:
let yaml1682805963 = `
    
    - 
        tag: p
        value: hi
    - 
        tag: p
        value: bye

    - 
        tag: container
        style:
            color: 1
            bold: true
        children:
            - 
                tag: introducer
                value: It will look something like this
                children:
                    - 
                        tag: item
                        value: graph

    
`

import yaml from "js-yaml"
console.logg(yaml.load(yaml1682805963)); throw ''
----------------------------------

[css-utils.js 05-09-2023]:
function foo1683640237() {
    let str1683173249 = `
        cm-editor
            h = 100
    
        cm-editor-123
            h = 100
    `
    console.log(cssPage(str1683173249))
}
----------------------------------

[css-utils.js 05-09-2023]:
function foo1683640328() {
    const cssObject = makeCSSObject()
    const value = cssObject(`
        root
            bred
            h = 40
            mh = 10
    
        focused
            bred
    `)
    console.log(value)
}
----------------------------------

[css-utils.js 05-09-2023]:
console.log(getStylePayload('grid-area = a | b c | d'))
----------------------------------

[parselib.js 05-09-2023]:
let str1683233580 = `
   
    /* @bookmark 1683600728 .header */

    header
        bg:red

    @float(+)
    el
        bg:red
    el
        @float(+)

        el
        el
        el

        el

    el

            breaker

            .header
                coding-website-logo-1 howdy
                    bg:red
                
            @float(split)

            el
            el
            el

            question-panel
                main-question-container fc:green
                    main-question {question}
`
----------------------------------

[parselib.js 05-09-2023]:
let str1683639192 = `
    /* 
     * consumed by htmlBuilder2
     * tests list items and code items
     *
     * */
    el

    /* 
     * The @list causes adjacent elements to be grouped
     * underneath its umbrella
     * */

    @list

    el
    el

    el

    /* these code items are automatically delineated as code */
    function foo() {
        function ab() {
        }
    }

    function abc() {
    }

    function abc() {
        function fo() {
            function fo() {
                
            }
        }
    }

    def foo():
        pass
        def foo():
            pass

    Make it as a plugin.
    This is prose.
`
----------------------------------

[parselib.js 05-09-2023]:
function mainPostParse(node) {
    const getLeafAttributeData = leafFactory()
    const lineParser = createLineParser()
    const _ox = oxFactory(oxFunctions)

    function getBranchData(s) {
        const m = lineParser(s)
        if (!m.type) m.type = "branchElement"
        return m
    }

    node.iterate((child) => {
        if (child.type) {
            child.assign({ class: child.type })
            return
            /*
             * Sometimes types are pre-assigned.
             * see fn:getBlock.
             * No further pre-processing is needed in this case
             * */
        }

        const raw = child.value
        if (raw == null) {
            return
            /*
             * spacers do not have child.value
             * do not need to evaluate them
             * */
        }
        child.value = null
        const m = _ox(raw)

        if (m) {
            child.assign(m)
        } else {
            const fn = child.isLeaf
                ? getLeafData
                : getBranchData
            const value = fn(raw)
            child.assign(value)
        }
    })
}
----------------------------------

[f.js 05-09-2023]:
console.log(markdownLeafParser('hi guys 2/4 is fun :happy: r u okay **ff**'))
//console.log(markdownLeafParser('a leaf of pure text should be fiin'))
----------------------------------

[contextParsers.js 05-11-2023]:
const atCallableRE = /^@(\w+)\((.+)\)/
const attrRE = /^(\S+) = (.+)/
----------------------------------

[stylesheet.js 05-11-2023]:
const s = new Stylesheet(elt('div', 'howdy'))
console.log(s.add({a:1}).toString(), '\n--------')
console.log(s.add({b:2}).toString(), '\n--------')
console.log(s.add({b:3}).toString(), '\n--------')
console.log(s.add({b:4}).toString(), '\n--------')
console.log(s.add({b:5, c:6}).toString(), '\n--------')
console.log(s.undo().toString(), '\n--------')
console.log(s.undo().toString(), '\n--------')
console.log(s.undo().toString(), '\n--------')
console.log(s.undo().toString(), '\n--------')
----------------------------------

[ec.js 05-11-2023]:
class Stylesheet {
    propagate(viaStyle = true) {
        const json = this.toJSON()
        const name = this.$el.className
        if (viaStyle) {
            const elements = querySelectorAll(name)
            elements.forEach((element) => {
                if (element != this.$el) {
                    assignStyle(element, json)
                }
            })
        } else {
            const s = cssString(name, json)
            cssLoader(s)
        }
    }

    constructor(element) {
        this.$el = element
        this.reset()
    }

    reset() {
        this.styles = []
        this.popped = []
        this.storage = new Storage()
    }

    update(data) {
        assignStyle(this.$el, data)
    }
    add(style) {
        if (style.left) {
            style.right = "unset"
        }
        if (style.right) {
            style.left = "unset"
        }
        if (style.top) {
            style.bottom = "unset"
        }
        if (style.bottom) {
            style.top = "unset"
        }

        for (let [k, v] of Object.entries(style)) {
            this.storage.add(k, v)
        }
        this.styles.push(style)
        this.update(style)
    }
    undo() {
        if (!this.styles.length) {
            return
        }
        const poppedStyle = this.styles.pop()
        const keys = Object.keys(poppedStyle)
        this.popped.push(poppedStyle)
        const payload = keys.reduce((acc, key) => {
            const store = this.storage.get(key)
            store.pop()
            const value = getLast(store)
            acc[value]
            return acc
        }, {})

        this.update(payload)
    }
    redo() {
        if (this.popped.length) {
            this.add(this.popped.pop())
        }
    }
    toJSON() {
        const store = {}
        for (let [a, b] of this.storage) {
            store[a] = getLast(b)
        }
        return store
    }
    toString() {
        return cssString(this.$el.className, this.toJSON())
    }
}
----------------------------------

[scratchpad.js 05-12-2023]:
class CoordinateGrid {
    constructor(xmax = 10, ymax = 10) {
        /* make it implicit */
        this.points = []

        let [
            xmin,
            ymin,
        ] = [0, 0]

        const width = xmax - xmin
        const height = ymax - ymin - 1
        const axes = {
            xmin,
            xmax,
            ymin,
            ymax,
            width,
            height,
        }

        this.cursor = new CoordinateCursor()
        this.cursor.setAxes(axes)
        this.axes = axes
    }
    add(value) {
        const payload = {
            value,
            pos: this.cursor.pos.toJSON()
        }
        this.points.push(payload)
    }
    toJSON() {
        return {
            points: flipOrientation(this.points, this.axes.height),
            axes: this.axes,
        }
    }
}
----------------------------------

[scratchpad.js 05-12-2023]:
function addFromBottom(grid, s, rightAlign, offset, short) {
    const items = isArray(s) ? s : split(s, '')
    let heightIncrease = 1
    if (items[0] == '-') {
        grid.axes.height += 1
        //heightIncrease = 0.2
    }
    if (rightAlign) {
        grid.cursor.x = grid.axes.width - 1 - (offset || 0)
        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i]
            grid.add(item)
            grid.cursor.x -= 1
        }

        grid.cursor.y += heightIncrease
        grid.cursor.x = grid.axes.width - 1 - (offset || 0)
        return 
    }

    items.forEach((item, i) => {
        grid.add(item)
        grid.cursor.x += 1
    })
    grid.cursor.x = (offset || 0)
    grid.cursor.y += heightIncrease
}
----------------------------------

[scratchpad.js 05-12-2023]:
function viewGrid(grid) {
    if (grid.constructor.name == 'Matrix2D') {
        return stringer(grid.rows)
    }
    const spaceValue = '#'
    const {points, axes} = grid.toJSON()
    const matrix = new Matrix(axes.width)
    for (let point of points) {
        matrix.set(point.pos.x, point.pos.y, point.value)
    }

    const array2D = matrix.toArray()
    return stringer(array2D)

    function stringer(array2D) {
    return array2D.map((row) => {
        return row.map((x) => {
            return x == null || x === '' ? spaceValue : x
        }).join('')
    }).join('\n')
    }
}
----------------------------------

[scratchpad.js 05-12-2023]:
function flipOrientation(points, height) {
    return points.map(({pos, value}, i) => {
        return {
            value,
            pos: {
                x: pos.x,
                y: height - pos.y,
            },
        }
    })
}

/* why did I want to get a tree structure for this ? */
/* can totally create a nesting structure */



//12.32423


function getDecimalLength(s) {
    return (s.toString().match(/\.\d+/) || ['.'])[0].length - 1
}
function prepare(s) {
    //console.log(eval(s.trim()))
    const operatorRE = /[+*/-]/
    const items = split(s.trim(), operatorRE)

    /* 
     * only normalize decimals if the operator is plus or minus.
     * */
    const longestDecimal = getLongest(items, getDecimalLength)
    const normalizedItems = items.map((item, i) => {
        const n = longestDecimal - getDecimalLength(item)
        return item + '0'.repeat(n)
    })

    const rows = normalizedItems.map((x) => split(x, ''))
    const matrix = new Matrix2D(rows)
    const columns = matrix.getColumns().reverse()
    //console.log(normalizedItems)
    //console.log(columns)
    const top = [null]
    const bottom = []
    let currentCarry = 0
    columns.forEach((column, i) => {
        if (column.every(isNumber)) {

            const sumValue = sum(column) + currentCarry
            const [a, b] = split(sumValue)
            const value = b != null ? b : a
            const carry = b != null ? a : null
            if (i == columns.length - 1) {
                bottom.push(value)
                if (carry) {
                    bottom.push(carry)
                    top.push(null)
                    rows.forEach((row, i) => {
                        row.unshift(null)
                    })
                }
            } else {
                if (carry) currentCarry = carry
                top.push(carry)
                bottom.push(value)
            }
        }
        else {
            let a = top.pop()
            top.push(null)
            top.push(a)
            bottom.push('.')
        }
    })
    top.reverse()
    bottom.reverse()
    const value = flat2D(top, rows, bottom)
    return value
}

//console.log(viewGrid(prepare(str0307)))
function widthAndHeight(items) {
    const length = getLongest(items)
    return [length, items.length]
}

function mather() {
    const items = prepare(str0307)
    const grid = new CoordinateGrid(...widthAndHeight(items))
    items.reverse().forEach((item, i) => {
        addFromBottom(grid, item)
    })
    const stringGrid = viewGrid(grid)
    const matrix = new Matrix2D(splitSplit(stringGrid))
    //console.log(matrix); throw "";
    insertRow(matrix.rows, -1, '-'.repeat(matrix.width + 2), false)
    fillRowsFromLeftAndRight(matrix.rows)
    const fixedStringGrid = viewGrid(matrix)
    console.log(getCoordinatesFromStringGrid(fixedStringGrid))
    //matrix.insertColumn()
    //console.log({matrix})
}
function insertRow(rows, index, x) {
    insert(rows, isString(x) ? x.split('') : x, index)
}

function fillRowsFromLeftAndRight(rows) {
    const payload = '*'
    const longest = getLongest(rows)
    rows.forEach((row, i) => {
        let count = 0
        while (row.length < longest) {
          isEven(count++) ?
              row.unshift(payload) : row.push(payload)
        }
    })
}

function splitSplit(s) {
    return lineGetter(s).map((x) => split(x, ''))
}

/* the grid */
function getCoordinatesFromStringGrid(s) {
    //console.log(s)
    const store = []
    const items = s.split('')
    let x = 0
    let y = 0
    for (let i = 0; i < items.length; i++) {
        let item = items[i]
        if (item == '\n') {
            y += 1
            x = 0
        }
        else if (item == '#') {
            x++
        }
        else if (item == '-' && items[i + 1] == '-') {
            let count = 0
            while (true) {
               if (items[++i] == '-') {
                   count++
               }
               else {
                   count++
                   i--
                   break
               }
            }
            store.push({pos: [x, y] , type: 'line', width: count})
        }
        else {
            //store.push({x, y, value: item})
            store.push({pos:[x, y], value: item})
            x++
        }
    }
    return store
}
//console.log(mather())

function toCoordinateSingles(...args) {
    return flat(args).map((arg) => split(arg, ''))
}
function emGuidedMultiplication2(s) {
    const [a, b] = longShort(...getNumbers(s))

    const topSingles = split(b).map((n, i) => [a, n])
    const bottomAnswers = reverse(topSingles.map(([a,b]) => a * b))
    const finalAnswer = a * b

    let items = toCoordinateSingles(a, b, bottomAnswers, finalAnswer)
    let [gridWidth, gridHeight] = widthAndHeight(items)

    const grid = new CoordinateGrid(gridWidth, gridHeight)
    const [A, B, ...ANSWERS] = items
    const FINAL = ANSWERS.pop()

    addFromBottom(grid, FINAL, true)

    //console.log(grid); assert();
    //addFromBottom(grid, '-'.repeat(grid.axes.width), true)

    // To be part of this system.
    // That what I do could be different.

    ANSWERS.reverse().forEach((ANSWER, i, a) => {
        ANSWER.push(...map(a.length - i - 1, 'O'))
        addFromBottom(grid, ANSWER, true)
    })
    //grid.cursor.y += 0.25
    //console.log(grid)
    //console.log(); assert();
    //addFromBottom(grid, '-'.repeat(grid.axes.width), true)
    let deltaOperatorLength = grid.axes.width - B.length
    let deltaAB = Math.abs(B.length - A.length)
        //console.log(deltaAB)
    if (deltaAB > 0 && deltaAB < 7) {
        map(deltaAB - 1, (x) => B.unshift(null))
        B.unshift('*')
    }
    else {
    switch (deltaOperatorLength) {
        case 1:
            B.unshift('*');
            break;

        case 2:
        case 3:
            B.unshift(null);
            B.unshift('*');
            break;

        case 4:
        case 4:
            B.unshift(null);
            B.unshift(null);
            B.unshift('*');
        default:
            let n = deltaOperatorLength - 2
            map(n, (x) => B.unshift(null))
            B.unshift('*');
    }
    }
    addFromBottom(grid, B, true)
    addFromBottom(grid, A, true)
    //console.log(grid.points)
    //console.log(); assert();
    const stringGrid = viewGrid(grid)
    console.log(stringGrid)
    const coords = getCoordinatesFromStringGrid(stringGrid, grid.height)
    console.log(coords); throw "";

    const vueObject = coords.map((coord, i) => {
        const directives = 
            [{name: 'pos', value: coord.pos, multiplier: 20}]

        if (coord.type == 'line') {
            return {
                directives,
                ...Line({width: coord.width * 20 + 'pt'}),
            }
        }
        return {
            directives,
            tag: 'div',
            staticClass: 'katex',
            value: coord.value,
        }
    })
    //console.log(vueObject)

    return {
        tag: 'div',
        staticClass: 'guided-multiplication',
        style: { position: 'relative', },
        children: vueObject,
    }
}

//const tempVueData = emGuidedMultiplication2('123 * 12344')
//console.log(tempVueData)
//export {
    //tempVueData
//}

function SVGLine({width} = {}) {
    const child = {
                tag: 'line',
                attrs: {
                    stroke: 'black',
                    //strokeWidth: '20',
                    x1: 0,
                    y1: 0,
                    y2: 0,
                    x2: width,
                }
            }
    const attrs = {
        width,
        height: '1',
    }
    return SVGWrapper(attrs, child)
}
function SVGWrapper(attrs, child) {
    return {
        tag: 'svg',
        attrs,
        children: [ child ]
    }
}


//1.34 + 1.23




class LatexBuilder {
    constructor() {
        this.s = ''
        this.actions = []
        this.lines = []
        this.start = ''
        this.end = ''
    }
    alignAt(key) {
        this.alignmentRE = RegExp(rescape(key))
        this.alignmentKey = key
        this.actions.push('align')
    }
    toString() {
        let s = this.lines.join('   \\\\\n') + '    \\\\\n'
        for (let action of this.actions) {
            s += '\\hline\n'
            s = align(s)
        }
        return s
    }
    add(terms, operator) {
        terms.forEach((term, i, a) => {
            let payload = this.alignmentRE ? 
                term.toString().replace(this.alignmentRE, this.alignmentKey + '&') : term

            if (a.length - 1 == i) {
                payload = operator + spaces(2) + payload
            }
            this.lines.push(payload)
        })
        return this
    }
}
function decimalArithmetic(s) {
    const terms = [123, 14444]
    const builder = new LatexBuilder()
    builder.alignAt('.')
    builder.add(terms, '+')
    //console.log(builder)
    return builder.toString()
}
function spaces(n) {
    return '\\,'.repeat(n)
}
function align(s) {
    return `\\begin{align*}${newlineIndent(s)}\\end{align*}`
}
//clip(decimalArithmetic('/home/kdog3682/2023/scratchpad.js'))


function latex1() {
    return {
        component: 'VLatex',
        props: {
            value: 'x^2 + 3 \\\\text{.   abc abc is the answer.} But \\\\tfrac{2}{3} \\\\text{is not.}'
        }
    }
}
//console.log(latex1(1))


let str0308 = `

nest1 
    nest 1 child 1
    nest 1 child 2

    nest2

        foo() {
            
        }

nestparent2
    howdy
`
function trimStart(s) {
    return s.replace(/^ *(?:\n *)*\n/, '')
}
function trimEnd(s) {
    return s.replace(/(?:\n *)*\n$/, '')
}
class EatFresh {
    constructor(s, indent = 0) {
        this.s = trimEnd(trimStart(s))
        this.indent = indent
        //console.log('starting s', {s: this.s})
        this.store = []
        this.run()
    }
    run() {
        breaker(5)
        const m = this.eat(/^\w+.*?(?=\n\S|$)/s)
        if (!m) {
            return 
        }
        const [a,b] = search(/^(.*?)\n+([^]+)/, m)
        console.log({b})
        console.log(); assert();
        const child = new EatFresh(a, this.indent + 1)



        console.log(a); throw "";
        //this.eat(/^\s+/)
        //this.eat(/^\w+.*?(?=\n\S|$)/s)
        return this
    }
    eat(r) {
        const spaces = ' '.repeat(this.indent * 4)
        const regexString = '^' + spaces + r.source.replace(/^\^/, '')
        const regex = new RegExp(regexString, r.flags)
        let m = this.s.match(regex)
        if (m) {
            const a = m[0]
            this.s = this.s.slice(a.length)
            return a
            //if (exists(a)) {
                //console.log({a})
                //const child = new EatFresh(a)
                //this.store.push(child.run())
            //}
            this.store.push(m.slice())
            console.log('store')
            console.log(this.store)
            console.log('------------------')
            console.log(this.s)
            console.log('------------------')
        }
    }
}
//const eaterie = new EatFresh(str0308)


var temp123 = [
  "haojunzhou",
  "shujingzhao",
  "ivyliu",
  "jaydenzhang",
  "alexdeng",
  "bonniejiang",
  "alexanderchen",
  "stephanieli",
  "stephenmai",
  "jefferyliang",
  "vincentchen",
  "austinwang",
  "mingruizhu",
  "andersonchen",
  "felixlee",
  "sandychen"
]
const f = (x) => {
    const filler = 'boogabooga'
    insert(x, filler, 1)
    insert(x, filler, 3)
    return x
}
//clip(partition(temp123, 2).map(f))


function logWithCaller() {
  const caller = logWithCaller.caller.name;
  console.log(`${caller}:`, ...arguments);
}
function fxoo() {
    logWithCaller()
}
//console.log(fxoo())


//import { wonderfulHomework } from "./vob.worksheet.js"
//console.log(stringify(wonderfulHomework()))


let mtxtstr0215 = `

# Sam and Ham Cakes

Every time Sam eats a cake, Ham eats 3 times as many cakes.

## Which equation below shows the correct relationship between Sam and Ham?

S represents Sam Cakes.
H represents Ham Cakes.

S = H + 3
H = S div 3
S = H div 3
H = S times 3

## On Monday, Sam and Ham eat a total of 12 cakes. How many cakes does Sam eat?



## On Tuesday, Sam and Ham eat a total of 120 cakes. How many cakes does Ham eat?


## @dialogue @skip

Hammy, no more cakes! 120 cakes is too many cakes!

But Hammy didn't listen. Bonnie's Bakery has the best cakes.
At 9:08PM, Hammy noticed Shujing was soon to fall asleep.
It was time for Ham and Sam's great adventure.
They would sneak off to Bonnie's Bakery for more cakes.

If the journey takes 17 minutes, Sam's bathroom break takes 1 minute, and Ham's snack break takes 3 minutes, what time will Ham and Sam arrive at Bonnie's Bakery?

(9:08PM + 17 + 1 + 3)


# Bonnie's Bakery

Every day, Bonnie's bakery has lots and lots of customers. That's why before the day even starts, Bonnie has to do lots of prep work to make sure everything runs smoothly.

The night before, she completes 3/5 of her prep work. How much more prep work does Bonnie need to complete in the morning in order to finish all of it?

(equivalent(3/5))


# block

3/5 + 2/5 - 1/5
roundingNumbers(42754)
numberPattern(106, 102, 98, null, 94)
fractionDecomposition(7/12)
1248 / 7

# 

The area of a rectangle is base times height.
The perimeter of a rectangle is add up all of the sides.

Rectangle A has an area of 40. Which of the following could be its perimeter?
@ai
`
----------------------------------
[utils.js 05-13-2023]:
function recursiveDictBuilder(dict) {
    dict = {
        a: ['b'],
        b: ['c', 'd'],
        c: ['d', 'e'],
        d: 'dowdy',
    }
    const keys = Object.keys(dict)
    return objectWalk2(dict, (v, parent, key, depth) => {
        if (keys.includes(v)) {
            /* index tooo */
            parent[key] = v + 'hii'
            //return v + 'hiiiiii'
        }
    })
}
----------------------------------

[utils.js 05-13-2023]:
function objectWalk2(o, f) {
    function runner(o, parent, key, depth = 0) {
        f(o, parent, key, depth)
        for (let [k, v] of Object.entries(o)) {
            isArray(v) && o[k].forEach(curryEnd(runner, o, k, depth + 1))
        }
        return o
    }
    return isArray(o) ? o.map(curryEnd(runner)) : runner(o)
}
console.log(recursiveDictBuilder())
----------------------------------
[JSObject.js 05-13-2023]:
function splitArgsAndParent(args) {
    if (args.length == 1) {
        return [args, null]
    }

    const last = getLast(args)
    if (isClassObject(last)) {
        return [args.slice(0, -1), last]
    }
}
----------------------------------

[pl-htmlBuilder.js 05-16-2023]:
function markMagic(rootNode) {
    console.log('no mark magic atm')
    return 
    rootNode.iterate((node) => {
        const [a,b] = splitOnce(node.value)
        if (a in magicRef) {
            const result = magicRef[a](node, b)
            return true
        }
    })
}
----------------------------------

[pl-htmlBuilder.js 05-16-2023]:
const magicRef = {
    numberedList(node, topValue) {
        node.assign({value: topValue})
        node.children.forEach((child, i) => {
            child.tag = 'li'
        })
        return false 
    }
        /* this will prevent the children from iterating */
}
----------------------------------

[css-utils.js 05-24-2023]:
function cssColon2Old(a, b) {
    const key = cssAttributeAbbreviations[a] || a
    return b.includes(' ')
        ? {[key] : b} : cssParseColon(a, b)
}
----------------------------------

[css-utils.js 05-24-2023]:
function cssColonoold(s) {
    if (s.includes(' ')) {
        const [a,b] = splitOnce(s, ':')
        return {
            [a]: b
        }
    }
    const r = /(\S+):(\S+)/g
    const f = (a, b) => {
        return getStylePayload(a, b)
    }
    if (/\S:\S/.test(s)) {
        return dict(map(findall(r, s), f).flat())
    }
    return getStylePayload(s)
}
//console.log(cssColon('bg:r3 fc:r5'))
//

let str1684279624 = `
            content: counter(item-count) ". "
`
//console.log(cssColon2(str1684279624.trim()))
//console.log(cssColon('mb'.trim()))
----------------------------------

[vimrc 05-24-2023]:
function NewString()
    
endfunction
----------------------------------

[today2.js 05-26-2023]:
let str1684962696 = `
    tx translate
    r rotate
    ta text-anchor
    ty translate
    t translate
    f fill color
    sc strokeColor color
    c strokeColor color
    sw strokeWidth
    h height
    w width
`
//const schema = ['alias', 'key', 'type']
//rp(str1684962696).split('lines').map((x) => x.match(/\w+/g).toSchema(schema)).write()
----------------------------------

[today2.js 05-26-2023]:
function jankyJavascript() {
    console.log('aaaaa')
}

//svgPathParser
----------------------------------

[LocalEvaluator.js 05-29-2023]:
function createSchema() {
    const lineParams = [
        "x1",
        "y1",
        "x2",
        "y2",
        "stroke",
        "strokeWidth"
    ]
    const args = ["fill", "stroke", "strokeWidth"]

    /* prettier-ignore */
    const items = [
      {"name": "xline", "params": lineParams},
      {"name": "yline", "params": lineParams},
      {"name": "line", "params": lineParams},
      {"name": "radialGradient", "params": ["...colors"]},
      {"name": "linearGradient", "params": ["...colors"]},
      {"name": "gradient", "params": ["tag", "...colors"]},
      {"name": "rect", "params": ["x", "y", "width", "height", ...args]},
      {"name": "circle", "params": ["cx", "cy", "r", ...args]},
      {"name": "square", "params": ["x", "y", "length", ...args]},
      {"name": "pattern", "params": ["width", "height"]},
      {"name": "group", "params": []},
    ]
    return items
    return items.reduce((acc, item, i) => {
        acc[item.name] = item.params
        return acc
    }, {})
}
----------------------------------

[pl-svgBuilder.js 05-29-2023]:
const ad3Spec = {
    options: { getBlocks: "d3Blocks" },
    postParse(node) {
        let localStore = []
        const colors = {
            red: "red",
            blue: "blue",
            green: "green"
        }
        const baseContext = {
            ...colors,
            xline: (...args) => {
                const value = ["xl", ...args]
                localStore.push(value)
                return value
            },
            yline: (...args) =>
                localStore.push(["yl", ...args])
        }

        let evaluate = ScopedEvaluate(baseContext)

        return runner(node)

        function childElement(v) {
            return {
                type: "childElement",
                value: evaluate(v)
            }
        }
        function leaf(v) {
            return v
            if (/^(?:[xy]?line|aaaa)/.test(v)) {
                const a = evaluate(v)
                return {
                    type: "element",
                    value: a
                }
            }

            const m = search(
                /^(\$*\w+) *= *['"]?(\w+)['"]?$/,
                v
            )
            if (m) {
                baseContext[m[0]] = m[1]
                evaluate = ScopedEvaluate(baseContext)
            } else {
                return { type: "js", value: v }
            }
        }

        function runner(node) {
            let v = node.value

            if (node.isLeaf) {
                return { type: "leaf", value: v }
                //return leaf(v)
            }

            const state = {}
            const store = []
            //if (v) {
            //store.push(childElement(v))
            //}
            const js = []
            const leaves = []
            for (const child of node.children) {
                const val = runner(child)
                if (!val) continue
                if (val.type == "leafdddddddd") {
                } else if (val.type == "leaf") {
                    leaves.push(val.value)
                } else if (val.type == "js") {
                    js.push(val.value)
                } else if (val.type == "element") {
                    store.push(val.value)
                } else {
                    push2(store, val)
                }
            }

            if (exists(leaves)) {
                if (v) {
                    leaves.push(v)
                    v = null
                }
                localStore = []
                let code = join(leaves)
                evaluate(code)
                console.log({ localStore })

                store.push(localStore)
            }
            if (exists(js)) {
                localStore = []
                let code = join(js)
                console.log(code)
                evaluate(code)
                store.push(localStore)
            }
            if (v) {
                //store.push(evaluate(v))
            }
            return store
        }
    }
}
----------------------------------

[pl-svgBuilder.js 05-29-2023]:
function d3PostParse(node, value) {

    const evaluator = new LocalEvaluator()
    const colors = {
        $globalBlue: 'blueee',
        red: "red",
        blue: "blue",
        green: "green"
    }
    const functions = {
        double,
    }

    evaluator.load({
        ...this.state.contextProps,
        ...colors,
        ...functions,
    })
    const evaluate = evaluator.build(svgElements)

    const parentState = {children: []}
    const payload = topRunner(node, parentState)
    if (this.state.mode == String) return d3String(payload)
    return payload

    function topRunner(node, parentState) {
        const store = []

        for (const child of node.children) {
            evaluator.code.push(child.value)

            if (child.isBranch) {
                const parent = evaluate()

                const newState = {
                    children: []
                }

                topRunner(child, newState)

                while (parent.length > 1) {
                    parentState.children.push(parent.shift())
                }
                newState.value = parent[0]
                push2(parentState.children, newState)
            }
        }

        const children = evaluate()
        extend(parentState.children, children)
        return parentState
    }
}
----------------------------------

[pl-svgBuilder.js 05-29-2023]:
function d3PostParseOld(node, value) {
    //let localStore = []
    let localStore = new LocalState()
    let js = []

    const colors = {
        red: "red",
        blue: "blue",
        green: "green"
    }

    const evaluators = {
        xline(anchor, width, height) {
            return 1
        },
        pattern(w, h) {
            return 2
        }
    }
    const contextProps = this.state.contextProps
    const baseContext = {
        ...contextProps,
        ...colors,
        double,
        ...createLocalFunctions(localStore, evaluators),
    }

    const evaluate = ScopedEvaluate(baseContext)
    const parentState = {children: []}
    return topRunner(node, parentState)

    function topRunner(node, parentState) {
        const store = []

        for (const child of node.children) {
            js.push(child.value)

            if (child.isBranch) {
                const parent = evalJS()

                const newState = {
                    children: []
                }

                topRunner(child, newState)

                while (parent.length > 1) {
                    parentState.children.push(parent.shift())
                }
                newState.value = parent[0]
                push2(parentState.children, newState)
            }
        }

        const children = evalJS()
        extend(parentState.children, children)
        return parentState

        function evalJS(asParent) {
            if (empty(js)) {
                return 
            }
            localStore.reset()
            evaluate(jankyJavascript(js))
            js = []
            return localStore.toJSON()
        }
    }
}
----------------------------------

[pl-htmlBuilder.js 05-30-2023]:
const yamlRef = {
    graph(node, yam) {
        //console.log(yam); assert();
        node.component = 'VGraph'
        node.props = yam
        node.value = ''
        //node.locals()
        //node.globals()
    }
}
----------------------------------

[pl-htmlBuilder.js 05-30-2023]:
function onYamlEnd(node) {
    const r = /^graphe/
    const regex = /^(\w+) *(.*)\n+([^]+)/
    node.selectAll(r).forEach((child) => {
        const [type, title, c] = child.value.match(regex).slice(1)
        const yam = extendedYamlParser(c)
        yam.title = title
        const fn = yamlRef[type]
        fn(child, yam)
        return false
    })
}
----------------------------------

[fire.js 05-30-2023]:
function setAliases(state, obj) {
    for (let [k, v] of Object.entries(obj)) {
        state[k] = state[v].bind(state)
    }
}
----------------------------------

[fire.js 05-30-2023]:
function createQuery(collectionRef, o = {}) {
    const args = [collectionRef]
    if (o.limit) {
        args.push(limit(o.limit))
    }
    if (o.orderBy) {
        args.push(orderBy(o.orderBy))
    }
    if (o.where) {
        args.push(where(o.where))
    }
    return query(...args)
}
----------------------------------

[pl-htmlBuilder.js 05-30-2023]:
function createComponents(ref) {
    if (!ref) ref = {
        d3: d3Builder,
        html: htmlBuilder,
    }
    return reduce(ref, (k, fn) => {
        const name = `v-${k}-container`
        const component = {
            name,
            props: ['value'],
            render(h) {
                return h('pre', JSON.stringify(this.value))
                return vueRenderer(this, fn(this.value))
            }
        }
        return [name, component]
    })
}
----------------------------------

[fire.py 05-30-2023]:
hammyAssignments = {
  "assignments": [
    {
      "title": "Algebraic Expressions",
      "description": "Simplify and evaluate algebraic expressions",
      "dueDate": "2023-05-01T23:59:59Z",
      "points": 20,
      "questions": [
        {
          "text": "Simplify: 3x + 5 - 2x + 7",
          "answer": "x + 12"
        },
        {
          "text": "Evaluate: 2x^2 - 3x + 1, when x = 4",
          "answer": "21"
        },
        {
          "text": "Simplify: (x + 2)(x - 3) + (x + 2)(4 - x)",
          "answer": "-2x - 10"
        }
      ]
    },
    {
      "title": "Functions and Graphs",
      "description": "Graph and analyze functions",
      "dueDate": "2023-05-08T23:59:59Z",
      "points": 30,
      "questions": [
        {
          "text": "Graph the function y = 2x + 1",
          "answer": "(insert graph image here)"
        },
        {
          "text": "Find the domain and range of the function f(x) = x^2 - 4",
          "answer": "Domain: all real numbers; Range: y ≤ -4 or y ≥ 0"
        },
        {
          "text": "Find the x-intercept(s) of the function y = x^3 - 3x^2 - 9x",
          "answer": "x = -3, 0"
        }
      ]
    },
    {
      "title": "Trigonometry",
      "description": "Solve problems using trigonometric functions",
      "dueDate": "2023-05-15T23:59:59Z",
      "points": 40,
      "questions": [
        {
          "text": "Find the value of sin 60°",
          "answer": "0.866"
        },
        {
          "text": "Find the length of the side opposite the angle θ in the right triangle below: (insert image of right triangle)",
          "answer": "8"
        },
        {
          "text": "Solve for x: tan x = 1",
          "answer": "x = π/4 or 45°"
        }
      ]
    }
  ]
}
----------------------------------

[pl-create.js 05-30-2023]:
function oxFactory(obj) {
    /*******************************
     * ox stands for Object-X Parsing
     *******************************/
    /*******************************
    * 05-30-2023 documentation:
    * deprecated in favor for oxNodeFactory
    * 
    *******************************/
    const items = createParsersFromObject(obj)
    return function ox(s) {
        for (let { regex, parser } of items) {
            const m = search(regex, s)
            const value = m && parser(...toArray(m))
            if (value) {
                return value
            }
        }
    }
}
----------------------------------

[pl-create.js 05-31-2023]:
function depbuildParser2(spec) {
    const o = {
        __postparse__: createPostParse(spec),
        options: spec.options,
        methods: spec.methods,
        mounted: spec.mounted,
    }
    return buildParser(o)
}
----------------------------------

[pl-create.js 05-31-2023]:
    function callingGetBranchData(s) {
        try {
            const m = elementParser.call(this, s)
            m.type = "branchElement"
            return m
        } catch(e) {
            console.log({s})
            throw new Error()
        }
    }

    function callingGetLeafData(s) {
        let m = leafFn && leafFn.call(this, s)
        if (m) {
            m.type = "leafAttribute"
        } else {
            m = elementParser.call(this, s)
            m.type = "leafElement"
        }
        return m
    }
----------------------------------

[pl-create.js 05-31-2023]:
    return function postParse(node, arg = true) {
        let currentValue = node
        for (const action of actions) {
            //const newValue = action.call(this, currentValue)
            //const newValue = action(currentValue)
            const newValue = action.name == 'main' ? action.call(this, currentValue) : action(currentValue)
            ///* calling */

            if (isDefined(newValue)) {
                currentValue = newValue
            }
        }
        return arg === true && isClassObject(currentValue)
            ? currentValue.toString(o.stringFn) : currentValue
    }
----------------------------------

[Lezer.js 06-02-2023]:
function runLezerHTMLnope(s) {
    const lezer = new Lezer(s.trim())
    const store = {}
    let current = store
    let lastValue
    const stack = []
    stack.push(current)

    lezer.tree.iterate({
        enter(node) {
            lastValue = lezer.getState(node)
            const name = lastValue.name
            current[name] = {}
            current = current[name]
            stack.push(current)
        },
        leave(node) {
            const value = lezer.getState(node)
            current = stack.pop()
        },
    })

    //const value = lezer.run(null, 'next')
    //console.log(value)
}

import {
    read,
    textAndLang,
    append,
    clip,
    appendVariable,
    write,
    rpw,
    isFile,
    sysget,
    npath,
    dirFromPath,
    //dryOrDebug,
} from "./node-utils.js"
----------------------------------

[Lezer.js 06-02-2023]:
function runLezerHTML(s) {
    const lezer = new Lezer(s.trim())
    const g = (x) => console.log(lezer.getState(x))
    const cursor = lezer.cursor
    const next = () => {
        cursor.next()
        g(c)
    }
    const c = cursor
    while (true) {
        if (cursor.firstChild()) {
            g(c)
            next()
            return
            while (cursor.nextSibling()) {
                g(c)
            }
            return
        }
        console.log()
        throw new Error()
    }
}
----------------------------------

[cm-inputHandler.js 06-03-2023]:
const EmptyDictionary = {
    "-": "-------------------------\n",
    //r: "return ",
    //f: inputHandler,
}


function inputHandlerFactory(fn) {
    return function inputHandler(cm, from, to, key) {
        const node = getNodeBefore(cm)
        const line = getLine(cm).text
        const value = fn(key, node.body, line, node, cm)
        if (isDefined(value)) {
            const [cursor, insert] = isObject(value) ? 
                [value.foo, value.boo] : [0, value]

            const selection = cursor ? 
                {anchor: cursor + node.from} : null

            cm.dispatch({
                changes: {
                    from: node.from,
                    to: node.to,
                    insert: insert,
                },
                selection
            })
            return true
        }
    }
}
----------------------------------

[cm.js 06-03-2023]:
function q2() {
    /*******************************
     * Write a function which
     * returns an object that has a key of fruits
     * The corresponding value should be an array containing 3 fruits.
     *
     * $answer.fruits.length === 3
     *
     * This is a dumb question.
     * It is kind of boring.
     *******************************/

    const myDataObject = {
        /* cursor */
    }
    return myDataObject
}

//Show me how to do it.
----------------------------------

[cm.js 06-03-2023]:
async function mainMounted() {
    const extensionState = {
        lang: "javascript",
        tabSize: 4,
        theme: "oneDark",
        theme: "solarizedLight",
        inputHandler,
        myTheme: "myTheme",
        lineNumbers: null
    }

    this.editor = new CodePanel(
        this.$refs.codemirror,
        extensionState,
        myBasicSetup
    )
    this.editor.focus()
    await toggleLanguages(this)
}
----------------------------------

[cm.js 06-03-2023]:
function myCompletions(context) {

    const completions = [
      {label: "panic", type: "keyword"},
      {label: "park", type: "constant", info: "Test completion"},
      {label: "password", type: "variable"},
    ]
  let before = context.matchBefore(/\w+/)
  if (!before) return null
  return {
    from: before ? before.from : context.pos,
    options: completions,
    validFor: /^\w*$/
  }
}
----------------------------------

[cm.js 06-05-2023]:
    //sleepshot
    //enter
    //sleepshot
    //type const asdf co
    //sleepshot
    //type space
    //sleepshot
    //type enter
    //type co
    //type space
    //type enter
    //type co
    //this.editor.setAutoComplete(myCompletions)
    //this.editor.setAutoComplete(completeJSDoc)
    //setTimeout(() => { console.log(this.editor.getText()) }, 1000)
    //await toggleThemes(this) /* works */
    //await toggleLanguages(this) /* works */
----------------------------------

[cm.js 06-06-2023]:
function wrapFn(fn, o) {
    const gn = o.state ? fn.bind(o.state) : fn
    return function lambda(...args) {
        const value = gn(...args)
        if (value == null && o.afterIfNullResult) {
            o.afterIfNullResult(...args)
        }
        else if (o.after) {
            o.after(...args)
        }
    }
}
----------------------------------

[clip.js 06-07-2023]:
function StateFunctionFactory(State, {args, main, methods} = {}) {
    const state = new State(...toArray2(args))
    const fn = state[main].bind(state)
    for (const [k, v] of Object.entries(methods)) {
        fn[k] = state[v].bind(state)
    }
    return fn
}
----------------------------------

[next.py 06-09-2023]:
def parseDiff(dir=dir2023):
    
    new = getNewGitFiles()
    rfile = '^diff --git a/(.*?) b.*\nindex (\w+)\.\.(\w+)'
    cmd = SystemCommand(f""" git diff --word-diff """)
    print(cmd.success)
    return 
    date = datestamp()
    matches = re.split(rfile, cmd.success, flags=re.M)
    items = partition(filter(matches), 4)
    def parse(x):
        a, b, c, d = x
        prefix = "[\[\{][-+]"
        regex = "^\{\+(?:(?:async )?function[!*]?|def|class|const|var) ([\w\$]+)"
        items = re.findall(regex, d, flags=re.M) or []
        if not items:
            return 

        payload = { 'date': date, 'file': a, 'from': b, 'to': c, 'items': items }
        return payload

    items = filter([parse(x) for x in items])
    for file in new:
        if fsize(file) < 50:
            rfile(file)
            continue

        payload = {
            'date': date,
            'file': file,
            'new': True,
        }
        if getExtension(file) == 'js':
            payload['items'] = getFunctionNames(read(file))

        items.append(payload)
    return items
----------------------------------

[cm-main.js 06-09-2023]:
function tryWrap(fn, ...args) {
    return function lambda() {
        try {
            return fn.call(this, ...args)
        } catch (e) {
            console.log("aaaaaaa")
            console.log(e.toString())
            console.log(e.stack)
            throw "trywrap"
        }
    }
}
----------------------------------

[cm-next.js 06-09-2023]:
class LezerTree {
    constructor(x) {
        const state = "state" in x ? x.state : x

        this.state = state
        this.pos = cmPos(this)
        this.tree = cmTree(this)
        this.text = cmText(this)
        this.cursor = this.tree.cursor()
        this.getState = this.getState.bind(this)
    }

    getState(node, mode) {
        const { from, to, name } = node
        const body = this.text.slice(from, to)
        return mode == "body"
            ? body
            : mode == "name"
            ? name
            : { from, to, name, body }
    }

    getCursor(x) {
        return !x
            ? this.cursor
            : "cursor" in x
            ? x.cursor()
            : x
    }
    getFunction(x) {
        return !x ? identity : isString(x) ? this[x] : x
    }
    iterate(x, y) {
        const cursor = this.getCursor(x)
        const fn = this.getFunction(y)
        const store = []
        while (cursor.next()) {
            push2(store, fn(this.getState(cursor), this))
        }
        return store
    }
}
----------------------------------

[cm-components.js 06-13-2023]:
var VLogItem = {
    name: 'VLogItem',
    props: ['value'],
    mounted() {
        console.log('hello from VLogItem')
    },
    render(h) {
        const raw = this.value
        const div = (value, color, bold) => {
            const fontWeight = bold ? 'bold' : null
            return h('div', {style: {color: color, fontWeight}}, value)
        }

        const span = (value, color, bold) => {
            const fontWeight = bold ? 'bold' : null
            return h('span', {style: {color: color, fontWeight}}, value)
        }

        const renderArray = (raw) => {

             const items = raw.map(runner)
             let showBody = false
             const onClick = () => {
                 showBody = !showBody
             }
             const children = showBody ? [
                span('['),
                ...items,
                span(']'),
             ] : [
                span('['),
                ...items,
                span(']'),
             ]

             const style = {}
             const body = h('div', {
                on: {click: onClick},
                style,
             }, children)
        }

        const renderObject = (item, t) => {

            let showBody = true 
            const onClick = () => {
                 showBody = !showBody
            }

            const children = showBody ? [
                div('{'),
                div(Object.entries(item).map(([a,b]) => {
                    const propKey = span(`"${a}"`, 'orange')
                    const propColon = span(':', 'gray')
                    const propValue = runner(b)
                    const children = [propKey, propColon, propValue]
                    return h('div', children)
                }), 'ml50'),
                div('}')
            ] : [
                span(`{Object}`, 'gray', true),
            ]

            const options = {
                on: {click: onClick},
            }
            const body = h('div', options, children)
            return body
        }

        const renderClassObject = (item, t) => {
            return h('div', 'classobjectnotdoneyet')
        }

        const runner = (item) => {
            const t = type(item)
            switch (t) {
                case 'Object': return renderObject(item)
                case 'Array': return renderArray(item)
                case 'Undefined': return span('undefined', 'gray')
                case 'Null':   return span(`null`, 'black')
                case 'Number': return span(`${item}`, 'blue')
                case 'String': return span(`'${item}'`, 'red')
                default: return renderClassObject(item, t)
            }
           
        }
        return runner(raw)
    },
}

//import {setupComponent} from "./setupComponent.js"
//setupComponent(VTextEditor)
//setupComponent(VTextEditor)
//setupComponent(VLogBody)
----------------------------------
[lezerGenerate.js 06-13-2023]:
lezerGenerate(basic, {split: true, ref: basicRef, logIt: true, pretty: true})
----------------------------------

[cm-components.js 06-13-2023]:
function mixinData(state, data) {
    const prev = state.$options.$data ?
        state.$options.$data() : {}

    const payload = mergeFresh(prev, data)
    state.$options.data = function () {
        return payload
    }
}
----------------------------------

[vimrc 06-14-2023]:
function Hpath(m)
    
endfunction
----------------------------------

[utils.js 06-14-2023]:
function raise(...args) {
    for (let i = 0; i < args.length; i += 2) {
        const [a,b] = args.slice(i, i + 2)
        if (a) {
            throw new Error(b)
        }
    }
}
----------------------------------

[ElementController.js 06-15-2023]:
            //this.storage.add(lastKey, newValue)
            //this.styles.push({[lastKey]: newValue})
            //this.lastTouchedItem = [lastKey, newValue]
            //this.update()
            //return this
----------------------------------

[pl-htmlBuilder.js 06-15-2023]:
function preview(x) {
    function runner(x) {
        console.log({value: x.value})
    }
    toArray2(x).map(runner)
    throw 'preview'
}
----------------------------------

[pl-htmlBuilder.js 06-15-2023]:
let str1686365177 = `
    button-icon reset
        class:foo

    breaker
    instructions
        ho ho ho
        go go go

    keypressItems
        class:asd123 

        p hi
            class:55
        p bye
            bg:r5

    i foo

    button-icon reset
        class:foo
        css:flex center

    breaker
    grid-container 12
        class:my-grid

        foo a 
        bar b 
        car c

    ender

    button-icon reset
        class:foo
        class:goo
        bg:r3
        css:flex

    ender

        keypressItems 
            class:abc
            bg:r3
            css:flex bg:black

        ender

        keypressItems 
            class:abc
            mouseover:foo = false
            click:$emit('click', $event)

            p item.foo
                class:abc

                ender


        message show:isHovered 
            slot :item = value
                bg:r1
                p value: {value}
                    bg:g4

                p value: {value}
                    bg:g4
                    ender

            slot :item = value class:hover-message
                foobar

            ender

            v-asdf :xcv = asa
                v-asdf :value = abc

            i class = material-icons {value}
ender

    logItems
        v-log-item :bind = item
        ender


        keypressItems 
            //class:abc
            //b:black
            //minh:50

            p item.foo
                //content:"
                class:abc
                ender

    //logItems
        //p {item}
        ender

            p item.foo
                content:leftQuote
                e
                class:ab
                ender

            header
            left
                v-code-editor @update = onUpdate
            right
                html-container v-html = html
            footer
            ender

            foo
                fruits
                    apples
                meats
                    pork
                    beef
e

            pork
                class:name == activeElement ? selected : unselected
                e
                {adasd}
                    bg:r1

e

        name-container
            for name in names
                click:setActiveElement(name)
                class:name == activeElement ? selected : unselected
                {name}

e

        
        .v-modal
            transition
                container
                    show:isActive
                    slot


`
console.log(htmlBuilder(str1686365177))
----------------------------------

[serve_html_file.js 06-16-2023]:
function runBackend({
    file,
    post,
    windowDataFn,
} = {}) {
    assert(isFile(file), `${file} is not a valid file`)
    const key = removeExtension(file)
    const port = 3000 
    const baseUrl = `http://localhost:${port}`
    const listenerUrl = `${baseUrl}/${key}`

    const getUrl = `/${key}`
    const postUrl = `/`
    const mainGet = routerApps.buildGet(key, asFile)
    const directory =  "/home/kdog3682/2023"

    const app = express()
    app.use(express.static(directory))
    app.use(express.json())
    app.listen(port, mainListen)
    app.get(getUrl, mainGet)
    app.post(getUrl, mainGet)

    async function mainListen(e) {
        log("/*---------------------------------*/")
        log("Running Server on port", port)
        log("LocalHost URL", listenerUrl)
        log(new Date().toLocaleString())
        log('server.main.action: ', {action})
        log("/*---------------------------------*/")

        if (action) {
            const puppeteer = new Puppeteer2()
            if (action == 'host') {
                setTimeout(open, 1000, listenerUrl)
            }
            await puppeteer.run({url: listenerUrl, action})
        } else {
            console.log('no puppeteer. go localhost')
            open(listenerUrl)
}
----------------------------------

[setupComponent.js 06-17-2023]:
function oldsetupWatchers(x) {
    const keys = Object.keys(x)
    fo
    for (let key of keys) {
        let m = search(/watch(\w+)/, key)
        let v = x[key]
        if (m && isFunction(v)) {
            if (!x.watch) {
                x.watch = {}
            }
            x.watch[uncapitalize(m)] = {
                immediate: topComment(v) == 'immediate',
                handler: v,
            }
        }
    }
}
----------------------------------

[utils.js 06-17-2023]:
function mixin2(state, ...mixins) {

    if (!state.options) state.options = {}
    if (!state.data) state.data = {}

    flat(mixins).forEach((mixin) => entries(mixin).map(g)

    function g([k, v]) {
        if (v == null) {
            return
        }
        if (isFunction(v)) {
            State[k] = v.bind(State)
        } 
        else if (isObject(v)) {
            if (v.get && isFunction(v.get)) {
                Object.defineProperty(State.prototype, k, v)
            }
            else if (k == 'methods') {
                mixin(State, v)
            }
            else if (State.hasOwnProperty(k)) {
                Object.assign(State[k], v)
            }
            else {
                State[k] = v
            }
        } else {
            State[k] = v
            //console.log({k, v})
        }
    }
}
----------------------------------

[ElementController.js 06-18-2023]:
class VueWindowListener {
    constructor(vue, { options = {}, contexts = {} } = {}) {
        this.vue = vue
        this.map = new Map()
        this.options = options
        this.contexts = this.init(contexts)
        const handleKey = this.options.mainHandleKey
            ? this.options.mainHandleKey
            : this.contexts[0].name
        this.setContext(handleKey)
    }
    init(contexts) {
        const f = (k, v) => {
            const contextSpec = { ...v, name: k }
            const vue = this.vue
            return new ContextHandle(contextSpec, {vue})
        }
        return reduce2(contexts, f)
    }
    setContext(name, props) {
        if (this.context) {
            this.prevContext = this.context
            this.prevContext.onExit()
        }
        this.context = this.contexts[name]
        this.context.reset()
        this.context.onEnter(props)
        this.listen(this.setListener(this.context.handle))
    }
    setListener(handle) {
        if (this.map.has(handle)) {
            return this.map.get(handle)
        }

        const preHandle = (key, currentInput) => {
            const computedKey =
                key.length > 1 ? key : currentInput + key

            let value = this.context.run(
                computedKey,
                currentInput
            )
            if (isDefined(value)) return value

            if (key == ' ') {
                this.enterFunction = 
                    this.spaceActivatedFunctions[currentInput]
                if (this.enterFunction) {
                    return CLEAR
                }
            }
            return CLEAR
        }

        const listener = (e) => {
            const key = getKeyArg(e)
            //console.log({key})
            preventDefault(e)

            const input = this.vue.input

            let response
            try {
                response = preHandle(key, input)
            } catch(e) {
                console.log('error @ preHandle', e.toString())
                return 
            }

            if (response === false) {
                try {
                    response = handle(key, input)
                } catch(e) {
                    const error = parseError2(e)
                    if (error.type == 'TypeError') {
                        console.log(error.message, 'keep going')
                        response = null
                    }
                    else {
                        console.log('error @ handle', e.toString())
                        return 
                    }
                }
            }

            switch (response) {
                case undefined:
                case null:
                    if (key.length == 1) {
                        this.vue.input += key
                        console.log({key, v:this.vue.input})
                        //console.log('adding key')
                    }
                    return
                case "":
                    console.log("clearing")
                    this.vue.input = ""
                    return
                case -1:
                    this.vue.input = backspace(
                        this.vue.input
                    )
                    console.log({s: this.vue.input})
                    return
            }
        }
        this.map.set(handle, listener)
        return listener
    }

    listen(listener) {
        if (this.listener == listener) {
            return
        }
        window.removeEventListener("keydown", this.listener)
        window.addEventListener("keydown", listener)
        this.listener = listener
    }
}
----------------------------------

[utils.js 06-19-2023]:
function aaa() { console.log('aaa') }
function bbb() { console.log('bbb') }
function ccc() { console.log('ccc') }
wrapFunctionBefore(wrapFunctionBefore(aaa, bbb), ccc)()
----------------------------------

[ec.js 06-19-2023]:
import {
    createVue,
} from "./vueSetup.js"

import {htmlBuilder} from "./pl-htmlBuilder.js"
import * as lorem from "./lorem.js"
import { animateOpacity } from "./animations.js"
import { cssIncrement, CSSAliases, cssString } from "./css-utils.js"
import {
    Element
} from "./Element2.js"
import {
    isNode,
    Storage,
    edit,
    Watcher,
    breaker,
    bindObject,
    backspace,
    getLast,
    join,
    isString,
    assert,
    isNumber,
    logConsole,
    flat,
    split,
    modularIncrement,
    findIndex,
    compose,
    dict,
    findall,
    stringBreaker,
    removeComments,
    makeRunner,
    isObject,
    map,
    TypeAssertion,
    sleep,
    chalk,
    fuzzyMatch2,
    red,
} from "./utils.js"

import {
    keypressDict,
    assignStyle,
    createElement,
    elementGetter,
    getKeyArg,
    getBoundingClientRect,
    preventDefault,
    querySelectorAll,
    localPost,
} from "./browser-utils.js"



const AnyangHandle = {
    name: "AnyangHandle",

    info() {},

    escape() {
        /* not really a Handle ... */
        /* more like a thing that exists ... a Module perhaps */
        /* ... */
        /* ... */
        /* ... */
    },
}

const ColonHandle = {
    name: "ColonHandle",
    initVueDisplayState: {
        staticClass: "colon",
        ummm: "dunno",
    },
    mounted() {
        this.vue.updateState({
            staticClass: "colon",
            style: styleParser("bg = y1"),
        })
        /*
         * In this manner, the state can change.
         * */
    },
    handle(key) {
        if (isNumber(key)) {
            this.setIncrement(key)
        }
        if (key in this.context) {
            this.context[key].call(this)
        }

        return
    },
    colon() {
        if (this.vue.input) {
        }
    },
    enter() {
        if (this.vue.input) {
        }
    },
}

const PositionHandle = {
    name: "AbsolutePositionHandle",
    name: "PositionHandle",
    handle(key) {
        if (isNumber(key)) {
            this.setIncrement(key)
        }
        if (key in this.context) {
            this.context[key].call(this)
        }

        return
    },

    top() {
        this.incrementPosition("top")
    },
    left() {
        this.incrementPosition("left")
    },
    bottom() {
        this.incrementPosition("bottom")
    },
    right() {
        this.incrementPosition("right")
    },
    escape() {
        const clickCount = this.clickTally.current
        if (clickCount == 2) {
            this.setContext("MainHandle")
        }
    },
    reset() {
        console.log("in-progress")
        assert()
        const sheet = this.activeElement.stylesheet
        sheet.addStyle({
            left: 0,
            top: 0,
        })
    },
    voiceActivationReference: {
        position: "asdfasdf",
        aaaaa: "vvvvvv",
    },
    methods: {
        setIncrement() {},
        incrementPosition(key) {
            const sheet = this.activeElement.stylesheet
            const currentPos = sheet[key]
            const clickCount = this.clickTally.current

            const ref = cssIncrementBuckets[key]
            const bucket = ref.find((bucket) => {
                const [a, b] = bucket.clickRange
                if (numClicks >= a && numClicks <= b) {
                    return true
                }
                if (!bucket.posRange) {
                    return
                }
                const [c, d] = bucket.posRange
                if (currentPos > c && currentPos < d) {
                    return true
                }
            })

            const direction =
                key == "top" || key == "right" ? 1 : -1
            const newPos =
                direction * increment + currentPos
            sheet.updateKey(key, newPos)
        },
    },
}

const PaddingHandle = {
    mounted() {
        console.log("hello from PaddingHandle")
    },
    //name: "PaddingWidthMarginHandle",
    name: "PaddingHandle",
    /* it has a sufficient amount shared ... */
    handle(key) {
        if (isNumber(key)) {
            if (this.lastKey) {
                return this.handleNumber(key)
            }
        }
    },
    handleNumber(key) {
        this.lastKey
    },
    actions: [
        { name: "paddingBottom", aliases: ["pb"] },
        { name: "more", aliases: ["="] },
        { name: "less", aliases: ["-"] },
        //{name: 'paddingTop', aliases: ['pt']},
        //{name: 'paddingLeft', aliases: ['pl']},
        //{name: 'paddingRight', aliases: ['pr']},
        //{name: 'paddingHorizontal', aliases: ['px']},
        //{name: 'paddingVertical', aliases: ['py']},
    ],
    methods: {
        paddingBottom(n) {
            if (n == null) {
                green("activated pb")
                return
            }
            ex.padding += n
            console.log("hi pb", ex.padding)
        },
        more() {
            return this.root.__run__(this.lastKey, 5)
        },

        less() {
            return this.root.__run__(this.lastKey, -5)
        },
    },
}
class Handle {
    constructor(state) {
        Object.assign(this, state)
    }
    setup() {}
}

var VTopBar = {
    name: 'VTopBar',
    props: ['value'],
    template: `
        
        for dropdown in value 
            v-dropdown :value = dropdown
    `,
}
var VDropdown = {
    name: 'VDropdown',
    props: ['value'],
    template: `
        if touched
            v-dropdown-option-panel for = value.items
        else
            button {value.label}
    `,
}
var xxxVElementController = {
    name: 'VElementController',
    props: ['value'],
    template: `
        v-top-bar :value = dropdowns

        v-control-panel :value = buttons
            template-slot
                
        v-history-panel :value = history
            template-slot
            
        {console}
        {activeElement}
    `,

    data() {
        return {
            activeElement: '',
            console: '',
            buttons: [
                {

                },
            ]
        }
    },
    mounted() {
        new VueWindowListener(this)       
    },
    methods: {
        onFoo(...args) {
            console.log({args})
        },
        onClick(buttonIndex) {
            announce(buttonIndex, this.buttons[buttonIndex])
        }
    }
}
const SpaceActivations = {
    paddingBottom: {
        defaultValue: 0,
        defaultUnit: 0,
    }
}
function normalizeAttrKey(key) {
    console.log({key})
    return CSSAliases[key]
}
/* @bookmark 1680661648 SpaceActivationHandle */
const SpaceActivationHandle = {
    vueState: {
        
    },
    vueItems: [
        {
            props: {},
            component: 'ghjghj',
        },
    ],
    mounted({name, props}) {
        let currentAttrKey = props.currentAttrKey
        this.currentAttrKey = normalizeAttrKey(currentAttrKey)
        this.currentAttrRef = SpaceActivations[this.currentAttrKey]
        this.currentAttrValue = this.currentAttrRef.defaultValue
    },
    actions: {
        left() { return this.cssIncrement(-1) },
        right() { return this.cssIncrement(1) },
    },
    methods: {
        cssIncrement(dir) {
            this.currentAttrValue = 
                cssIncrement(this.currentAttrValue, dir)
            console.log(this.currentAttrValue)
        }
    },
    name: "SpaceActivationHandle",
    handle(key) {
        if (/[1-9]/.test(key)) {
            this.currentAttrValue = Number(key)
            return 0
        }
        if (key in this.currentAttrRef) {
            this.currentAttrRef[key].call(this)
            return 0
        }
    },
}

const CSSHandle = {
    mounted() {
        console.log("hello from CSSHandle")
    },
    name: "CSSHandle",
    handle(key) {
        if (key == "p") {
            return this.root.setContext("PaddingHandle")
        }
    },
    handles: {
        PaddingHandle,
    },
    setup() {
        /* @bookmark 1679802616 this.context.once */
        //console.log(this.vue); assert();
        const actions = [{ ah: 123 }]
    },
}

/* @bookmark 1680654852 SimpleHandle */
const SimpleHandle = {
    mounted() {
        console.log(
            "hello we have arrived at simple handle"
        )
    },
    name: "SimpleHandle",
    methods: {
        inputParser(input) {
            console.log("hi")
            assert()
        },
    },
    handle(key) {
        if (key == "enter") {
            this.inputParser(this.input)
            return 0
        }
        if (
            key == " " &&
            CSSAliases.hasOwnProperty(this.input)
        ) {
            this.root.setContext(
                "SpaceActivationHandle",
                {currentAttrKey: this.input}
            )
            return 0
        }
        this.input = this.vue.input + key
        blue('input', this.input)
    },
    setup() {
        //this.known = ['a']
        this.inputParserWorker = makeRunner({
            foo(a, b) {
                /* ^([a-z]+)(\d+)$ */
                console.log({ a, b })
            },
        })
        /*
         *
         * A few handles can use prehandle
         * because they have aliases
         * In the setup actions which becomes transmuted.
         *
         * But SimpleHandle does not do this.
         *
         * */
        /* after pressing enter ... you can do certain things */
        /* you can repeat the last command */
        /* mounted happens every single time */
        /* setup happens once */
        const actions = [{ ah: 123 }]
    },
}

const SecondaryHandle = {
    name: "SecondaryHandle",
    handle(key) {},
    actions: [{ name: "menu", aliases: ["m"] }],
    menu() {
        this.root.setContext("MainHandle")
    },
}

const MenuHandle = {
    name: "MenuHandle",
    mounted(prev) {
        const { name, data } = prev || {}
        this.menuData = data
    },
    shortcuts: {
        c: "CSSHandle",
    },
    handle(key) {
        if (isNumber(key)) {
            this.handleNumber(key)
        } else if (key == "escape") {
            this.root.setPrevContext()
        } else if (key in this.shortcuts) {
            this.root.setContext(this.shortcuts[key])
        } else {
            warn("no context matches for the key", key)
        }
        return 0
    },
    handleNumber(key) {
        const choice = this.menuData[key - 1]
        this.root.setContext(choice)
    },
}

/* @bookmark 1679715452 MainHandle */
const MainHandle = {
    name: "MainHandle",
    handle(key) {
        //console.log(this, key); assert();
    },

    actions: [
        //{name: 'right', aliases: ['rgh']},
        //{name: 'bottom', aliases: ['rgh']},
        //{name: 'left', aliases: ['rgh']},
        { name: "menu", aliases: ["m"] },
    ],
    methods: {
        getContextNames() {
            return Object.keys(this.root.contexts)
        },
    },

    menu() {
        this.root.setContext(
            "MenuHandle",
            this.getContextNames()
        )
    },
}
/* @bookmark.1678504832 */
const ecVueState = {
    getters: {
        activeElement: () => this.vue.ec.activeElement,
        stylesheet: () =>
            this.vue.ec.activeElement.stylesheet,
        foobar_getter_test1: () => this.foobar1,
        /* this doesnt work */
        foobar_getter_test2() {
            return this.foobar1
        },
        /* but this does work */
    },
    /* it doesnt have to hold its own data */
    foobar1: "hi from foobar1 at ecVueState",
    options: {
        mainHandleKey: "MainHandle",
        mainHandleKey: "SimpleHandle",
    },
    async mounted() {
        this.vue.el = new StyleElement()
        if (isNode()) {
            return
        }
        this.vue.ec = new ElementController()
        this.vue.ec.load()
        const names = this.vue.ec.tree.getNames()
        while (true) {
            breaker(5)
            const name = this.vue.ec.next()
            if (name) {
                this.setActiveElement(name)
                await sleep(1000)
            } else {
                break
            }
        }
        console.log({ names })
    },
    contexts: {
        //SpaceActivationHandle,
        //SimpleHandle,
        //MainHandle,
        //PositionHandle,
        //SecondaryHandle,
        //MenuHandle,
        //CSSHandle,
        //PaddingHandle,
        //StyleHandle,
        //ColorHandle,
        //EvalHandle,
        //DimensionHandle,
    },
    globals: {
        ["go-main"]() {
            this.setContext("MainHandle")
        },
        ["go-position"]() {
            this.setContext("PositionHandle")
        },
        ["go-style"]() {
            this.setContext("StyleHandle")
        },
        //position style
        //position style
        //position style
        prev() {
            this.setActiveElement(this.vue.ec.next())
            return 0
        },
        next() {
            this.setActiveElement(this.vue.ec.prev())
            return 0
        },
        backspace() {
            return -1
        },
        escape() {
            return 0
        },
        undo() {
            this.vue.ec.stylesheet.undo()
            return 0
        },
        redo() {
            this.vue.ec.stylesheet.redo()
            return 0
        },
    },
}

class VueWindowListener {
    constructor(vue, externalState) {
        this.handleMap = new Map()
        this.watcher = new Watcher()
        this.clickTally = new ClickTally()
        this.doLifeCycleAction = this.doLifeCycleAction.bind(this)
        this.vue = vue
        this.vue.vuewin = this

        bindObject(this, externalState)

        this.mounted()
        this.setContext(this.options.mainHandleKey)
    }
    prehandle(key, input) {
        const aliases = this.context.aliases
        if (!aliases) {
            return
        }
        const effectiveKey = input + key
        const fnKey = aliases[effectiveKey]
        if (!fnKey) {
            return
        }
        return this.__run__(fnKey)
    }
    setPrevContext() {
        this.setContext(this.prevContext.name)
    }
    __run__(key, ...args) {
        breaker(100)
        const ignore = [
            "more",
            "less",
            "left",
            "right",
            "top",
            "bottom",
            "enter",
        ]
        if (!ignore.includes(key)) {
            this.context.lastKey = key
        }
        return this.context.methods[key](...args) || 0
    }
    setContext(name, props) {
        if (name == null) {
            return
        }

        /* the data should be serializeable */
        this.prevContext = {
            name: this.context ? this.context.name : null,
            props,
        }
        this.context = this.contexts[name]
        this.context.lastKey = null

        const handle = this.context.handle
        const listener = this.setListener(handle)
        this.listen(listener)

        if (this.watcher.isFresh(name)) {
            this.initializeContextOnce()
        }
        TypeAssertion(this.context.name, String)

        this.runLifeCycles()
        return 0
    }
    setListener(handle) {
        if (!handle) return
        if (this.handleMap.has(handle)) {
            return this.handleMap.get(handle)
        }

        //this.handle = handle.bind(this) /* old */
        this.handle = handle.bind(this.context) /* old */
        //console.log(this.context); assert();

        /* @bookmark.1678510184 */
        const listener = (e) => {
            const key = getKeyArg(e)
            this.clickTally.add(key)
            const input = this.vue.input
            let response = this.prehandle(key, input)
            if (response == null) {
                response = this.handle(key, input)
            }

            if (response === true || response === 200) {
                return
            } else if (response === 0) {
                //console.log('reseting the input to ""')
                this.vue.input = ""
            } else if (response === -1) {
                this.vue.input = backspace(this.vue.input)
            } else if (response) {
                console.log("ndy...ec.js:line:148")
            } else {
                this.vue.input += key
            }
            preventDefault(e)
        }
        this.handleMap.set(handle, listener)
        return listener
    }

    listen(listener) {
        if (!listener) return
        if (this.listener == listener) {
            return false
        } else if (this.listener) {
            window.removeEventListener(
                "keydown",
                this.listener
            )
        }
        window.addEventListener("keydown", listener)
        this.listener = listener
        return true
    }
    initializeContextOnce() {

        console.log(`
                setting up root and vue
            `)
        if (!this.context.options) {
            this.context.options = {}
        }

        this.context.root = this
        this.context.vue = this.vue

        if (this.context.setup) {
            this.context.setup()
            /* @bookmark 1679802616 this.context.once */
        }

        //announce()

        if (!this.context.methods) {
            this.context.methods = {}
        } else {
            console.log("binding methods to context!")
            edit(this.context.methods, (k, v) => {
                this.context[k] = v.bind(this.context)
            })
        }
        const actions = this.context.actions

        if (!actions) {
            console.log(
                "no actions so we dont set up actions"
            )
            console.log(
                "which subsequently means we dont set up aliases either"
            )
            return
        }

        if (!this.context.aliases) {
            this.context.aliases = {}
        }

        if (isObject(actions)) {
            return map(actions, (name, fn) => {
                this.context.methods[name] = fn.bind(this.context)
                this.context.aliases[name] = name
                /* it is important to set the aliases. aliases tells the prehandle whether or not prehandle can be run. prehandle uses the effective key. so make sure to clear out the previous input if necessary */
                /* @bookmark 1680661985 this.context.aliases */
            })
        }

        //if (!this.context.methods) {
        //this.context.methods = {}
        //}

        this.context.actions.forEach((item, i) => {
            const { name, aliases, action } = item
            const fn = (action || this.context[name]).bind(
                this.context
            )
            //console.log(fn)
            /* each function in this manner is bound to this */
            if (!fn) {
                console.log("error no fn")
                return
            }

            this.context.methods[name] = fn
            aliases.forEach((alias, i) => {
                this.context.aliases[alias] = name
            })
            //console.log(state.context)
        })
    }
    runLifeCycles() {

        const lifeCycleActions = [
            {
                method: "mounted",
                source: "context",
                args: "prevContext",
                //updateVue: true,
            },
        ]

        lifeCycleActions.forEach(this.doLifeCycleAction)

        chalk(`
            Running Life Cycles for ${this.context.name}
            Number of cycles is ${actions.length}.
        `)
    }
    doLifeCycleAction(action) {
        
        const { method, source, args, updateVue } = action
        const context = source == "this" ? this : this[source]
        const fn = context[method]
        if (fn) {
            chalk("running", method)
            if (args) {
                fn.call(context, ...this.map(args))
            } else {
                fn.call(context)
            }
        }
        if (updateVue && context.vueState) {
            this.updateVueState(context)
        }
    }
    updateVueState(context) {
        console.log('updating vue state because context has changed')
        const {name, vueState} = context
        if (this.vue.components[name]) {
            this.vue.componentKey = this.vue.components[name]
        }
        console.log('do something here ....')
        map(vueState, () => {
            //this.vue.component =
        })
        /* everything needs to have a name pretty much */


    }
    map(...args) {
        return flat(args).map((arg) => this[arg])
    }
}

var oldECControlConfig = {
    globals: {
        r() {
            vue.ec.stylesheet.redo()
        },

        u() {
            vue.ec.stylesheet.undo()
        },
        colon(vue) {
            vue.ec.stylesheet.repeat()
        },
        comma(vue) {
            vue.display = vue.ec.prev()
        },
        period(vue) {
            vue.display = vue.ec.next()
        },
        escape(vue, state) {
            if (vue.display) {
                vue.display = ""
            } else {
                vue.ec.reset()
                state.activeProperty = ""
            }
        },
        left(vue, state) {
            if (state.activeProperty) {
                vue.ec.decrementProperty(
                    state.activeProperty
                )
            }
        },

        right(vue, state) {
            if (state.activeProperty) {
                vue.ec.incrementProperty(
                    state.activeProperty
                )
            }
        },
    },
}

class QueryList {
    constructor({transform, limit} = {}) {
        this.transform = transform || identity 
        this.limit = limit || 5
        this.store = {}
        this.keys = []
        bind(this, 'add')
    }
    add(x) {
        const key = this.transform(x)
        if (this.store.hasOwnProperty(key)) return
        this.store[key] = x
        this.keys.push(key)
    },
    find(q) {
        const key = fuzzyMatch2(this.keys, q)
        return this.store[key]
    }
}
class ElementController {
    constructor() {}
    load(q) {
        const root = elementGetter(q) || document.body.firstChild
        const tree = buildTree(root)

        this.queryList = new QueryList({
            transform: (element) => element.name,
            limit: 3,
        })

        tree.iterate(this.queryList.add)
        this.tree = tree
        this.setActiveElement(tree)
    }

    findall(q) {}
    get element() {
        return this.activeElement.$el
    }
    get stylesheet() {
        return this.activeElement.stylesheet
    }
}

class ECElement extends Element {
    hasChildren() {
        return this.$el.children.length > 0
    }
    get name() {
        return this.$el.className
    }
    __init__(el) {
        this.$el = elementGetter(el)
        this.stylesheet = new Stylesheet(this.$el)
    }
}

function highlight(x) {
    if (!highlight.$el) {
        const style = {
            border: "3px dashed purple",
            opacity: "0",
            zIndex: "999",
            position: "absolute",
            background: "cyan",
            "box-sizing": "border-box",
            padding: 0,
            margin: 0,
        }
        highlight.$el = createElement({
            style,
            className: "highlighter",
        })
    }
    const pos = getBoundingClientRect(x)
    assignStyle(highlight.$el, pos)
    animateOpacity(highlight.$el)
}

function buildTree(
    root,
    condition = yes,
    ignore = ["katex", ""],
) {

    const watcher = new Watcher()

    const runner = (current, depth = 0, parent = null) => {
        const el = new ECElement(current, parent)

        for (const child of current.children) {
            const name = child.className
            if (
                ignore.includes(name)
                || !name
                || !watcher.isFresh(name)
                || !condition(child)
            ) {
                continue
            }

            const newElement = runner(
                child,
                depth + 1,
                el
            )
            el.appendChild(newElement)
        }
        return el
    }
    return runner(root)
}
class ClickTally {
    constructor() {
        this.current = 0
    }
    add(key) {
        if (key == this.currentKey) {
            this.current += 1
        } else if (this.currentKey == null) {
            this.current += 1
            this.currentKey = key
        } else {
            this.current = 1
            this.currentKey = key
        }
        return this.current
    }
}
function initActions(state) {
    if (!state.context.actions) {
        return
    }
    //announce()

    if (!state.context.methods) {
        state.context.methods = {}
    } else {
        console.log("binding methods!")
        edit(state.context.methods, (k, v) => {
            state[k] = v.bind(state)
        })
        //console.log(state.context.methods)
        //you dont want this because it means
        // everything is accessible from everywhere
        // u want it to be self contained the way vue does it
    }

    if (!state.context.aliases) {
        state.context.aliases = {}
    }

    state.context.actions.forEach((item, i) => {
        const { name, aliases, action } = item
        const fn = (action || state.context[name]).bind(
            state
        )
        /* each function in this manner is bound to state */
        if (!fn) {
            console.log("error no fn")
            return
        }

        state.context.methods[name] = fn
        aliases.forEach((alias, i) => {
            state.context.aliases[alias] = name
        })
        //console.log(state.context)
    })
}
function select() {
    vuewin.setContext(vuewin.vue.select("SecondaryHandle"))
}
class StyleElement {
    constructor() {
        this.padding = 0
        //paddingLeft
        //paddingRight
        //paddingTop
        //paddingBottom
        //paddingVertical
        //paddingHorizontal

        this.paddingLeft = 0
        this.paddingRight = 0
        this.paddingTop = 0
        this.paddingBottom = 0

        this.indexed = new GroupIndexed()
        this.load(alignContent)
    }
    load({ name, values }) {
        this.indexed.add(name, values)
    }

    addPaddingLeft(n) {
        this.paddingLeft += n
    }

    addPaddingRight(n) {
        this.paddingRight += n
    }
    addPaddingTop(n) {
        this.paddingTop += n
    }
    addPaddingBottom(n) {
        this.paddingBottom += n
    }
    addPaddingHorizontal(n) {
        this.paddingHorizontal += n
    }
    addPaddingVertical(n) {
        this.paddingVertical += n
    }
}

const alignContent = {
    name: "align-content",
    values: [
        "center",
        "space-between",
        "space-around",
        "stretch",
        "flex-start",
        "flex-end",
    ],
}

class Indexed {
    constructor(items = []) {
        this.items = items
        this.index = 0
    }
    add(item) {
        if (isDefined(item)) {
            this.items.push(item)
        }
    }
    get(el) {
        let newIndex = findIndex(el, this.items)
        if (newIndex < 0) {
            return
        }
        return this.items[this.index]
    }
    prev() {
        this.index = modularIncrement(
            this.items,
            this.index,
            -1
        )
        return this.items[this.index]
    }
    next() {
        this.index = modularIncrement(
            this.items,
            this.index
        )
        return this.items[this.index]
    }
    moveTo(el) {
        let newIndex = findIndex(el, this.items)
        if (newIndex < 0) {
            return
        }
        this.index = newIndex
        return this.items[this.index]
    }
}
class GroupIndexed extends Indexed {
    constructor(store = {}) {
        super()
        this.store = store
    }

    wrapper(key) {
        return this.store[key]
    }
    prev() {
        return this.wrapper(super.prev())
    }
    next() {
        return this.wrapper(super.next())
    }
    get(el) {
        return this.wrapper(super.get(el))
    }
    moveTo(el) {
        return this.wrapper(super.moveTo(el))
    }

    add(key, values) {
        this.items.push(key)
        this.store[key] = new Indexed(values)
    }
    toJSON() {
        return dict(this.items, (key) =>
            this.store[key].get()
        )
    }
}

function createTyper(fn) {
    return function lambda(s) {
        s = removeComments(s)
        s = stringBreaker(s)
        const regex = /\((\w+)\)/g
        const matches = findall(regex, s)
        matches.forEach((match, i) => {
            if (match in keypressDict) {
                fn(keypressDict[match])
            } else {
                match.split("").map(fn)
            }
        })
    }
}

//runWindow('m c p     p b   =  =  =  = - - -  ac ')
//runWindow('m c p     p b   ac ac ac 1')
/* @bookmark 1679802616 this.context.root */

/* @bookmark 1680656592 PuppeteerCommandString */
const PuppeteerCommandString = `
    
    /*---------------------------------*/
    press p
    press b     (pb)  ... we have entered paddingBottom
    press space (space) ... which brings us into SpaceActivation
    (left) but it wont work ... because it needs a current value.
    (right)
    (right)
    (left) now it works



    //Start at SimpleHandle
    //Activate paddingBottom   (pb5) | sets pb 5 points
    //(enter)
    

    /*---------------------------------*/

`


var VDropdownOptionPanel = {
    name: 'VDropdownOptionPanel',
    props: ['icon', 'label', 'action', 'children', 'hotkey'],
    template: `

        flex

        v-icon :value = icon
        .label {label}
        .label {hotkey}
    `,
    methods: {
        handleKeyDown(e) {
            
        },
    },
    mounted() {
        //this.
    },
}
/* @bookmark 1679715452 MainHandle */



//typer(PuppeteerCommandString)
/* @bookmark 1680654852 SimpleHandle */
/* @bookmark 1680656592 PuppeteerCommandString */
/* @bookmark 1680661648 SpaceActivationHandle */
/* @bookmark 1680661985 this.context.aliases */

//d:asdf
//

var VElementController = {
    name: 'VElementController',
    props: ['value'],
    template: `

        for name in names
            click:setActiveElement(name)
            class:name == activeElement ? selected : unselected
            
        {input}
        {activeElement}
    `,

    data() {
        return {
            activeElement: '',
            input: '',
            names: [],
        }
    },
    mounted() {
        new VueWindowListener(this, ecVueState2)       
    },
    methods: {
        setActiveElement(name) {
            const ecElement = isString(name) 
                ? this.queryList.find(name) : name
            if (ecElement) {
                this.activeElement = ecElement.name
                this.ecElement = ecElement
                highlight(ecElement.$el)
            }
        },
        prev() {
            this.setActiveElement(this.ecElement.prev())
        },
        next() {
            this.setActiveElement(this.ecElement.next())
        },
        load(q) {
            const root = elementGetter(q)
            const tree = buildTree(root)

            this.queryList = new QueryList({
                transform: (element) => element.name,
                limit: 3,
            })

            tree.iterate(this.queryList.add)
            this.names = tree.map((e) => e.name)
        },
    },
}
const VerySimpleHandle = {
    name: 'VerySimpleHandle',
    handle(key, currentInput) {
        console.log({key, input})
    },
    methods: {
        foobar() {
            /* foo|boo */

            console.log('hi from foo', type(this))
        },
    }
}

const ecVueState2 = {
    options: {
        mainHandleKey: "VerySimpleHandle",
    },
    contexts: {
        VerySimpleHandle,
    }
}

function createDocument(s) {
    const html = htmlBuilder(s)
    document.body.innerHTML = html
}

const ElementControllerPlugin = {
    install(Vue, options) {
        createDocument(`
            foo
                fruits
                    apples
                meats
                    pork
                    beef
        `)
        const app = createVue(VElementController)
        app.load(document.body.firstChild)
    }

}

//let window = lorem.window
//let ex = new StyleElement()
//let vuewin = new VueWindowListener(lorem.vue)
//let typer = createTyper(window.keydown.bind(window))

class VueWindowListener2 {
    constructor(vue, externalState) {
        this.vue = vue
        mixin(this, externalState)
        this.handleMap = new Map()
        this.setContext(this.options.mainHandleKey)
    }
    setContext(name) {
        this.prevContext = this.context
        this.context = this.contexts[name]
        this.context.lastKey = null

        this.listen(this.setListener(this.context.handle))
    }
    setListener(handle) {
        if (this.handleMap.has(handle)) {
            return this.handleMap.get(handle)
        }

        console.log('binding handle', this.context.name)
        const context = this.context
        const aliases = {}
        editObject2(context.methods, (fn) => {
            const aliasNames = xsplit(topComment(fn))
            aliasNames.forEach((alias) => {
                aliases[fn.name] = alias
            })
            return fn.bind(this.vue)
        })
        const currentHandle = handle.bind(context)


        const run = (key) => {
            const fn = context.methods[key]
            if (fn) {
                context.lastKey = key
                return fn(...args)
            }
        }

        const postHandle = (input) => {
            return 
        }

        const preHandle = (key, input) => {
            const fnKey = key.length > 1
                ? aliases[key]
                : aliases[currentInput + key]

            return fnKey ? run(fnKey) : false
        }

        const listener = (e) => {
            const key = getKeyArg(e)
            red({key, input})
            const input = this.vue.input

            let response = preHandle(key, input)
            if (response === false) {
                response = currentHandle(key, input)
            }
            if (response === false) {
                response = postHandle(input)
            }

            switch (response) {
                case undefined:
                case null:
                    if (key.length == 1) {
                        this.vue.input += key
                    }
                    return 
                case '':
                    this.vue.input = ''
                    return 
                case -1:
                    this.vue.input = backspace(this.vue.input)
                    return 
                case true:
                    return
            }
            preventDefault(e)
        }
        this.handleMap.set(handle, listener)
        return listener
    }

    listen(listener) {
        if (this.listener == listener) {
            return
        }

        window.removeEventListener("keydown", this.listener)
        window.addEventListener("keydown", listener)
        this.listener = listener
    }
}
export {
    ElementControllerPlugin   
}

function editObject2(state, fn) {
    for (let [k, v] of Object.entries(state)) {
        const value = fn(v)
        if (isDefined(value)) {
            state[k] = value
        }
    }
}
----------------------------------

                ArrowBottom: ["y", 1],
                ArrowTop: ["y", -1]
            }
            const m = ref[x]
            dir = m[0]
            key = m[1]
            const newValue = cssIncrement(
                key,
                lastArgValue,
                dir
            )
            const newString = key + newValue
            return this.addString(newString)
        } else if (lastArgKey) {
            const newValue = cssIncrement(
                lastArgKey,
                lastArgValue,
                dir
            )
            const newString = lastArgKey + newValue
            return this.addString(newString)
        }

c 
                argKey: s,
                cssValue: m,

----------------------------------
const LezerFactory = (fn, handleError) => {
    return curry(lezer, fn, handleError)
}
[next.js 06-20-2023]:
const ref = {
    px: {
        keys: ['padding-left', 'padding-right'],
        type: 'pmwh',
        defaultUnit: 'pt',
        incrementRanges:
            [[0, 1, 0.1], [1, 10, 1], [10, 30, 5], [30, 100, 10]],
    },
}


class CSSObject {
    constructor(state) {
        this.values = []
        this.popped = []
        Object.assign(this, state)
        this.set()
    }
    setValue(value) {
        this.argValue = value
        this.values.push(this.argValue)
        return this
    }

    increment(dir) {
        if (!this.__increment__) return null
        return this.setValue(this.__increment__(dir))
    }

    get items() {
        
    }
    __get__(x) {
        return x
    }
    getValue() {
        const value = this.__get__(getLast(this.values))
        this.cachedValue = value
        return value
    }

    decrement() { return this.increment(-1) }
    redo() { this.values.push(this.popped.pop()); return this }
    undo() { this.popped.push(this.values.pop()); return this }
    getCachedValue() { return this.cachedValue }
    get items() {
        return this.getValue()
    }
}

function pmwhIncrement(current, ranges, dir = 1) {
    function getIncrement(n, ranges) {
        const range = ranges.find(([a, b]) => {
            return n >= a && n <= b
        })
        return range[2]
    }
    const increment = getIncrement(current, ranges)
    if (increment + 1 > current && !isInteger(current)) {
        return roundToNearest(current, increment)
    }
    return current + (increment * dir)
}


//c CSSObjectCABMAP
class PmwhObject {
    __init__() {
        this.defaultUnit = 'pt'

    }
    __increment__(arg, dir) {
        //const inc = [[0, 1, 0.1], [1, 10, 1], [10, 30, 5], [30, 100, 10]]
        //ret increment(arg, inc, dir)
        /* hmm do this */
        
        function getIncrement(n, ranges) {
            const range = ranges.find(([a, b]) => {
                return n >= a && n <= b
            })
            return range[2]
        }
        const increment = getIncrement(current, ranges)
        if (increment + 1 > current && !isInteger(current)) {
            return roundToNearest(current, increment)
        }
        return current + (increment * dir)
        }
}

function foo1687219925(items) {
    const cabmap = new Cabmap()
    const indexedCabmap = new IndexedCabmap()

    /* might have to make it for each item */

    const aliases = items.map((x) => x.alias)
    assert(allUnique(aliases))
    const bigRegex = aggregateRE(aliases, /^($1)(.*)/)
    const bigRef = reduce(items, (x) => [x.alias, x])

    return function parser(s) {
        let m
        /*---------------------------------*/
        if (m = indexedCabmap.get(s)) {
            return m 
            /* returns a cabmapObject */
        }
        if (m = cabmap.get(s)) {
            return m
            /* returns itself */
        }
        /*---------------------------------*/
        m = search(bigRegex, s)
        assert(m, `
            no match for ~~ ${s} ~~
            using bigRegex: ${bigRegex}
        `)

        const [argKey,b] = m
        const ref = bigRef[argKey]
        const keys = xsplit(ref.key)
        const type = ref.type

        if (type == 'functional') {
            return {
                type,
                args: [argKey, b]
            }
        }
        if (type == 'color') {
            let colorIndex = null
            let colorKey = null
            let colorValue = null
            const m = search(/^([a-zA-Z]+)(\d+)/, b)
            const args = []
            if (m) {
                args.push('indexed')
                colorKey = m[0]
                colorIndex = Number(m[1])
                args.push(colorKey)
                args.push(colorIndex)
            } else {
                args.push('preset')
                args.push(colorValue)
                colorValue = b
            }
            return new CSSColorObject({
                args, keys
            })
        }
        if (type == 'pmwh') {
            const args = numberBoundarySplit(b)
            const {
                incrementRanges
            } = ref
            return new CSSPmwh({args, incrementRanges, keys})
        }
    }
}
function aggregateRE(x, regexTemplate) {
    const items = isObject(x) ? Object.keys(x) : x
    const keys = sort(items)
    const storage = Storage.partitionByFunction(keys, (x) => x[0])

    const store = storage.entries.map(([k, v]) => {
        if (v.length == 1) {
            return v[0]
        } else {
            let base = sort(unique(v), len, true)
            let elements = base.map((x) => x.slice(1))
            while (elements.every((x, i, a) => x[0] === a[0][0])) {
            	  k += elements[0][0]
                elements = elements.map((x) => x.slice(1))
            }

            if (elements.every((x) => x.length == 1)) {
                return `${k}[${elements.join('')}]`
            }
            let questionMark = ''
            if (getLast(elements) == '') {
                elements.pop()
                questionMark = '?'
            }
            return `${k}${wrap(elements)}${questionMark}`
        }
            
    })
    return reWrap3(store, regexTemplate)

    function wrap(elements) {
        if (elements.every((x) => x.length == 1)) {
            return `[${elements.join('')}]`
        }
        return elements.length > 1
            ? `(?:${elements.join('|')})`
            : elements[0]
    }

    function reWrap3(x, r) {
        function getReplacement(x) {
            const keys = isObject(x) ? Object.keys(x) : x
            return keys.every((x) => x.length == 1) 
                ? keys.join('')
                : keys.join('|')
        }

        const source = r.source.replace(/\$1/g, getReplacement(x))
        return RegExp(source, r.flags)
    }
}

function sdf() {
    const c = new CSSObject('px')
    console.log(c)
    console.log(c.set(40))
    console.log(c.increment())
    console.log(c.set(1))
    console.log(c.increment())
    console.log(c.decrement())
    console.log(c.undo())
    console.log(c.undo())
    console.log(c.undo())
    console.log(c.undo())
    console.log(c.redo())
    console.log(c.redo())
}
//

let str1687222962 = `
    bgr1
    bgred
    box50
    harog
    bmd
    t40
`
console.log(foo1687219925(CSSAttributeItems)(getLast(lineGetter(str1687222962))))

----------------------------------

[utils.js 06-21-2023]:
function josdf() {
    console.log([self])
}
function josdf() {
    console.log([this])
}
let jsdf = (x) => [global]
let jsdf = (x) => [globals]
console.log(global)
----------------------------------

[utils.js 06-26-2023]:
//var x = 1
//var x = [['c', 2], ['b']]
//console.log(x.sort((k, v) => k[0].localeCompare(v[0])))
//console.log(x.sort((k, v) => k[0].localeCompare(v[0])))
----------------------------------

[baseComponents.js 06-28-2023]:
function renderAnything(state, value) {
    const h = state.$createElement
    const className = state.$options.name  || 'render-anything'
    const prefix = abrev(className)
    return runner(value)

        const staticClass = `${prefix}-${dashCase(type)}`
        return h('div', {staticClass}, s)
    }
    function runner(x, depth) {
        const t = type(x)
        switch (t) {
            case 'Null':      return simpleRender(t, 'null')
            case 'Undefined': return simpleRender(t, 'undefined')
            case 'String':    return simpleRender(t, x)
            case 'Number':    return simpleRender(t, x)
        
            case 'CustomError':
            case 'Error':

            case 'Set':
            case 'Promise':
            case 'Object':
            case 'Array':
            default:
                return 
        }
    }
}
----------------------------------

[vueSetup.js 06-28-2023]:
function vueSetup2(master) {
    const asNode = isNode()
    const items = ["ham(?:my)?", "v"]
    const childrenRE = reWrap(items, /<((?:$1)[-\w]+)/g)
    const renderRE = /\bV\w+/g
    const directiveRE = /(\w+)directive/i
    const watcher = new Watcher()
    const pluginWatcher = new Watcher()
    pluginWatcher.isFresh('WindowStoragePlugin')
    const plugins = []
    plugins.push(registerFunctionsFactory($toggle, vueGetCountFactory()))

    function mainRunner(items) {
        map(items, wrapper)
    }

    mainRunner(baseComponents)
    if (master != baseComponents)  {
        mainRunner(master)
    }
        

    const pluginRef = {
        MixinDataPlugin,
        WindowStoragePlugin, /* should work */
        //testing: TestingLifeCycleHooksPluginFunction,
    }
    const wrapper = (k, v) => {
        //console.log({k})
        if (!k || !v) {
            return
        }

        if (k.startsWith('renderSpec')) {
            return runnerRenderSpec(k, v)
        }
        if (k == "VTransition") {
            return
        }
        if (type(v) == "Module") {
            return
        }
        if (isObject(v) && v.install) {
            return plugins.push(v)
        }
        if (k.endsWith("PluginFunction")) {
            return plugins.push(v)
        }

        if (k.endsWith("Plugin")) {
            return plugins.push(v)
        }
        if (isFunction(v)) {
            if (asNode) return
            return vuetify(v)
        }
        if (isString(v)) {
            const components = setupString(v)
            return components.forEach((component) => {
                watcher.add(component.name)
                getChildrenFromTemplate(component).forEach(
                    runner
                )
                vuetify(component)
            })
        }
        runner(k)
    }

    /*---------------------------------*/
    if (typeof baseComponents != 'undefined' && !isSetup) {
        vueSetup(baseComponents, {watcher, pluginWatcher}, true)
    }
    else if (master.baseComponents) { 
        vueSetup(master.baseComponents, {watcher, pluginWatcher}) 
    }
    map(master, wrapper)
    /*---------------------------------*/

    const pluginOptions = {}

    plugins.forEach(use)
        //use(plugin)
    //})

    pluginFunctions.forEach((pluginFunction, i) => {
        function install(Vue, options) {
            registerPrototypeFunction(Vue, pluginFunction)
        }
        Vue.use({ install })
    })

    function runnerRenderSpec(key, spec) {
        if (!watcher.isFresh(key)) {
            return
        }
        const name = search(/renderSpec(.+)/, key)
        watcher.add(name)
        const valueKey = spec.transform
            ? getParameters(spec.transform)[0]
            : null

        const options = {
            class: dashCase(name)
        }
        Object.assign(options, spec.options)

        const component = {
            name,
            props: ['value'],
            render(h) {
                const value = valueKey
                    ? spec.transform(this[valueKey])
                    : null
                return h(spec.tag || 'div', options, value)
            }
        }
        //console.log(component)
        vuetify(component)
    }
    function booper(k, v) {
        if (!watcher.isFresh(k)) {
            return
        }
        const x = isDefined(v) && !isNumber(v) ? v : getComponent(k)
        if (!x.name) {
            x.name = k 
        }

        const result = setupComponent(x, k)
        if (isArray(result)) {
            return result.forEach(vuetify)
        }
        getChildrenFromTemplate(x).forEach(booper)
        getChildrenFromRender(x).forEach(booper)
        getChildrenFromComponent(x).forEach(booper)

        if (x.plugins) {
            x.plugins.forEach(({name, options}) => {
                if (pluginWatcher.isFresh(name)) {
                    Vue.use(pluginRef[name], options || {})
                }
            })
        }
        vuetify(x)
    }
    function runner2([k, v]) {
        //console.log({k, v})
        if (!watcher.isFresh(k)) {
            return
        }
        if (!v.name) {
            v.name = k 
        }
        const result = setupComponent(v, k)
        if (isArray(result)) {
            return result.forEach(vuetify)
        }
        getChildrenFromTemplate(v).forEach(runner)
        getChildrenFromRender(v).forEach(runner)
        getChildrenFromComponent(v).forEach(runner2)

        if (v.plugins) {
            v.plugins.forEach(({name, options}) => {
                if (pluginWatcher.isFresh(name)) {
                    Vue.use(pluginRef[name], options || {})
                }
            })
        }
        vuetify(v)
    }

    function runner(key) {
        if (!watcher.isFresh(key)) {
            return
        }
        const x = getComponent(key)
        if (!x.name) {
            x.name = key
        }
        const result = setupComponent(x, key)
        if (isArray(result)) {
            return result.forEach((x, i) => {
                vuetify(x)
            })
        }

        getChildrenFromTemplate(x).forEach(runner)
        getChildrenFromRender(x).forEach(runner)
        getChildrenFromComponent(x).forEach(runner2)

        if (x.plugins) {
            x.plugins.forEach(({name, options}) => {
                if (!pluginWatcher.isFresh(name)) {
                    return 
                }
                Vue.use(pluginRef[name], options || {})
            })
        }
        vuetify(x)
    }

    function getChildrenFromTemplate(x) {
        if (!x.template) {
            return []
        }

        return findall(childrenRE, x.template).map(
            pascalCase
        )
    }

    function getChildrenFromComponent(x) {
        if (!x.components) return []
        return Object.entries(x.components)
    }
    function getChildrenFromRender(x) {
        if (!x.render) {
            return []
        }
        return findall(renderRE, x.render.toString()).map(
            pascalCase
        )
    }


    function getComponent(key) {

        assert(key, "a key is required @ getComponent")

        const presetComponents = {
            VRenderer,
        }

        let cKey
        try {
            cKey = pascalCase(key)
        } catch(e) {
            throw new DebugError(e, key)
        }
        const component = isObject(key)
            ? key
            : master[cKey] || presetComponents[cKey] || window[cKey]

        assert(
            component,
            `the component doesnt exist for key ${key}. most likely, you forget to register ${key} as an export.`
        )
        return component
    }

    function vuetify(x) {
        if (isNode()) {
            return
        }
        if (isVueDirective(x)) {
            const name = dashCase(
                search(directiveRE, x.name)
            )
            Vue.directive(name, x)
            return
        }

        if (isVueComponent(x)) {
            const name = dashCase(x.name)
            Vue.component(name, x)
            window[pascalCase(x.name)] = x
            return
        }
    }
}
----------------------------------

[pl-create.js 06-29-2023]:
function example1687488911() {
    const eaters = {
        foo(s) {
            /* foo (\w+) */
            return { b: 123 }
        },
        moo(s) {
            /* (asdf) */
            return { c: 123 }
        }
    }
    function end(s) {
        return { a: 234 }
    }
    const fn = createElementParser(null, eaters, end)
}
----------------------------------

[ec-main.js 07-02-2023]:
            function parse(s) {
                let second
                let first = s.split(" ")[0]
                if (s.includes("*")) {
                    second = "children"
                } else if (/before/.test(s)) {
                    second = "before"
                } else {
                    second = "after"
                }
                return [first, second]
            }
----------------------------------

[cabmap.js 07-06-2023]:
//import {appendVariable} from "./node-utils.js";
//const g = map(temp, (k, v) => {
    //v.name = k
    //return v
//})
//appendVariable(g)
----------------------------------

[vueSetup.js 07-07-2023]:
function vueSetup(
    master,
    { watcher, pluginWatcher } = {},
    isSetup = null
) {
    const asNode = isNode()
    if (!watcher) watcher = new Watcher()
    const plugins = []
    //const pluginFunctions = [] /* no idea */

    //const pluginRef = {
    //PromptPlugin, /* in progress */
    //MixinDataPlugin,
    //WindowStoragePlugin, /* should work */
    //testing: TestingLifeCycleHooksPluginFunction,
    //}
    const wrapper = (k, v) => {
        if (!k || !v) {
            return
        }

        if (k.startsWith("renderSpec")) {
            return runnerRenderSpec(k, v)
        }
        if (k == "VTransition") {
            return
        }
        if (type(v) == "Module") {
            return
        }
        if (isObject(v) && v.install) {
            return plugins.push(v)
        }
        if (k.endsWith("Plugin")) {
            return plugins.push(v)
        }
        if (isFunction(v)) {
            if (asNode) return
            return vuetify(v)
        }
        if (isString(v)) {
            const components = setupString(v)
            return components.forEach((component) => {
                watcher.add(component.name)
                getChildrenFromTemplate(component).forEach(
                    runner
                )
                vuetify(component)
            })
        }
        runner(k)
    }

    /*---------------------------------*/
    if (typeof baseComponents != "undefined" && !isSetup) {
        vueSetup(
            baseComponents,
            { watcher, pluginWatcher },
            true
        )
    } else if (master.baseComponents) {
        vueSetup(master.baseComponents, {
            watcher,
            pluginWatcher
        })
    }

    /*---------------------------------*/
    map(master, wrapper)
    plugins.forEach(use)
    /*---------------------------------*/

    function runnerRenderSpec(key, spec) {
        if (!watcher.isFresh(key)) {
            return
        }
        const name = search(/renderSpec(.+)/, key)
        watcher.add(name)
        const valueKey = spec.transform
            ? getParameters(spec.transform)[0]
            : null

        const options = {
            class: dashCase(name)
        }
        Object.assign(options, spec.options)

        const component = {
            name,
            props: ["value"],
            render(h) {
                const value = valueKey
                    ? spec.transform(this[valueKey])
                    : null
                return h(spec.tag || "div", options, value)
            }
        }
        vuetify(component)
    }
    function booper(k, v) {
        if (!watcher.isFresh(k)) {
            return
        }
        const x =
            isDefined(v) && !isNumber(v)
                ? v
                : getComponent(k)
        if (!x.name) {
            x.name = k
        }

        const result = setupComponent(x, k)
        if (isArray(result)) {
            return result.forEach(vuetify)
        }
        getChildrenFromTemplate(x).forEach(booper)
        getChildrenFromRender(x).forEach(booper)
        getChildrenFromComponent(x).forEach(booper)

        if (x.plugins) {
            x.plugins.forEach(({ name, options }) => {
                //if (pluginWatcher.isFresh(name)) {
                    //Vue.use(pluginRef[name], options || {})
                //}
            })
        }
        vuetify(x)
    }
    function runner2([k, v]) {
        if (!watcher.isFresh(k)) {
            return
        }
        if (!v.name) {
            v.name = k
        }
        const result = setupComponent(v, k)
        if (isArray(result)) {
            return result.forEach(vuetify)
        }
        getChildrenFromTemplate(v).forEach(runner)
        getChildrenFromRender(v).forEach(runner)
        getChildrenFromComponent(v).forEach(runner2)

        if (v.plugins) {
            v.plugins.forEach(({ name, options }) => {
                //if (pluginWatcher.isFresh(name)) {
                    //Vue.use(pluginRef[name], options || {})
                //}
            })
        }
        vuetify(v)
    }

    function runner(key) {
        if (!watcher.isFresh(key)) {
            return
        }
        const x = getComponent(key)
        if (!x.name) {
            x.name = key
        }
        const result = setupComponent(x, key)
        if (isArray(result)) {
            return result.forEach((x, i) => {
                vuetify(x)
            })
        }

        getChildrenFromTemplate(x).forEach(runner)
        getChildrenFromRender(x).forEach(runner)
        getChildrenFromComponent(x).forEach(runner2)

        if (x.plugins) {
            x.plugins.forEach(({ name, options }) => {
                if (!pluginWatcher.isFresh(name)) {
                    return
                }
                Vue.use(pluginRef[name], options || {})
            })
        }
        vuetify(x)
    }

    function getChildrenFromTemplate(x) {
        if (!x.template) {
            return []
        }

        const items = ["ham(?:my)?", "v"]
        const childrenRE = reWrap(items, /<((?:$1)[-\w]+)/g)
        return findall(childrenRE, x.template).map(
            pascalCase
        )
    }

    function getChildrenFromComponent(x) {
        if (!x.components) return []
        return Object.entries(x.components)
    }
    function getChildrenFromRender(x) {
        if (!x.render) {
            return []
        }

        const renderRE = /\bV\w+/g
        return findall(renderRE, x.render.toString()).map(
            pascalCase
        )
    }

    function getComponent(key) {
        assert(key, "a key is required @ getComponent")

        const presetComponents = {
            VRenderer
        }

        let cKey
        try {
            cKey = pascalCase(key)
        } catch (e) {
            throw new DebugError(e, key)
        }
        const component = isObject(key)
            ? key
            : master[cKey] ||
              presetComponents[cKey] ||
              window[cKey]

        assert(
            component,
            `the component doesnt exist for key ${key}. most likely, you forget to register ${key} as an export.`
        )
        return component
    }

    function vuetify(x) {
        if (isNode()) {
            return
        }
        if (isVueDirective(x)) {
            const directiveRE = /(\w+)directive/i
            const name = dashCase(
                search(directiveRE, x.name)
            )
            Vue.directive(name, x)
            return
        }

        if (isVueComponent(x)) {
            const name = dashCase(x.name)
            Vue.component(name, x)
            window[pascalCase(x.name)] = x
            return
        }
    }
}
----------------------------------

[css-utils.js 07-08-2023]:
            else if (item.type == 'functional') {
                const self = this
                const fnKey = item.fnKey
                function wrap(key, fn) {
                    if (!fn) {
                        console.log(key); assert();
                    }
                    if (countParams(fn) == 1) {
                        return key ? function lambda(...args) {
                            const value = fn.call(self, ...args) 
                            return isObject(value)  ? 
                                value : { [key]: value }
                        } : fn
                    }

                    function foobar(...a) {
                        const args = a.length == 1 && !/^\w+$/.test(a[0])
                            ? argParse(a[0]) : a
                        const value = fn.call(self, ...args)
                        if (isObject(value)) {
                            return value
                        }
                        return key ? { [key]: value } : value
                    }
                    return foobar
                }
                const fn = fnKey && this.functionDict[fnKey]
                    || this.functionDict[alias || ''] 
                    || this.functionDict[camelCase(attributeKey || '')]
                lambda = wrap(attributeKey, fn)
            }

----------------------------------

[utils.js 07-08-2023]:
async function clockTest() {
    const c = new Clock()
    c.duration = 2
    c.onTick = boo
    c.onEnd = () => console.log('done')
    const response = await c.start()
    console.log(response)

    async function boo(count) {
        console.log('count', count)
        if (count === 1) {
            this.pause()
            await sleep(2000)
            this.resume()
        }
        if (count === 4) {
            this.stop()
        }
    }
}

clockTest()
----------------------------------

[baseComponents.js 07-10-2023]:
const renderSpecVPre = {
    tag: "pre",
    transform(value) {
        switch (type(value)) {
            case "Object":
            case "Array":
                return JSON.stringify(value, null, 2)
            case "Null":
            case "NaN":
            case "Undefined":
            case "Number":
            case "String":
                return value
            default:
                return JSON.stringify({
                    name: value,
                    keys: Object.keys(value)
                })
        }
    }
}
----------------------------------

[browser-utils.js 07-10-2023]:
function googleSearch() {
    openWindow
    /* Google Search 1 */
    /* My Google API Services */
    const apiKey = 'AIzaSyCw9aBVDX3VHaJybNKj59_uBhqvIBlXA9k'
    const searchEngineId = '136565982044a46ae'
    //https://console.cloud.google.com/apis/credentials/key/7dbd41e2-bcd5-47ff-b904-048514b497aa?authuser=0&project=rapid-math-367217
    // Very Interesting ...
}
----------------------------------

[a.js 07-11-2023]:
    //errorCaptured(err) { console.log('error captured from child', err) },
    deactivated() {
        console.log('hi deactivated because of keep alive')
    },
    activated() {
        console.log('hi activated because keep alive')
    }
----------------------------------

[ec-main.js 07-11-2023]:

        //await sleep(1000)
        //this.updateElementTree()
        //return
        //const response = await this.$choose(["a", "b", "c"])
        //this.handleResponse(response)
----------------------------------

[vueSetup.js 07-11-2023]:
function browserChalk(a, b) {
    b = stringify(b)
    console.log(
        `%c${a}: %c${b}`,
        "color: blue; font-weight: bold",
        "color: blue"
    )
}
----------------------------------

[pl-htmlBuilder.js 07-12-2023]:
const mdSpec = {
    leafAttributes: markdownLeafAttributeFunctions,
    ox: markdownOxFunctions,

    elementEat: markdownEatFunctions,
    elementEnd: markdownLeafParser,

    //onStart: [markMagic],
    //onEnd: [mergeChildAttributes, floatAction, onYamlEnd, modeHandler],
    onEnd: [floatAction, modeHandler, markdownOnEndDebugHandler],
    stringFn: xmlString,
    options: {
        getBlocks: 'default',
        trackNewLines: true,
        splitRE: /(\n+)/,
        argSchema: Object, /* what is this ??? */
        //argSchema: { beforeAfter: 1 },
        //debugAt: 'lines'
    },
    typedHandlers: {
        bracket(node) {
            const {key, kwargs} = node
            if (bracketRef.hasOwnProperty(key)) {
                bracketRef[key](node, kwargs)
                node.assign({class: ''})

            } else {
                node.assign({class: key})
            }
        }
    },
    methods: {
        onNewline(context, value) {
            context.assign({
                style: {marginBottom: marginBottom(value)},
                spacerValue: value,
            })
        }
    },
    mounted() {
        mixin(StateContext, 'set', setAttr)
        /* define mixins explicitly */
    }
}
----------------------------------

[LineEdit2.js 07-17-2023]:
function buildParser(...args) {
    const spec = isObject(args[0])
        ? args[0]
        : {
              __postparse__: args[0] || identity,
              __parser__: isFunction(args[1]) ? args[1] : getBlocks,
              options: {
                  trackNewLines: args[1] === true ? true : false
              }
          }

    if (spec.options && spec.options.getBlocks) {
        const f = blockRef[spec.options.getBlocks] || getBlocks
        spec.__parser__ = f
    }
    if (spec.postParse) {
        spec.__postparse__ = spec.postParse
    }
    const lineEdit = new BaseLineEdit(spec)
    return lineEdit.run.bind(lineEdit)
}


let str1684180796 = `
    hi
        a
        asdf
            a = b
    bye
`
//console.log(base(str1684180796).toString())
----------------------------------

[pl-comprehensiveMarkdown.js 07-17-2023]:
function mdComprehensiveVue(node, component, env) {
    console.log(this); assert();
    messengerAssert(component)
    const data = {}
    const template = rep(node, /\$(\w+)/g, (x) => {
        data[x] = env[x]
        return x
    })
    console.log(collectDataKeysFromTemplate(template))
    component.name = 'VComprehensiveVueMarkdown'
    component.template = template
    component.data = data
    return component
}
----------------------------------

[pl-comprehensiveMarkdown.js 07-17-2023]:
function oxMarkdownVue(node, a, b) {
    throw new Error('not in use')
    /* ^(v-\S+) ?(.*) */
    console.log({a, b})
    return 
    const kwargs = getKwargs(b, 'equalSign')
    const props = reduce2(kwargs, (k, v) => {
        const items = split(v, '|')
        vd.setProps(a, k, items)
        const arg = `${k}Selection`
        return [':' + k, arg]
    })

    node.popValue() 

    function reducer(items) {
        return items
    }
    const data = reducer(map2(node.removeAllChildren(), 'value'))
    const key = camelSlice(a)
    const propKey = vd.assignData(key, data)

    node.assign({ 
        component: a,
        attrs: { ':value': propKey, ...props }
    })
}
----------------------------------

[setupComponent.js 07-18-2023]:
    const htmls = templates.map((template) => htmlBuilder(template))
    let template = '<p>Current Index: {{currentIndex}}</p>\n'
    template += '<p>Max Index: {{maxIndex}}</p>\n\n'

    htmls.forEach((html, i) => {
        template += wrapHtml('template', s, html)
    })
    
    template = wrapHtml('div', 'class="abcde"', template)
----------------------------------

[next.js 07-20-2023]:
class ChalkText {
    constructor() {
        this.s = ''
    }
    set(key) {
        const colors = {
            BLACK: '\x1b[30m',
            RED: '\x1b[31m',
            GREEN: '\x1b[32m',
            YELLOW: '\x1b[33m',
            BLUE: '\x1b[34m',
            RESET: '\x1b[0m',
            BRIGHT: '\x1b[1m',
            BOLD: '\x1b[1m',
        }
        if (isString(key) && key.toUpperCase() in colors) {
            this.s += colors[key.toUpperCase()]
        } else if (isPrimitive(key)) {
            this.s += key.toString()
        }
        else if (key) {
            
        }
        return this
    }
    reset() {
        return this.set('reset')
    }
    linebreak() {
        const s = `${'-'.repeat(20)}\n`
        this.set(s)
        //return this.wrap('bold', s)
    }
    wrap(a, b) {
        this.set(a)
        this.set(b)
        return this.reset()
    }
    delimited(...args) {
        this.linebreak()
        partition(flat(args)).forEach(([a,b]) => {
            this.wrap('blue', a)
            this.set(b)
            this.set('\n')
        })
        this.linebreak()
        return this
    }
    build() {
        const args = [
            1,2,3,4,5,6
        ]
        return this.delimited(args)
    }
    log() {
        console.log(this.s.trim())
    }
}
----------------------------------

[pl-htmlBuilder.js 07-22-2023]:
function oxImplicits(node, s, y) {
        /* ^(i-\S+) ?(.*) */
        const isHorizontal = y && y.includes('|')
        const children = isHorizontal
            ? split(s, '|')
            : node.popChildValues()
        const source = isHorizontal ? 'horizontal' : 'vertical'
        return htmlImplicitDirectionalRef[key](node, children, source, key)

        if (y && y.includes('|')) {
            const key = /horizontal/i.test(s)
                ? camelSlice(s) : 'horizontal' + capitalize(camelSlice(s))
                console.log(key)
            return htmlImplicitRef[key](node, y)
        }

        node.children.forEach((child) => {
            child.forceSkip = true
            child.requireAssignmentTouched = true
        })

        function getKey(s, ...refs) {
            const aliases = {
                'i-text': 'paragraphText',
            }
            if (aliases.hasOwnProperty(s)) {
                return aliases[s]
            }
            for (let ref of refs) {
                if (ref.hasOwnProperty(s)) {
                    return s
                }
                let a = camelSlice(s)
                if (ref.hasOwnProperty(a)) {
                    return a
                }
            }
        }

        const key = getKey(s, htmlInlineImplicitRef, htmlImplicitRef)
        return y
            ? htmlInlineImplicitRef[key](node, s, y)
            : htmlImplicitRef[key](node, s)
}
----------------------------------

[pl-htmlBuilder.js 07-22-2023]:
const htmlImplicitRef = {
    paragraphText(node, tag) {
        node.children.forEach((child) => {
            child.forceSkip = false
            child.requireAssignmentTouched = false
        })
    },
    label(node, children, source) {
        node.assign({ class: "aaa" })
        children.forEach((child, i) => {})
    },
    horizontalLabel(node, s) {
        node.assign({ class: "aaa" })
        const items = split(s, "|")
        items.forEach((item, i) => {
            const className = i == 0 ? "left" : "right"
            const data = {
                text: item,
                class: className
            }
            node.appendChild(data)
        })
    },
    verticalLabel(node, s) {
        node.assign({ class: s })
        node.children.forEach((child, i) => {
            const className = i == 0 ? "left" : "right"
            child.assign({
                value: "",
                text: child.value,
                class: className
            })
        })
    }
}
----------------------------------

[codeOrganizer.js 07-23-2023]:
function setExports(state, ...names) {
    const item = state.find({
        type: "export",
        createDefault: true
    })
    item.setExports(names)
    item.moveTo(-1)
    return item
}
----------------------------------

[c.js 07-24-2023]:
import pinyin from 'js-pinyin'
pinyin.setOptions({checkPolyphone: false, charCase: 0});
console.log(pinyin.getFullChars('管理员'));
console.log(pinyin.getCamelChars('管理员'));
----------------------------------

[codeOrganizer2.js 07-24-2023]:
    getItems() {
        this.items = this.lezer.getItems().map(this.create.bind(this)) 
    }
    getLezer() {
        const lezer = new Lezer3()
        lezer.load(this.text, this.file)
        this.lezer = lezer
    }
----------------------------------

[cm-inputHandler.js 07-24-2023]:
        switch (item.type) {
            case 'iab':
                return iabCompletion(item.value, cm, from, to)
            case 'dynamicSnippet':
                return dynamicSnippet(item.value, cm, from, to, node)
            case 'snippet':
                return staticSnippet(item.value, cm, from, to, cache)
            case 'fn':
            case 'function':
                return caller(item.value, cm, from, to)
        }
----------------------------------

[cm-inputHandler.js 07-25-2023]:
class HTMLCreate {
    constructor() {
    }
    run(template) {
        return function htmlCreate(completion) {
            console.log(completion)
            const el = document.createElement('div')
            el.innerHTML = Date.now()
            el.style.color = 'red'
        }
    }
}
----------------------------------

[utils.js 07-25-2023]:
const items = [
    {name: 'e', dep: ''},
    {name: 'a', dep: 'b'},
    {name: 'b', dep: 'c d'},
    {name: 'c', dep: 'e'},
    {name: 'd'},
]

const r = sortByDependencies(items, (x) => {
    const items = xsplit(x.dep)
    return items
})
console.log(r)
----------------------------------

[utils.js 07-26-2023]:
function f(s) {
    if (isString(s)) {
        console.log({s})
    }
    if (isNumber(s)) {
        return s + 3
    }
}
function checkpoint(x) {
    if (isString(x)) {
        return 
    }
    return true
}
//console.log(walk(['a',2, {a: 'a'}], f))
----------------------------------

[cm-next.js 07-26-2023]:
function inputQW(cm, dir = 1) {
    const line = cmLine(cm)
    const nextLine = cmLine(cm, line.number + 1)
    const indent = dir * 4
    const indentation = Math.max(
        0,
        line.indentation + indent
    )
    const pos = cmPos(cm)
    const insertion = '\n' + toSpaces(indentation)
    const anchor = pos + insertion.length
    return cmTextDispatch(cm, pos - 1, null, insertion, anchor)
}
----------------------------------

[cm-next.js 07-27-2023]:
function getRegexes() {
    const r = /^ *(?:const|let|var)? *(\w+)\s*=\s*(\/.*?\/[a-z]*)/gm
    const matches = sort(findall(r, s), (x) => x[1].length)
    return matches
}
----------------------------------

[cm-next.js 07-27-2023]:
//console.log(unique(readParse('class.js', cmPrepare(LoremEditorView, cmCollectText, 'RegExp'))).sort())
----------------------------------

[next.js 07-28-2023]:
class Booga {
    constructor() {
        this.foods = ['a', 'b', 'c', 'd', 'e']
        nextify(this, 'food')
    }
}
const c = new Booga()
console.log(c.nextFood())
console.log(c.nextFood())
console.log(c.nextFood())
console.log(c.nextFood())
console.log(c.nextFood())
----------------------------------

[cm3.js 07-28-2023]:
function baka(arg, color = 'blue', bold = true) {
    const style = `color: ${color}; font-weight: ${bold ? 'bold' : '400'}`

    const {caller, lineNumber} = getCaller2(-1)
    if (arg == null) {
        arg = lineNumber
    }
    if (isPrimitive(arg)) {
        console.log(`%c${caller}: ${stringify(arg)}`, style)
    } else {
        console.log(`%c${caller}:${lineNumber}`, style, arg)
    }
}
----------------------------------

[stylesheet-textarea.test.js 07-28-2023]:
window.onload = function () {
    const textarea = document.querySelector('textarea')
    const stylesheet = document.querySelector('style')
    textarea.focus()
    textarea.addEventListener('keydown', (e) => {
        stylesheet.innerHTML = e.target.value
    })
}
----------------------------------

[cm3.js 07-31-2023]:

    loadVueExtensions() {
        return 
        /* deprecated */
        const commands = this.spec.vue.$options.commands
        const vue = this.spec.vue
        const commandKeymap = createVueCommands(vue, commands)
        this.loadExtension("keymap", commandKeymap)
    }
----------------------------------

[cm3.js 07-31-2023]:
function createCodeEditorState(vue, key) {
    const computedKey = arguments.length == 2 ? key : vue.editorStateKey
    console.log({computedKey})

    const editorSpecs = {
        spec1: {
            completions: [],
            initialText: dunder,
            basicSetup: getBasicSetup
        }
    }
    const editorSpec = editorSpecs[computedKey]
    if (editorSpec) {
        editorSpec.vue = vue
        editorSpec.dynamicExtensions = createExtensionState(computedKey)
        return editorSpec
    }
}
----------------------------------

[next.js 08-01-2023]:
function evalThis(s, state) {
    const code = s.replace(/this/g, 'state')
    return evaluate2(code, {state})
}


class Fo {
    constructor() {
    }
    a(a) {
        return a + 'bb'
    }
    get geta() {
        return 'aa'
    }
}
const fo = new Fo()
console.log(evalThis('this.a(this.geta)', fo))
----------------------------------

[next.js 08-01-2023]:
const hodgepodgeString = `
    function htmlCtrlEnter() {
        this.sayhi()
        this.html = findall(/aa/, 'aabc')
        console.log(this)
    }
`
const fo = new Fo()
const fs = evalHodgePodge(hodgepodgeString, fo)
console.log(fs)
----------------------------------

[LineEdit2.js 08-02-2023]:
function getBlocks(s, spaces) {
    /*******************************
     * 05-09-2023 documentation:
     * This is a hack to group together child elements.
     *******************************/
    function makeRE(spaces, delimiter) {
        return RegExp(`^${" ".repeat(spaces)}${delimiter}`)
    }

    const atNamedRE = /^@(python|javascript) */
    const leafRE = /^(def|class|const|var|async|function) /
    const miscRE = /^(graph)/
    const callableRE = /^(\w+)\(/
    const bracketRE = /{$/
    const assignmentRE = /= *[\{\[]$/
    const ref = {
        function: {
            stop: "}",
            cont: "(def|class|const|var|async|function)",
        },
    }

    let store = []
    let m
    let count = 0

    if ((m = search(atNamedRE, s))) {
        const type = m
        const stopRE = makeRE(spaces, "-------------")
        const store = this.iterate(
            (line, newSpaces, count) => {
                if (count == 0) {
                    return line.replace(atNamedRE, "")
                }
                if (line && newSpaces < spaces) {
                    return false
                }
                if (stopRE.test(line)) {
                    return false
                }
                return line
            },
            this.index,
            true
        )

        return {
            type,
            value: smartDedent2(store),
        }
    } else if ((m = search(leafRE, s))) {
        const store = []
            let newlines
        while (true) {
            const block = getCodeBlock(this, spaces, m)
        	  store.push(...block)
            let a = this.index
            let info = this.getLineInfo(a)

            if (info == null) {
                break
            }
                else if (info.newlines) {
                    newlines = info.newlines
                } else {
                    m = search(leafRE, info.line)
                    if (m) {
                        for (let i = 0; i < newlines; i++) {
                            store.push('')
                        }
                        this.index = a
                    } else {
                        break
                    }
                }
                a++
        }
        return {
            type: "code",
            value: smartDedent2(store),
        }
    } 
    else if (m = search(callableRE, s)) {
        const block = getBlock(this, spaces, true, null, true)
        return {
            type: "callable",
            key: m,
            value: smartDedent2(block),
        }
    }
    else if ((m = search(assignmentRE, s))) {
        function assignmentFn(line, lineSpaces, originalSpaces) {
            //console.log({line, lineSpaces, originalSpaces})
            if (lineSpaces == originalSpaces && /^[\]\}]$/.test(line)) {
                return {offset: 1}
                //console.log('aaa')
                //return {changeIndex: -1}
            }
        }
        const block = getBlock2(this, spaces, assignmentFn)
        //console.log({block})
        return {
            type: "assignment",
            value: smartDedent2(block),
        }
    }
    else if ((m = search(bracketRE, s))) {
        const block = getBlock(this, spaces, true, 0, true)
        block.pop()
        const top = block.shift().replace(/ *{$/, '')
        const [key, b] = splitOnce(top)
        const kwargs = getKwargs2(b || '')
        return {
            type: "bracket",
            foo: [12],
            key,
            kwargs,
            value: smartDedent2(block),
        }
    } 

    else {
        return { value: s }
    }
}
----------------------------------

[LineEdit2.js 08-02-2023]:
function getBlock(state, spaces, emptyLinesOkay, offset, stopOnBracket) {
    const store = []
    while (state.index < state.size) {
        let info = state.getLineInfo(state.index++)
        if (info.line && info.spaces < spaces) {
            console.log("break because less spaces")
            break
        }

        if (info.newlines) {
            for (let i = 0; i < info.newlines - 1; i++) {
                store.push('')
            }
        }
        else {
            store.push(info.base)
        }

        let next = state.getLineInfo(state.index)
        if (next == null) {
            if (emptyLinesOkay) {

            } else {
                break
            }
        }
        if (stopOnBracket && info.spaces == spaces && info.line == '}') {
            break
        }
        if (
            info.line == "" &&
            next.spaces == spaces &&
            !/^[\]\}]$/.test(next.line)
        ) {
            break
        }
    }
    if (offset) {
        store.pop()
        state.index -= 1
    }

    return store
}
----------------------------------

[LineEdit2.js 08-02-2023]:
function getCodeBlock(state, spaces, delimiter) {
    const store = []
    const terminal = /async|function/.test(delimiter)
        ? jsBlockTerminal
        : /def/.test(delimiter)
        ? pythonBlockTerminal
        : varTerminal

    function varTerminal(info) {
        if (info.spaces == spaces && /^[}\]]$/.test(info.line)) {
            return true
        }
    }
    function pythonBlockTerminal(info) {
        if (info.spaces == spaces && store.length) {
            state.index--
            return true
            while (true) {
            	  if (getLast(store) == '') {
                    store.pop()
                    state.index--
                } else {
                    break
                }
            }
            return true
        }
    }

    function jsBlockTerminal(info) {
        if (info.spaces == spaces && info.line == '}') {
            store.push(info.line)
            return true
        }
    }
    while (state.index < state.size) {
        const info = state.getLineInfo(state.index++)
        if (terminal(info)) {
            break
        }

        if (info.newlines) {
            for (let i = 0; i < info.newlines - 1; i++) {
                store.push('')
            }
        } else {
            store.push(info.base)
        }
    }
    return store
}
----------------------------------

[LineEdit2.js 08-02-2023]:
function getBlock2(state, spaces, fn) {
    const store = []
    const startingIndex = state.index
    while (state.index < state.size) {
        let info = state.getLineInfo(state.index++)
        if (info.line && info.spaces < spaces) {
            break
        }

        if (info.newlines) {
            for (let i = 0; i < info.newlines - 1; i++) {
                store.push('')
            }
            continue
        }
        
        const m = state.index - 1> startingIndex && fn(info.line, info.spaces, spaces)
        if (m) {
            if (isObject(m)) {
                if (m.changeIndex) {
                    state.index += m.changeIndex
                }
                else if (m.append) {
                    const appends = toArray2(m.append)
                    const emptyLine = popEmptyLine(store)
                    appends.forEach((append, i) => {
                        store.push(' '.repeat(spaces) + append)
                    })
                    if (emptyLine) {
                        store.push('')
                    } else {
                        state.index--
                    }
                }
                else if (m.offset) {
                    //console.debug(store, state.index, state.getLine(state.index - 1), 'aaa')
                    if (m.offset < 0) {
                        for (let i = 0; i < m.offset; i++) {
                            store.pop()
                            state.index--
                        }
                    } else {
                        store.push(info.base)
                        for (let i = 1; i < m.offset; i++) {
                            store.push(state.getLine(++state.index))
                        }
                    }
                }
            }
            break
        } else {
            store.push(info.base)
        }
    }
    return store
}
----------------------------------

[utils.js 08-02-2023]:
let s = `
foo = {
    a: 1
}

afoo = {
    a: 1,
    b: {
        asadf: agetConstructorName(adsf a)
        aaaasadf: agetConstructorName(adsf a)
    }
}
asdf = 112
howdy asdf

`
let [astest, jsonConfig] = getOptions(s, 'extractStartingJsonLikeConfig')
console.log(jsonConfig)
----------------------------------

[next.js 08-02-2023]:
function evalHodgePodge(s, state) {
    const items = getJavascriptChunks(hodgepodgeString)
    return items.map(f)
    function f(s) {
        const fn = bringToLife(s)
        return {
            name: fn.name,
            topComment: topComment(s),
            bottomComment: bottomComment(s),
            fn: fn.bind(state),
        }
    }
}
----------------------------------

[next.js 08-02-2023]:
let str1690941884 = `
    
    name = asdfasdf asdfa sdfasdfasdf
    hi = asd
    bye = 1
    asdf = {
        asdf: 1
    }

    foogar
    foogar
    foogar
`
console.log(getStartingConfig(str1690941884))
----------------------------------

[utils.js 08-02-2023]:
function deepEqual(objA, objB, map) {
    if (!map) {
        map = new WeakMap()
    }
    if (Object.is(objA, objB)) return true
    if (objA instanceof Date && objB instanceof Date) {
        return objA.getTime() === objB.getTime()
    }
    if (objA instanceof RegExp && objB instanceof RegExp) {
        return objA.toString() === objB.toString()
    }
    if (
        typeof objA !== 'object' ||
        objA === null ||
        typeof objB !== 'object' ||
        objB === null
    ) {
        return false
    }

    if (map.get(objA) === objB) return true
    map.set(objA, objB)

    const keysA = Reflect.ownKeys(objA)
    const keysB = Reflect.ownKeys(objB)

    if (keysA.length !== keysB.length) {
        return false
    }

    for (let i = 0; i < keysA.length; i++) {
        if (
            !Reflect.has(objB, keysA[i]) ||
            !deepEqual(objA[keysA[i]], objB[keysA[i]], map)
        ) {
            return false
        }
    }

    return true
}
templater('{{aa}}', 'vv')
----------------------------------
<script type="module">
  import * as prettier from "https://unpkg.com/prettier@3.0.0/standalone.mjs";
  import prettierPluginBabel from "https://unpkg.com/prettier@3.0.0/plugins/babel.mjs";
  import prettierPluginEstree from "https://unpkg.com/prettier@3.0.0/plugins/estree.mjs";
  import prettierPluginHtml from "https://unpkg.com/prettier@3.0.0/plugins/html.mjs";

  console.log(
    await prettier.format("const html=/* HTML */ `<DIV> </DIV>`", {
      parser: "babel",
      plugins: [prettierPluginBabel, prettierPluginEstree, prettierPluginHtml],
    }),
  );
  // Output: const html = /* HTML */ `<div></div>`;
</script>
----------------------------------
[baseComponents.js 08-04-2023]:
var VPrompt = {
    name: "VPrompt",
    props: ["value"],
    template: `
        container show = internalValue
            p ref = asdf hi
            v-input ref = input @enter = emitEvent
            v-html :value = internalValue

    `,
    prompt(promptSpec) {
        const self = this
        self.internalValue = htmlBuilderFromVueObject(promptSpec)
        focus(self.$refs.input)

        return new Promise((resolve) => {
            self.$on("event", (value) => {
                self.$nextTick(() => {
                    self.internalValue = null
                    self.$refs.input.clear()
                    resolve(value)
                })
            })
        })
    }
}
----------------------------------

[pl-svgBuilder.js 08-14-2023]:
const svgSpec = {
    options: { getBlocks: true },
    typedHandlers: {
        callable(node) {
            if (node.key in svgCallableRef) {
                return svgCallableRef[node.key](
                    node,
                    node.popValue()
                )
            }
        },
        bracket(node) {
            if (node.key in svgBracketRef) {
                return svgBracketRef[node.key](
                    node,
                    node.popValue(),
                    node.kwargs
                )
            }
        }
    },
    onReturn1: svgReturn1,
    onReturn2: svgReturn2,
    leafAttributes,
    elementParser(s) {
        const [args, kwargs] = argKwargSplit(s)
        const key = camelCase(args.shift())

        const payload =
            key in svgElementRef
                ? svgElementRef[key](...args)
                : { value: s }

        for (let [a, b] of kwargs) {
            const value = { attrs: svgColon(a, b) }
            cumulativeSchemaAssign(payload, value, {
                transform: "merge"
            })
        }
        return payload
    }
}
----------------------------------

[pl-svgBuilder.js 08-14-2023]:
    //let m
    //if (m = search(/^for (.*?) in (\w+))) {
        
    //}
    //if (/^for \w+/.test(s)) {
        //return inlinePythonToJavascript(s)
    //}

This stuff has been moved to d3Blocks via LineEdit
----------------------------------

[pl-d3Builder.js 08-14-2023]:
function svgCode(node, value) {
    const fix = (s) => {
        const declarations = findall(/^ *(\w+) *=/gm)
        return prependCode(s, { declarations })
    }
    const data = new SVGData()
    const yline = (...args) => data.push("yl", ...args)
    const xline = (...args) => data.push("xl", ...args)
    const localContext = {
        data,
        tickHeight,
        yline,
        xline
    }
    const context = merge(localContext, state.context)
    bringToLife(fix(value), context)()
    const datum = data.toJSON()
    if (empty(datum)) return
    const aliases = {
        yline: "yl",
        xline: "xl"
    }
    const children = datum.map((item, i) => {
        const [rawKey, ...args] = item
        const fnKey = aliases[rawKey] || rawKey
        const fn = this[fnKey] || svgElementRef[fnKey]
        return fn(...args)
    })
    node.assign({ tag: "g" })
    node.appendChildren(children)
}
----------------------------------

[pl-d3Builder.js 08-14-2023]:
class SVGData {
    constructor() {
        this.arrayStore = []
        this.objectStore = {}
    }
    push(...args) {
        args.length == 1
            ? this.arrayStore.push(args[0])
            : this.arrayStore.push(args)
    }
    update(...args) {}
    toJSON() {
        return empty(this.arrayStore)
            ? this.objectStore
            : this.arrayStore
    }
}
----------------------------------

[pl-d3Builder.js 08-14-2023]:
function prependCode(code, o) {
    let s = ""
    if (exists(o.declarations)) {
        s += `let ${o.declarations}\n`
    }
    return code.trimStart().replace(/\n/, (x) => {
        "\n" + indent(s.trim())
    })
}
----------------------------------

[cm3.js 08-16-2023]:
    options: {
        useId: true,
    },
----------------------------------

[vimrc 08-16-2023]:
        if mode == 'edit' && !empty(g:saveTheFile) && !IsFile(name)
            call SaveTheFile(name)
        endif
----------------------------------

[cm-next.js 08-16-2023]:
function oldInputQWUp(cm) {
    oldInputQW UP
    /* review_it */
    ///* used in inputQW as upward */
    /* This does something ... but I am not sure what */
    const [line, prevLine] = cmGetLineAndPrevLine(cm)
    console.log({line, prevLine})
    if (prevLine.number == 1) {
        return cmDispatchText2(cm, prevLine.from, "\n")
    }
    const payload = "\n" + toSpaces(line.indentation - 4)
    return cmDispatchText2(
        cm,
        prevLine.from - 1,
        payload
    )
}
----------------------------------

[cm3.js 08-16-2023]:
    async create() {
        const promptSpec = {
            template: `

            prompt-container
                p:10
                border:green

                p hohoho from prompter
                    bg:g3
                p {{booga}}
            `,
            data: {
                booga: 123123
            }
        }


        const name = await this.$refs.prompter.prompt(promptSpec)
        const res = this.bufferManager.openBuffer(name)
        if (res === false) {
            return this.$refs.popup.popup('failed opening buffer')
        }

        this.codeEditor.focus()
    },

need to do this later
----------------------------------

[cm3.js 08-16-2023]:
    setup() {
        this.languages = Object.keys(languagePacks)
        this.themes = Object.keys(CMThemes)
        this.themes2 = Object.keys(ThemeMirrorThemes)
        this.toggables = ["lineNumber", "readOnly"]
        const wrapper = (state, key, value) => {
            state.update(key, value)
        }
        try {
            nextify(this, "language", "lang", wrapper)
            nextify(this, "theme", null, wrapper)
        } catch(e) {
            console.log("ERRORRRRRRRR", e.stack)
            console.log(this)
        }
    }

----------------------------------

[ma.js 08-18-2023]:
function isPalindrome(s) {
    return s == reverse(s.toString())
    s = s.toString()
    for (let i = 0; i < Math.min(s.length / 2); i++) {
        let a = s[i]
        let b = s[s.length - 1 - i]
        if (a != b) {
            return false
        }
    }
    return true
}
----------------------------------

[codeOrganizer2.js 08-18-2023]:
function moveMathUtilsToMathUtils2(state, outState) {
    outState.debug = 1
    const spec = {
        extendedType: 'class|function',
        notIn: outState.identifers,
        text: (s) => lineCount(s) <= 5,
    }
    const children = state.filter(spec)
    const names = children.map((x) => x.identifier)
    outState.addExports(names)
    return outState
    outState.append(children)
    outState.sort('identifier')
}
----------------------------------

[baseComponents.js 08-21-2023]:
var VDynamicRender = {
    name: "VDynamicRender",
    //props: ["componentKey", "componentProps", "value"],
    data() {
        return {
            componentProps: {},
            componentKey: ""
        }
    },
    render(h) {
        if (this.value) {
            return vueRenderer(this)
        }

        const component = window[this.componentKey]
        const options = {
            staticClass: "v-dynamic-render",
            props: this.componentProps,
            on: propagateForward(this)
        }
        return h(component, options)
    }
}
----------------------------------

[baseComponents.js 08-21-2023]:
function propagateForward(state) {
    return {
        onEnter(e) {
            state.$emit("onEnter", e)
        },
        onClick(e) {
            state.$emit("onClick", e)
        },
        onEvent(e) {
            state.$emit("onEvent", e)
        }
    }
}
----------------------------------

[turtle2.js 08-23-2023]:
function assignPos(child, x, y) {
    const types = [
        "Point",
        "Circle",
    ]
    const data = has(types, type(child)) ? {cx: x, cy: y} : {x,y}
    assignOnTop(child, 'attrs', {x, y})
}
import { scaleLinear } from "./math-utils.js"
----------------------------------

[utils.js 08-26-2023]:
function requireArg(arg) {
    const caller = getCaller3(-1)
    const text = bringToLife(caller).toString()
    const m = search(/requireArg\( *(.*?) *\)/, text)
    const message = `param {${m}} is a required arg @ fn:${caller}`
    warn(message)
}
----------------------------------

[pl-htmlBuilder.js 08-26-2023]:
        if (type(value) == "StateContext") {
            node.appendChild(value)
        } else if (
            isArray(value) &&
            type(value[0] == "StateContext")
        ) {
            node.appendChildren(value)
        }
----------------------------------

