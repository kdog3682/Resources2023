linebreak = '-' * 50
hammyfirebasehtml = "/home/kdog3682/FIREBASE/public/index.html"
localbackupdir= "/home/kdog3682/LOCALBACKUP/"
publishdir= "/home/kdog3682/PUBLISHED/"
firebasedir= "/home/kdog3682/FIREBASE/"
publicfirebasedir= "/home/kdog3682/FIREBASE/public"
latexdir = '/home/kdog3682/LATEX/'
alist = ['a', 'b', 'c', 'd']
glogfile = '/home/kdog3682/2023/log.json'
gunkExtensions = ['recent', 'mp3', 'ass', 'eps', 'zip', 'url', 'gz', 'backup', 'webp', 'asy', 'vcf', 'js']
pdfdir2 = "/home/kdog3682/PDFS2/"
archdir = "/mnt/chromeos/GoogleDrive/MyDrive/ARCHIVES/"
sshfile = "/home/kdog3682/.ssh/id_rsa.pub"
dir2023 =  "/home/kdog3682/2023/"
nodedir2023 = "/home/kdog3682/2023/node_modules/"
mathchadir = dir2023 + 'mathcha/'
githuburl = "https://github.com/"
drivedir = "/mnt/chromeos/GoogleDrive/MyDrive/"
outdir = "/mnt/chromeos/GoogleDrive/MyDrive/OUTBOUND/"
zipdir = "/mnt/chromeos/GoogleDrive/MyDrive/ZIP/"
gdocdir = "/mnt/chromeos/GoogleDrive/MyDrive/GDOC/"
backupdir = "/mnt/chromeos/GoogleDrive/MyDrive/BACKUP/"
dropboxdir = "~/DropBox"

pythondir = (
    "/home/kdog3682/.local/lib/python3.7/site-packages"
)

pythondir = "/home/kdog3682/PYTHON/"
javascriptdir = "/home/kdog3682/JAVASCRIPT/"
swiftdir = "/home/kdog3682/SWIFT-LATEX/"
htmlbudir = "https://drive.google.com/drive/folders/16gpifAlQhHxBHr3SP0IbRiwnGLwbmF59"
teachdir = "/home/kdog3682/TEACHING/"
vimdir = "/home/kdog3682/VIM & SH/"
nodedir = "/home/kdog3682/.npm-global/lib/node_modules/"
nodedir2023 = "/home/kdog3682/2023/node_modules/"
linebreak = "-" * 50
tododir = "/mnt/chromeos/GoogleDrive/MyDrive/TODO"
boadir = "/mnt/chromeos/GoogleDrive/MyDrive/TODO/BOA"
yearRE = "20(?:[012][0123456789])"
examdir = "/home/kdog3682/EXAMS/"
productiondir = "/home/kdog3682/PRODUCTIONS/"
productiondir = "/home/kdog3682/PRODUCTIONS/"
lezfile = "/home/kdog3682/.npm-global/lib/node_modules/@lezer/html/dist/index.cjs"
filelogfile = "/home/kdog3682/LOGS/today.log"
clipdir = "/home/kdog3682/CLIPS/"

lezerdir = (
    "/home/kdog3682/.npm-global/lib/node_modules/@lezer/"
)

pubnodedir = "/home/kdog3682/CWF/public/node_modules/"
cwfnodedir = "/home/kdog3682/CWF/node_modules/"
servernodedir = "/home/kdog3682/CWF/node_modules/"
svgdir = "/home/kdog3682/SVG/"

nodemodulesdir = (
    "/home/kdog3682/.npm-global/lib/node_modules/"
)

servedir = "/home/kdog3682/SERVER/"
gmailsenturl = "https://mail.google.com/mail/u/0/#sent"
gmailurl = "https://mail.google.com/mail/u/0/#inbox"
testpdf = "/mnt/chromeos/MyFiles/Downloads/test.pdf"

googleassignmentdir = (
    "/home/kdog3682/CWF/public/assignments"
)

ONE_MINUTE = 60
homedir = "/home/kdog3682/"
rootdir = "/home/kdog3682/"
dir2023images = dir2023 + 'images'
tempappscriptfile = "/home/kdog3682/appscript.temp.json"
tempfile = "/home/kdog3682/CWF/public/temp.json"
chifile = "/mnt/chromeos/GoogleDrive/MyDrive/JSONS/hsk-pinyin-dict.json"
nonutfe = ["ttf", "mp3", "gz", "gifv"]
clipfile = ".clip.js"
clipfile = "/home/kdog3682/2023/clip.js"
cvfile = "Kevin Lee Cover Letter.pdf"
resumefile = "Kevin Lee Resume.pdf"
jsdir = "/home/kdog3682/CWF/public/"
dldir = "/mnt/chromeos/MyFiles/Downloads/"
pdfdldir = dldir + 'PDFS/'
sandir = "/mnt/chromeos/removable/Sandisk/"

usbdir = "/mnt/chromeos/removable/"
usbdrivedir = "/mnt/chromeos/removable/USB Drive/"
pydir = "/home/kdog3682/PYTHON/"
pdfdir = "/home/kdog3682/PDFS/"
logdir = "/home/kdog3682/LOGS/"
oldtxtdir = "/home/kdog3682/TEXTS/"
txtdir = "/home/kdog3682/2023/TEXTS/"
jsondir = "/home/kdog3682/JSONS/"
emojifile = "/home/kdog3682/JSONS/emojis.json"
mathdir = "/home/kdog3682/MATH/"
picdir = "/home/kdog3682/PICS/"
colordir = "/home/kdog3682/COLORING/"
colordistdir = "/home/kdog3682/COLORING/dist/"
trashdir = "/home/kdog3682/TRASH/"
fontdir = "/home/kdog3682/CWF/public/fonts/"
jchdir = "/home/kdog3682/CWF/jch/"
pubdir = "/home/kdog3682/CWF/public/"
budir = "/mnt/chromeos/GoogleDrive/MyDrive/BACKUP/"
tempbudir = "/mnt/chromeos/GoogleDrive/MyDrive/BACKUP/TEMP/"

bucurdir = (
    "/mnt/chromeos/GoogleDrive/MyDrive/BACKUP/CURRENT/"
)

currentdir = dir2023

dirdict = {
    "root": rootdir,
    "math": mathdir,
    "home": rootdir,
    "js": jsdir,
    "html": jsdir,
    "py": pydir,
    "py": pythondir,
    "pdf": pdfdir,
    "txt": txtdir,
    "json": jsondir,
    "jpg": picdir,
    "jpeg": picdir,
    "png": picdir,
    "svg": picdir,
    "log": logdir,
    "dl": dldir,
    "dldir": dldir,
    "trash": trashdir,
    "fonts": fontdir,
    "dldir": dldir,
    "budir": budir,
    "current": dir2023,
    "dir2023": dir2023,
}

macdirdict = {
    "drive": "/users/harfunmaterials/Google Drive/",
    "outbound": "/users/harfunmaterials/Google Drive/OUTBOUND/",
}

olddirdict = {
    "bu": "/mnt/chromeos/GoogleDrive/MyDrive/BACKUP",
    "outbound": "/mnt/chromeos/GoogleDrive/MyDrive/OUTBOUND",
    "cwf": "/home/kdog3682/CWF",
    "root": "/home/kdog3682/",
    "jch": jchdir,
    "cwd": "/home/kdog3682/CWD",
    "pub": "/home/kdog3682/CWF/public",
    "root": "/home/kdog3682/",
    "a": "ASSETS",
    "drive": "/mnt/chromeos/GoogleDrive/MyDrive/",
    "drivecwf": "/mnt/chromeos/GoogleDrive/MyDrive/CWF",
    "0104": "/mnt/chromeos/GoogleDrive/MyDrive/CWF/01-04-2022",
    "dl": "/mnt/chromeos/MyFiles/Downloads/",
}

import regex as re
from pprint import pprint
from datetime import datetime, timedelta
import sys
import env
import os
import json
import webbrowser
import shutil
emptyBlockRE = "^ *(?:function )?\\w+\\(.*?\\) {\\s*},?"
callableRE = "^[a-zA-Z.]+\\([^\\n`]+$"
callableRE = "^[a-zA-Z]\w*(?:.\w+)*\\([^\\n`]*"

blockQuoteRE = (
    "^ *(?:let |)?\\w+ =\\s*(?<!\\)`[^]+?(?<!\\)`.*\\n?"
)

cwfdir = "/home/kdog3682/CWF/"
cdir = "/home/kdog3682/CWF/"
drivecwfdir = "/mnt/chromeos/GoogleDrive/MyDrive/CWF/"

drivedir0104 = (
    "/mnt/chromeos/GoogleDrive/MyDrive/CWF/01-04-2022/"
)

BROWSER_AGENT = "Mozilla/5.0 (X11; CrOS aarch64 13310.93.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/85.0.4183.133 Safari/537.36"

utfe = [
    "",
    "txt",
    "grammar",
    "drafts",
    "js",
    "py",
    "vim",
    "json",
    "css",
    "html",
    "math",
    "history",
    "ts",
    "vue",
    #"pdf",
]

imge = ["jpg", "jpeg", "png", "svg"]
fonte = ["ttf", "otf", "woff", "woff2"]
musice = ["m4a", "mp3", "mp4", "wav"]
macdir = "/users/harfunmaterials/"
drivedir = "/mnt/chromeos/GoogleDrive/MyDrive/"
original = print

def exists(x):
    t = type(x)
    if t == str:
        return x.strip() != ""
    if t == list:
        return len(x) > 0
    if t == dict:
        return len(x.keys()) > 0
    return x != None

def test(r, s, flags=0):
    if not isString(s):
        return
    return bool(re.search(r, s, flags))

def isPublicFile(x):
    if isIgnoredFile(x):
        return 0
    return test("^[a-zA-Z]|^\d+$", tail(x))

def isPrimitive(s):
    return isString(s) or isNumber(s)

def isFunction(x):
    return callable(x)

def isString(x):
    return type(x) == str

def isNumber(x):
    if isString(x):
        return test("^\d[.,\d]*$", x)
    return type(x) == int or type(x) == float

def isArray(x):
    return type(x) == list or type(x) == tuple

def isObject(x):
    return type(x) == dict

def head(f):
    return (
        re.sub("/$", "", str(f)).rsplit("/", maxsplit=1)[0]
        + "/"
    )

def tail(x):
    return re.sub("/$", "", str(x)).rsplit("/", maxsplit=1)[
        -1
    ]

def identity(s):
    return s

def getExtension(s):
    if "json.js" in s:
        return "json.js"
    return search("\.([a-zA-Z]+)$", s).lower()

def unique(a, b=None):
    if b:
        if isArray(a):
            return difference(a, b)
        if isObject(a):
            return filter(a, lambda k, v: k not in b)
    else:
        return list(set(a))

def difference(a, b):
    return list(set(a).difference(b))

def intersection(a, b):
    return list(set(a).intersection(b))

def toArray(x):
    if isArray(x):
        return x
    if isString(x):
        return split(x, "\n")
    return [x]

def every(items, fn):
    for item in list(items):
        if not fn(item):
            return False
    return True

def datestamp(x=None, strife="%m-%d-%Y"):
    if hasattr(x, 'created_utc'):
        x = x.created_utc
        strife = 'praw'
    elif isObject(x)  and x.get('created_utc'):
        x = x['created_utc']
        strife = 'praw'

    ref = {
        "/": "%m/%d/%Y",
        "-": "%m-%d-%Y",
        "human": "%A %B %d, %-I:%M:%S%p",
        "praw": "%m-%d-%Y %-I:%M:%S%p",
    }
    strife = ref.get(strife, strife)
    if isString(x):
        if isfile(x):
            x = mdate(x)
            return datetime.fromtimestamp(x).strftime(
                strife
            )
        return datetime.strptime(x, strife)
    if type(x) == float or type(x) == int:
        return datetime.fromtimestamp(x).strftime(strife)
    if type(x) == datetime:
        return x.strftime(strife)

    return datetime.now().strftime(strife)

def getLast(s):
    return s[-1]

def search(regex, item, flags=0):
    match = re.search(regex, item, flags)
    if not match:
        return ""
    if match.groups():
        if len(match.groups()) == 1:
            return match.groups()[0]
        return match.groups()
    return match.group(0)

def toNumber(x):
    return int(x) if isNumber(x) else x

def isUrl(s):
    return test("^http|www|\.(?:com|net|io|org)\\b", s)

def clear(x):
    if isfile(x):
        with open(x, "w") as f:
            pass

    elif isdir(x):
        rmdir(x, None, True)

def absdir(dir="."):
    if isArray(dir):
        return dir
    dir = abspath(dir)
    return [os.path.join(dir, f) for f in os.listdir(dir)]

def getCaller(n=0):
    from inspect import stack

    stack = stack()
    if n == -1:
        return stack[2][3]
    else:
        return stack[len(stack) - 2][3]

def filter(items, f=exists, *args, **kwargs):
    if not f:
        return items
    if isString(f):
        r = f
        f = lambda s: test(r, s)
    if isObject(items):
        return {k: v for k, v in items.items() if f(k, v)}
    else:
        if isArray(f):
            ignore = f
            f = lambda x: x not in ignore

        return [
            x for x in list(items) if f(x, *args, **kwargs)
        ]

def isfile(f):
    return os.path.isfile(abspath(f))

def isdir(f):
    return isString(f) and os.path.isdir(f)
    return os.path.isdir(os.path.expanduser(f))

def toSeconds(
    minutes=0, hours=0, seconds=0, days=0, weeks=0, months=0
):
    return (
        seconds
        + minutes * 60
        + hours * 3600
        + days * 3600 * 24
        + months * 3600 * 24 * 30
    )

def isRecent(file, before=0, after=0, **kwargs):
    if isNumber(file):
        n = int(file)
    elif isfile(file):
        n = mdate(file)
    else:
        return False

    if before:
        return n < dategetter(before)
    if after:
        return n > dategetter(after)

    seconds = toSeconds(**kwargs)
    currentTime = timestamp()
    lastAcceptableTime = currentTime - seconds
    if n > lastAcceptableTime:
        return True

def timestamp(x=int):
    if type(x) == datetime:
        return int(x.timestamp())
    if x == int:
        return int(datetime.now().timestamp())

def mdate(f):
    return int(os.path.getmtime(f))

def mostRecent(dir, n=1, reverse=0, **kwargs):
    from glob import glob

    files = glob(dir + "/*") if isString(dir) else dir

    if kwargs:
        files = filter(files, checkpointf(**kwargs))

    files.sort(key=mdate)

    if not files:
        return None
    if n == 1:
        return files[-1]
    elif isNumber(n):
        return files[-n:]
    else:
        if reverse:
            return files[-n:][::-1]
        else:
            return files[-n:]

def npath(dir=0, file=0):
    if not dir:
        return file
    elif not file:
        return os.path.join(os.getcwd(), dir)
    return os.path.join(dir, tail(file))

def normpath(dir, file):
    dir = abspath(dir) if isdir(dir) else head(dir)
    return os.path.join(dir, tail(file))

def abspath(file=None):
    if file == None:
        return os.path.expanduser("~/")
    elif file == ".":
        return os.getcwd()
    elif file.startswith("~"):
        return os.path.expanduser(file)
    elif file.startswith("./"):
        return os.path.join(os.getcwd(), file[2:])
    else:
        return os.path.abspath(file)

google_url = "https://google.com/"

def ofile(f):
    if hasattr(f, 'permalink'):
        return openBrowser('https://redd.it/' + f.id)
    return map(f, openBrowser)

def mfiles(files, dir, fn=0, ask=0):
    if isString(files):
        files = absdir(files)
    if not isdir(dir):
        dprompt('not a dir', dir, 'press a key to make it')
        mkdir(dir)

    if ask:
        prompt(files, 'move these files to', dir, '?')
    for f in files:
        if fn:
            dir = fn(dir + fn(tail(f)))
        mfile(f, dir)

def cfiles(files, dir, ask=0):
    if ask:
        prompt(files, tempbudir, 'are you sure you want to copy these files and overwrite existing files in the directory?')

    mkdir(dir)
    for f in files:
        cfile(f, dir)
    if ask:
        printdir(dir)

def cfile(f, t):
    mfile(f, t, mode="copy")

def mfile(f, t, mode="move"):
    assert isfile(f)
    if not getExtension(t) and not isdir(t):
        mkdir(t)
    elif not getExtension(t):
        t = normpath(t, f)

    if tail(f) == tail(t):
        print(mode, "file", tail(f), "to", head(t))
    else:
        print(f"{mode} file: {f} to {t}")

    if mode == "move":
        try:
            shutil.move(f, t)
            return 1
        except Exception as e:
            return 0
            pass

    elif mode == "copy":
        try:
            shutil.copy(f, t)
            return 1
        except Exception as e:
            return 0
            pass

def rfile(f):
    mfile(f, "/home/kdog3682/TRASH")

def cfile(f, t):
    if not getExtension(t):
        t = normpath(t, f)
    shutil.copy(f, t)
    print(f"copying file: {f} to {t}")

def cdir(dir, t):
    newDir = npath(t, dir)
    if isdir(newDir):
        if prompt("it is already a dir", newDir):
            return
    prompt(newDir)
    shutil.copytree(dir, newDir)
    print(f"copying directory: {newDir}")

def isMacbook():
    return not os.path.exists("/mnt")

def isCurrentDir(d):
    return abspath(os.getcwd()) == abspath(d)

def chdir(d, force=0):
    d = dirgetter(d)
    if not getExtension(d) and not isdir(d):
        if not force:
            prompt("mkdir?", d)
        mkdir(d)
    if isdir(d) and not isCurrentDir(d):
        print(f"changing to directory: {d}")
        os.chdir(d)

def prompt(*args, **kwargs):
    for arg in args:
        if arg:
            if isString(arg):
                print(arg)
            else:
                pprint(arg)
    if kwargs:
        pprint(kwargs)
    return input() or kwargs.get('fallback', '')

def isIgnoredFile(name):
    name = tail(name)
    ignore = [
        "vosk-api",
        "__pycache__",
        "node_modules",
        ".git",
    ]
    ignoreRE = "^(?:\W)"
    recursiveIgnoreRE = "^(?:LICNSE|README\.[mM][dD])$"
    return name in ignore or test(ignoreRE, name)

def fileInfo(f, r=0):
    if isfile(f):
        strife = "%A %B %d %Y, %-I:%M:%S%p"
        name = tail(f)
        date = datestamp(f, strife)
        size = fsize(f)
        return {
            "name": tail(f),
            "size": fsize(f),
            "date": date,
        }
    else:
        print(["not a file", f])

def dirgetter(dir=None):
    if not dir:
        return os.getcwd()
    return dirdict.get(dir, dir)
    return dirdict.get(dir, os.path.expanduser(dir))

    key = "macbook" if isMacbook() else "chromebook"
    dicts = {"macbook": macdirdict, "chromebook": dirdict}
    dict = dicts[key]

    dir = dict.get(dir, dir)
    assert isdir(dir)
    return dir

def number(items):
    for i, item in enumerate(items):
        print(i + 1, item)

def askToRemove(file):
    pprint(read(file))
    print(file)
    a = input()
    if a:
        rfile(file)

def fixBrowserPath(f):
    if not f:
        return 
    if isfile(f):
        return f
        prompt(f)
    aliases = {
        'red': 'reddit',
    }
    if f in aliases:
        return fixUrl(aliases[f])
    ref = {
        'json': [dldir, jsondir],
        'pdf': [dldir, pdfdir],
    }
    e = getExtension(f)

    if e:
        for dir in ref.get(e, []):
            temp = npath(dir, f)
            if isfile(temp):
                return temp
            raise Exception('cant find the file')


    if isUrl(f):
        return f

    return f"https://google.com/search?q={f}"
    

def openBrowser(f):
    if not f:
        return 
    f = fixBrowserPath(f)
    print(f"opening file: {f}")
    webbrowser.open(f)

def choose(x, mode=0, filter=0, auto=1):
    if isString(x) and isdir(x):
        x = absdir(x)
    else:
        x = list(x)
    if not isPrimitive(x[0]):
        mode = 1
    if auto and len(x) == 1:
        return x[0]

    if isString(x[0]) and isfile(x[0]):
        x = map(x, tail)
    a = prompt2(x)
    if not a:
        return
    if filter:
        while isWord(a):
            newList = [
                el
                for el in x
                if test(a, filter(el), flags=re.I)
            ]
            if newList:
                x = newList

            a = prompt2(x)

    if a == "x":
        return []

    value = None
    if not a:
        return x
    else:
        value = [
            x[int(n) - 1] for n in a.strip().split(" ")
        ]

    if value:
        if mode == 1:
            return value[0]
        if mode == 0:
            return unique(value)

def find(arr, fn, mode=None, flags=0):
    if isObject(arr):
        for k, v in arr.items():
            if fn in v:
                return os.path.join(k, fn)
        return

    for i, item in enumerate(list(arr)):
        if ftest(fn, item, flags=flags):
            return i if mode == int else item

def createKwargs(s):
    if not s:
        return {}

    dict = {
        "backup": "dir=pub after=8pm js=1 copy=bu",
        "i": "ignore",
        "budir": "dir=bu",
        "old": "old=1",
        "budir": "dir=bu",
        "pdfjson": "json=1",
        "root": "dir=root",
        "pdf": "pdf=1",
        "5pm": "after=5pm",
        "6pm": "after=6pm",
        "7pm": "after=7pm",
        "8pm": "after=8pm",
        "9pm": "after=9pm",
        "10pm": "after=10pm",
        "11pm": "after=11pm",
        "midnight": "after=12am",
        "noon": "after=12pm",
        "1pm": "after=1pm",
        "2pm": "after=2pm",
        "3pm": "after=3pm",
        "4pm": "after=4pm",
        "pub": "dir=pub",
        "cwf": "dir=cwf",
        "dl": "dir=dl",
        "c": "copy",
        "cp": "copy",
        "debug": "mode=debug",
        "open": "mode=open",
        "o": "mode=open",
        "d": "mode=debug",
        "n": "name",
        "r": "mode=review",
        "today": "date=today",
        "t": "text",
        "ye": "date=yesterday",
        "sm": "small=2000",
        "this": "date=today",
        "tf": "testfunction",
        "mv": "move",
        "of": "onlyFiles=1",
        "h": "html",
        "i": "mode=info",
        "s": "mode=save",
        "big": "big=100000",
    }
    s, quote = mreplace('"(.*?)"', s)
    s = dreplace(s, dict, template="(?<![\w=])(?:$1)\\b")
    regex = "(\S+?) *= *(\S+?)(?= |$)"
    s, items = mreplace(regex, s)
    f = lambda x: int(x) if isNumber(x) else x

    items1 = {k: f(v) for k, v in items}
    items2 = {a: 1 for a in split(s, " ")}
    items1.update(items2)
    if quote:
        items1["text"] = quote[0]
    return items1

def configurable(fn):
    def wrapper(s="", **bargs):
        if s:
            s += " of"
        kwargs = createKwargs(s)
        kwargs.update(bargs)
        return fn(**kwargs)

    return wrapper

def sort(x, f=int, reverse=0):
    if isObject(x):
        return {
            k: v
            for k, v in sorted(
                x.items(),
                key=lambda item: f(item[1]),
                reverse=reverse,
            )
        }
    else:
        return sorted(list(x), key=f, reverse=reverse)

def append(f, s):
    if f.endswith('.json'):
        return appendjson(f, s)
    if isObject(s):
        s = s.values()

    value = toString(s)

    if value:
        with open(f, "a") as _:
            _.write("\n" + value)
            print(f"appending file: {f}")

def fixUrl(s):
    s = re.sub("(?:https://)?view-source:", "", s)
    if "." not in s:
        s += ".com"
    if not test("^http", s):
        s = "https://" + s
    return s

def getDomainName(url):
    return re.sub("(?<!/)/\w.*$", "", fixUrl(url))

def downloadWebsite(url):
    chdir(pubdir)
    downloader = lambda x: write(
        tail(x), request(x), open=1
    )
    domainName = getDomainName(url)

    s = request(url)

    def runner(x):
        m = x.group(1)
        if m.startswith("/"):
            m = os.path.join(domainName, m[1:])

        # print(m)
        # downloader(m)
        return quote(tail(m))

    regex = "['\"]" + "(\S+\.(?:js|css))" + "['\"]"
    s = re.sub(regex, runner, s)
    write("index.html", s, open=1)

def toNumber(x):
    if isNumber(x):
        return int(x)
    return x

def toString(x):
    return str(x) if isPrimitive(x) else join(x)

def gatherArgs(args):
    if isArray(args[0]):
        return args[0]
    return args

def join(*args, delimiter="\n"):
    if not args:
        return ""

    if not args[0]:
        return ""

    s = ""
    for item in gatherArgs(args):
        if isArray(item):
            item = join(item)
        s += item
        s += "\n\n" if "\n" in item else delimiter

    return backspace(s) if delimiter else s

def moveClipToLogJson(key):
    value = clip()
    logger(key=key, value=value)

def logger(**kwargs):
    if not kwargs:
        return 

    from collections import OrderedDict
    store = OrderedDict()
    store['action'] = getCaller()
    store['date'] = datestamp()
    entries = sort(kwargs.items(), lambda x: len(json.dumps(x)))
    for a,b in entries:
        store[a] = b

    appendjson(glogfile, store, mode=list)

def backup(f):
    if isArray(f):
        assert every(f, isfile)
        dirName = budir + prompt('Creating new Directory: Name for the back-up directory (it will be located in drive/budir)?')
        cfiles(f, dirName)
        logger(action='backup', dirName=dirName, files=f)
    elif isfile(f):
        shutil.copy(f, npath(budir, f + ".backup"))
    elif isdir(f):
        return print('no dirs yet')

    print("backed up", f)

def backspace(s):
    return s[:-1]

def camelCase(s):
    s = uncapitalize(s.strip())
    s = re.sub("[- .](\w)", lambda x: x.group(1).upper(), s)
    return s

def decode(x):
    return x.decode("utf-8")

def node(*args):
    return system("node", *args)

class CD:
    def __init__(self, newPath=None):
        if not newPath:
            newPath = os.getcwd()
        self.newPath = os.path.expanduser(newPath)

    def __enter__(self):
        self.savedPath = os.getcwd()
        os.chdir(self.newPath)

    def __exit__(self, etype, value, traceback):
        os.chdir(self.savedPath)

def quote(s):
    return (
        '"""\n' + s.strip() + '\n"""'
        if "\n" in s
        else '"' + s + '"'
    )

def some(items, x):
    for item in items:
        if ftest(x, item):
            return True

def addExtension(s, extension="py", force=0):
    if not s:
        return ""
    return (
        s
        if getExtension(s) and force == 0
        else s + "." + extension
    )

def ftest(f, arg, flags=0):
    if isArray(f):
        return every(f, lambda f: ftest(f, arg))
    if isString(f):
        return test(f, arg, flags=flags)
    if isFunction(f):
        return f(arg)
    return True

def handleError(e):
    print([getCaller(), "error", str(e)])

def rigidSort(items, order, f=identity):
    order = {k: i for k in order}
    items.sort(key=lambda x: order[f(x)])
    return items

def breaker(n=10):
    global a
    a += 1
    if a >= n:
        raise Exception()

def _setup_chromebook():
    os.system("clear")
    print("Install Pip Libraries")

def _cleanup_base():
    # cleanup base.py
    # uses globals() to organize everything

    from inspect import getsource

    lib = globals()
    preset = {"pprint": "from pprint import pprint"}

    f = testf("^__", 0, 1)
    keys = filter(list(lib.keys()), f).sort()
    keys.sort()

    def f(key):
        v = lib.get(key)
        t = type(v)
        if t == str:
            s = f"{key} = '{str(v)}'"
            name = "primitives"
        elif t == int or t == float:
            s = f"{key} = {str(v)}"
            name = "primitives"
        elif t == module:
            s = str(v)
            name = search("<module '([\w-]+)'", s)
            if name == key:
                s = f"import {name}"
            else:
                s = f"import {key} as {name}"
            name = "modules"

        elif key in preset:
            name = "modules"
            s = preset[key]
        else:
            s = getsource(v)

        if name:
            pass
        elif test("^_", s):
            name = "apps"
        elif t == type:
            name = "classes"
        elif t == function:
            name = "functions"

        storage.add(name, s)

    storage = Storage()
    map(keys, f)
    items = storage.store.items()
    order = [
        "modules",
        "primitives",
        "functions",
        "classes",
        "apps",
    ]
    rigidSort(items, order, lambda x: x[0])
    s = ""
    for k, v in items:
        v.sort()
        s += join(v)
        s += "\n\n"
    return s
    breaker(3)

def testf(r, flags=0, reverse=0):
    if reverse:
        return lambda x: not test(r, x, flags)
    else:
        return lambda x: test(r, x, flags)

def rmdir(dir, force=0, create=0):
    if (
        len(os.listdir(dir)) < 10
        and absdir(dir) not in dirdict.values()
    ):
        shutil.rmtree(dir)
        print("removing dir", dir)

    elif (
        len(os.listdir(dir)) == 0
        or force
        or prompt("rmdir for sure?")
    ):
        shutil.rmtree(dir)
        print("removing dir", dir)

    if create:
        mkdir(dir)

quoteRE = "(?<!\\)'.*?(?<!\\)'|(?<!\\)\".*?(?<!\\)\""

def mkdir(dir):
    if isdir(dir):
        print("dir alrady exists. early return")
        return dir
    elif getExtension(dir):
        raise Exception("dir has an extension...")
    else:
        os.makedirs(dir)
        print(f"creating new directory: {dir}")
        return dir
        return True

def write(f, s, open=0):
    try:
        _write(f, s, open)
    except Exception as e:
        print(e)
        return
        dir = head(f)
        mkdir(dir)
        _write(f, s, open)

def _write(f, s, _open=0):
    if not exists(s):
        return
    e = getExtension(f)

    if e == "json.js":
        name = camelCase(removeExtension(tail(f)))
        value = createVariable(name, stringify(s), "js")
        with open(f, "w") as _f:
            _f.write(value)
        # log(file = f)

    elif e == "recent":
        with open(f, "w") as _f:
            if isString(s):
                _f.write(s)
            else:
                json.dump(s, _f, indent=2)

    elif e == "json":
        with open(f, "w") as _f:
            json.dump(s, _f, indent=2)
    else:
        with open(f, "w") as _f:
            _f.write(toString(s))

    print(f"writing file: {f}")
    if _open:
        ofile(f)

def uncapitalize(s):
    return re.sub(
        "[a-zA-Z]", lambda x: x.group(0).lower(), s, count=1
    )

def lineCount(s):
    return len(re.findall("\n", s))

def stringify(x):
    if type(x) == bytes:
        return x.decode()
    if isPrimitive(x):
        return str(x)
    return json.dumps(x, indent=4)

def removeComments(s, e=None):
    raise Exception()
    js = "(?://|/\*[\w\W]+?\*/)"
    html = "<!--[\w\W]*?-->"
    start = "^ *"
    end = ".*\n+"

    if not e:
        if test(html, s):
            e = "html"

        elif test(js, s):
            e = "js"

    r = start + locals().get(e, "js") + end
    return re.sub(r, "", s, flags=re.M)

def removeExtension(s):
    return re.sub("(?:\.json)?\.\w+$", "", s)

def createVariable(name, s, lang="py"):
    if test("^(fun|def|class)", s):
        return s
    prefix = "var " if lang == "js" else ""
    if not name:
        name = "PLACE_HOLDER"
    if isString(s) and not isJsonParsable(s):
        s = quote(s)
    s = stringify(s)
    return prefix + name + " = " + s

def unidecode(s):
    from unidecode import unidecode

    return unidecode(s)

def wrap(a, b="()"):
    dict = {
        "()": ["(", ")"],
        "[]": ["[", "]"],
        "{}": ["{", "}"],
    }
    a, c = dict.get(b, [b, b])
    return f"{b}{a}{c}"

def templater(template, ref):

    if isString(ref):
        ref = [ref]
    regex = "\$(\w+)"

    def parser(x):
        if isArray(ref):
            return ref[int(x) - 1]

        if isObject(ref):
            return ref.get(x)

        if isFunction(ref):
            return ref(x)

    def runner(x):
        return parser(x.group(1))

    return re.sub(regex, runner, template)

def map(items, fn, *args, filter=1, **kwargs):
    if not items:
        return []
    if isString(fn):
        _key = fn
        if isObject(items[0]):
            fn = lambda x: x.get(_key)
        else:
            fn = lambda x: search(_key, x)
    if isNestedArray(items):
        return [fn(a, b) for a, b in items]

    if isObject(items):
        store = {}
        for k, v in items.items():
            value = fn(k, v)
            if value:
                store[k] = value
            elif filter:
                continue
            else:
                store[k] = v
        return store

    store = []
    for item in toArray(items):
        try:
            value = fn(item, *args, **kwargs)
            if not (filter and not value):
                store.append(value)
        except Exception as e:
            prompt(item, error='ERROR AT MAP', message=e)
            continue
    return store

def raw(f):
    with open(f, "rb") as f:
        return str(f.read())

def read(file):
    e = getExtension(file)
    mode = "rb" if e in imge else "r"
    try:
        with open(file, mode) as f:
            return json.load(f) if e == "json" else f.read()
    except Exception as error:
        return None

def snakeCase(s):
    return re.sub(
        "([a-z])([A-Z])",
        lambda x: x.group(1) + "-" + x.group(2).lower(),
        s,
    )

def pop(x, key):
    if isNumber(key):
        return x.pop(key)
    elif isArray(x):
        return x.pop(x.index(key))
    else:
        return x.pop(key, None)

def parseJSON(x):
    if isString(x):
        x = x.strip()
    try:
        return json.loads(x) if isJsonParsable(x) else x
    except Exception as e:
        prompt(text=x)
    

def isJsonParsable(x):
    return isString(x) and test("^[{\[]", x)

def request(url, delay=0):
    from requests import get

    if delay:
        import time
        time.sleep(delay)

    r = get(fixUrl(url), {"user-agent": BROWSER_AGENT})
    return parseJSON(r.text) if r.status_code == 200 else ""

def stringcall(fn, args):
    f = lambda x: int(x) if isNumber(x) else quote(x)
    return fn + "(" + ", ".join(map(args, f)) + ")"

def clip(s=0, name=0):
    presetClipFiles = ["reddit", "booga"]
    if s == 2:
        return parseJSON(read(jsdir + "clip2.js"))
    if s in presetClipFiles:
        return read(clipdir + s + ".json")

    n = None
    if isNumber(s):
        n = s
        s = None

    if not s:
        data = parseJSON(normRead(clipfile))
        if isArray(data) and n:
            return data[0:n]
        return data
    if isString(s) and isdir(s):
        s = os.listdir(s)
    if s:
        write(name or clipfile, stringify(s), open=1)

def googleYouTubeVideosFromUrl():
    url = "https://www.youtube.com/watch?v=qNgZxjJBey4&ab_channel=Mario%27sMathTutoring"
    url = re.sub(
        "watch\?.+?channel=(.*?)",
        lambda x: "c/" + x.group(1),
        url,
    )
    url = re.sub("%\d+", "", url)
    data = request(url)
    id = search('externalId.*?(\w.*?)"', data)
    clip(id)

def mergefiles(s):
    return join(map(s, read))

def split(s, r=" ", flags=0):
    if r == 'linebreak':
        flags = re.M
        r = '^----+'

    return map(
        filter(re.split(r, s.strip(), flags=flags)), trim
    )

def trim(s):
    return s.strip()

def splitonce(s, r=" "):
    if isArray(s):
        return [s[0], s[1:]]
    return force(re.split(r, s, maxsplit=1))

def force(arr, n=2):
    while len(arr) < n:
        arr.append("")
    return arr

def fsize(f):
    return os.path.getsize(f)

def isRemovableFile(file):
    removeRE = "\\bboo\\b|debug|dela|foo|\(|^-?\d+$"
    removeList = ["log", "aux", "mhtml", "tex", "zip"]
    e = getExtension(file)
    size = fsize(file)

    return (
        (e and size < 100)
        or test(removeRE, tail(file))
        or e in removeList
        or e == "js"
        and size < 100
        or size == 0
        or (e == "json" and size < 1000)
    )

def getArgsKwargs(s):
    r = "(\w+) *= *(\S+?)(?= |$)"
    s, kwargs = mreplace(r, s)
    args = split(s, " ")
    return args, {k: v for k, v in kwargs}

def dategetter(s, mode=int):
    today = datetime.today()
    year = today.year
    day = 1
    value = 0

    if s == True:
        value = today.replace(minute=today.minute - 10)
    elif test("^\d", s):
        a, b, c = search('(\d+):?(\d*) *([ap]m)?', s, flags=re.I)
        print(a, b, c)
        offset = 0 if test("am", s, flags=re.I) else 12
        hour = int(a) + offset
        minute = int(b)
        #date = datetime()
        day = (
            today.day - 1
            if today.hour < hour
            else today.day
        )
        value = today.replace(
            day=day, hour=hour, minute=minute, second=0
        )
        #strife = "%A %B %d, %-I:%M:%S%p"
        #print(datestamp(value, strife))
        #return
    elif s == "yesterday":
        value = today.replace(day=today.day - 1)
    elif s == "today":
        value = today
    elif s == "month":
        value = today.replace(day=1)

    return int(value.timestamp()) if mode == int else value

def isSameDate(date, f):

    fdate = datetime.fromtimestamp(mdate(f))
    date = dategetter(date, None)
    return date.day == fdate.day

def checkpointf(
    contains=0,
    deleteIt=0,
    include="",
    size=0,
    maxLength=0,
    image=0,
    today=0,
    flags=re.I,
    files=0,
    gif=0,
    weeks=0,
    month=0,
    old=0,
    ignore="",
    ignoreRE="",
    css=0,
    js=0,
    py=0,
    txt=0,
    html=0,
    pdf=0,
    date=0,
    name=0,
    big=0,
    r=0,
    antiregex=0,
    small=0,
    before=0,
    after=0,
    minLength=0,
    minutes=0,
    days=0,
    hours=0,
    regex=0,
    public=0,
    math=0,
    text=0,
    lib=0,
    log=0,
    onlyFiles=0,
    isf=0,
    isp=0,
    onlyFolders=0,
    biggerThan=0,
    smallerThan=0,
    fn=0,
    e=0,
    json=0,
    **kwargs,
):
    if size:
        biggerThan = size
    if text:
        onlyFiles = 1
    if isf:
        onlyFiles = 1
    if r:
        name = r
    extensions = kwargs.get("extensions", [])
    if kwargs.get("isdir"):
        onlyFolders = 1
    if log:
        extensions.append("log")
    if math:
        extensions.append("math")
    if css:
        extensions.append("css")
    if js: extensions.append("js")
    if json: extensions.append("json")
    if py:
        extensions.append("py")
    if txt:
        extensions.append("txt")
    if html:
        extensions.append("html")
    if pdf:
        extensions.append("pdf")
    if gif:
        extensions.append("gif")
    if image:
        for e in imge:
            extensions.append(e)
    if isArray(e):
        extensions.extend(e)
    elif e:
        extensions.append(e)

    if old:
        hours = 24 * 30
    elif days:
        hours = days * 24
    elif weeks:
        hours = 24 * 7 * weeks
    elif month:
        hours = 24 * 30
    elif today:
        hours = 12

    if include:
        print("deleting")
        include = xsplit(include, "\s+")
    if ignore:
        ignore = xsplit(ignore, "\s+")
    if deleteIt:
        isp = 1

    def runner(f):
        filename = tail(f)

        if fn and not fn(f):
            return False

        if include and filename in include:
            return True
        if ignore and filename in ignore:
            return False
        if isp and filename.startswith("."):
            return False
        if deleteIt and alwaysDelete(f):
            rfile(f)
            return False
        if regex and not test(regex, filename, flags=flags):
            return False
        if antiregex and test(antiregex, filename, flags=flags):
            return False

        if name and not test(name, filename, flags=flags):
            return False

        e = getExtension(filename)

        if text and e == 'pdf':
            return False

        if extensions and e not in extensions:
            return False

        if hours and not isRecent(f, hours=hours):
            return False

        if not lib and isLibraryFile(f):
            return False

        if public and not isPublicFile(f):
            return False

        if onlyFiles and isdir(f):
            return False

        if contains:
            if not isdir(f):
                return True
            gn = lambda x: getExtension(x) == contains
            files = filter(os.listdir(f), gn)
            if len(files) < 5:
                print(f, 'has some files but not enuf of ', contains)
                return False
            return True

        if onlyFolders:
            if isdir(f):
                return 1
            return False

        if maxLength and isString(f) and len(f) > maxLength:
            return False

        if minLength and isString(f) and len(f) < minLength:
            return False

        if biggerThan and fsize(f) < biggerThan:
            return False
        if smallerThan and fsize(f) > smallerThan:
            return False
        if small and fsize(f) > small:
            return False
        if big and fsize(f) < big:
            return False
        if ignoreRE and test(ignoreRE, filename, flags=re.I):
            return False
        if text and not test(text, read(f), flags=flags):
            return False
        if date and not isSameDate(date, f):
            return False
        return True

    return trycatch(runner)

def trycatch(fn):
    def runner(*args, **kwargs):
        try:
            return fn(*args, **kwargs)
        except Exception as e:
            print("hiiiiiiiiiii", str(e), *args)
            raise Exception()
            return

    return runner

def mreplace(r, s, **kwargs):
    store = []

    def runner(x):
        if x.groups():
            store.append(
                x.group(1)
                if len(x.groups()) == 1
                else x.groups()
            )
        else:
            store.append(x.group(0))

        return ""

    text = re.sub(r, runner, s, **kwargs).strip()
    return text.strip(), store

def flat(items, depth=None):
    def runner(items, limit=0):
        for item in items:
            if isArray(item) and (
                not depth or limit < depth
            ):
                runner(item, limit + 1)
            else:
                store.append(item)

    store = []
    runner(items)
    return store

def changeExtension(s, e, unique=False):
    # if isArray(s):
    # return map(s, lambda x: changeExtension(x, e, unique))

    def incrementName(s):
        count = 1
        while isfile(s):
            count += 1
            s = re.sub("(?=\.)", str(count), s)
        return s

    name = re.sub("(?:\.\w+)?$", "." + e, s, count=1)
    if unique:
        name = incrementName(name)
    return name

def capitalize(s):
    return s[0].upper() + s[1:]

def getfiles(dir, recursive=0, mode=dict, sort=0, **kwargs):

    if recursive and not mode == list:
        mode = dict

    checkpoint = checkpointf(**kwargs)

    def runner(dir):
        store = []
        files = absdir(dir)
        for file in files:
            name = tail(file)

            if isIgnoredFile(name):
                continue

            elif isfile(file):
                if checkpoint(file):
                    if mode == dict:
                        store.append(name)
                    else:
                        output.append(file)
            elif isdir(file) and recursive:
                runner(file)

        if mode == dict:
            if sort:
                store = map(
                    store, lambda x: os.path.join(dir, x)
                )
                if sort == datestamp:
                    store = {
                        tail(f): datestamp(f)
                        for f in sorted(store, key=mdate)
                    }
                else:
                    store.sort()
            output[dir] = store

    output = {} if mode == dict else []
    runner(dirgetter(dir))
    return output

def printdir(dir=dldir, printIt=0):
    dir = dirgetter(dir)
    files = os.listdir(dir)
    size = len(files)
    if size < 30:
        files = map(files, lambda f: normpath(dir, f))
        pprint(map(files, fileInfo))
    else:
        pprint(sorted(files))

    dprint(size, dir)
    if printIt:
        clip(files)
    return files

NCG_TEMPLATE_LIBRARY = {
    "b": "\\b(?:$1)\\b",
}

def reWrap(dict, template = ''):
    ref = {
        '': '(?:$1)',
        'b': "\\b(?:$1)\\b",
    }
    template = ref.get(template, template)
    keys = list(dict.keys() if isObject(dict) else dict)
    symbols = map(keys, re.escape)
    s = "|".join(symbols)
    return re.sub('\$1', s, template)

def ncg(template, ref):
    if not template:
        template = "(?:$1)"
    if NCG_TEMPLATE_LIBRARY.get(template):
        template = NCG_TEMPLATE_LIBRARY.get(template)
    s = "|".join(list(ref.keys()))
    r = template.replace("$1", s)
    return r

def dreplace(s, dict, flags=0, template=''):

    regex = reWrap(dict, template)
    def parser(x):
        value = (
            dict.get(x.group(1))
            if x.groups()
            else dict.get(x.group(0))
        )
        if None == value:
            prompt(dreplace_error=x)
        return value

    return re.sub(regex, parser, s, flags=flags)

def execute(s):
    if isfile(s):
        e = getExtension(s)
        if e == "py" and not tail(s) == "base.py":
            print(f"executing file: file{s}")
            s = read(s)
        else:
            return

    try:
        if test("\n|^\w+ \w+", s.strip()):
            return exec(s)
        else:
            return eval(s)
    except Exception as e:
        handleError(e)

def toKwargs():
    ref = {
        "ds": "doubleSided",
        "c": "copies",
        "ls": "landscape",
    }
    f = lambda x: ref.get(x)
    # s = "ds c ls"
    s = input("input  ")
    args = {k: 1 for k in map(split(s), f)}
    return args

def partitionByFunction(arr, f):
    store = [[], []]
    for item in arr:
        if f(item):
            store[0].append(item)
        else:
            store[1].append(item)
    return store

def partition(arr, n=2):
    if isString(n):
        n = testf(n)
    if isFunction(n):
        return partitionByFunction(arr, n)

    store = []
    for i in range(0, len(arr), n):
        store.append(arr[i : i + n])
    return store

class Partitioner:
    def run(self):
        while len(self) > 0:
            done = self.partition()
            if done:
                break

    def __len__(self):
        return len(self.keys)

    def toJSON(self):
        return self.inputs

    def __init__(self, items, dest=0):
        self.defaultDest = dest
        self.inputs = {}
        if isArray(items):
            self.keys = items
        elif isObject(items):
            self.items = items
            self.keys = list(self.items.keys())

        self.storage = Storage()
        self.run()

    def partition(self):
        number(self.keys)
        pprint(self.storage.store)
        a, b = splitonce(
            input("write s and destination\n\n")
        )
        if not a and not b:
            return 1
        elif b:
            destination = a
            self.lastDestination = destination
            s = b
        elif hasattr(self, "lastDestination"):
            destination = self.lastDestination
            s = a
        elif self.defaultDest:
            destination = self.defaultDest
            s = a
        else:
            destination = prompt("write a destination")
            s = a

        self.inputs[destination] = s
        store = []
        items = unique(split(s))

        for item in items:
            if "-" in item:
                a, b = item.split("-")
                for item in range(int(a), int(b) + 1):
                    value = self.keys[int(item) - 1]
                    store.append(value)

            elif isNumber(item):
                value = self.keys[int(item) - 1]
                store.append(value)

            else:
                values = filter(
                    self.keys, testf(item, re.I)
                )
                store.extend(values)

        for key in store:
            pop(self.keys, key)
            self.storage.add(destination, key)

class Storage:
    def toJSON(self):
        return self.store

    def __repr__(self):
        return stringify(self.store)

    def __init__(self):
        self.store = {}

    def add(self, k, v):
        if not v:
            print("return")
            return
        if k in self.store:
            self.store[k].append(v)
        else:
            self.store[k] = [v]

def includef(items):
    return lambda x: x not in items

def edit(o, fn):
    if isObject(o):
        store = {}
        for k, v in o.items():
            value = fn(k, v)
            if value == None:
                value = v
            store[k] = value
        return store

    if isArray(o):
        for i, item in enumerate(o):
            o[i] = fn(o[i]) or item
        return o


def self():
    return sys.argv[0]


def isWord(s):
    return test("^[a-zA-Z]+$", s)

def inferlang(s):
    if isString(s) and len(s) <= 4 and isWord(s):
        return s
    if s in utfe:
        return s
    if getExtension(s):
        return getExtension(s)
    match = search(
        "^(?:\{|\[]\$|mkdir|touch|cd|npm|touch|function|def|<|\.|let|var|const)",
        s,
        flags=re.M,
    )
    ref = {
        "[": "json",
        "{": "json",
        "touch": "npm",
        "mkdir": "npm",
        "cd": "npm",
        "$": "npm",
        "touch": "npm",
        "nano": "npm",
        "var": "js",
        "let": "js",
        "function": "js",
        "const": "js",
        "def": "py",
        "<": "html",
        ".": "css",
    }
    return ref.get(match)

def jspy(lang, key):
    lang = inferlang(lang)

    namePY = "^(?:\w+(?= )|(?<=def |class )\w+)"
    nameJS = (
        "^(?:(?:async )?function|def|class|const) ([\w\$]+)"
    )
    callablePY = "\w\w\w+\.(?!log|toString)[a-z]\w+(?=\()"
    callablePY = "[\w\.]{8,}(?=\()"
    callableJS = (
        "new \w+|\w\w\w+\.(?!log|toString)[a-z]\w+(?=\()"
    )
    # variableJS = '(?:const )?\w+ = (?:.+?[^\[\{](?=\n)|[\w\W]+?\n[\]\}])'
    variableJS = "^(?:const )?\w+ = \w.+"
    cleanupJS = "^(?:const )?\w+ = \w.+"
    cleanupJS = "^\w+(?:\.\w+)*\(.+"
    cleanupPY = "^(?:const )?\w+ = \w.+|^(?:new \w+|\w\w\w+\.(?!log|toString)[a-z]\w+\().+"
    variablePY = "\w+ = (?:.+[^\[\{]|[\w\W]+?\n[\]\}]"
    commentJS = "// "
    commentPY = "# "
    functionJS = "(?:(?<=\n)|^)(?:(?:async )?function|class) \w+\\b[\w\W]+?\n}(?=\n|$)"
    functionJS = "(?:(?<=\n)|^)(?:const [\w\$]+ = [\[\{][\w\W]+?\n[\]\}]|(?:(?:async )?function|class) [\w\$]+\\b[\w\W]+?\n})(?=\n|$)"
    functionPY = (
        "^(?:@.+\n)*(?:def|class) \w+\\b[\w\W]+?(?=\n\S)"
    )

    functionBodyJS = (
        "^(?:(?:async )?function|class) [\w\W]+\n}"
    )
    functionBodyPY = "^(?:def|class) [\w\W]+(?=\n\S+)"

    codeJS = "(?:(?<=\n)|^)(?:(?:(?:async )?function|class) \w+\\b|const \w+ *= *[\[\{])[\w\W]+?\n[\]\}]"
    codePY = "^(?:def|class) [\w\W]+(?=\n\S+)"
    linebreakJS = (
        "/* ------------------------------------- */"
    )
    linebreakPY = "# -------------------------------------"

    indexes = ["js", "py", "vim", "bash", "css", "html"]

    ref = {
        "compiler": ["node", "python3", None, "bash"],
        "runtime": ["node", "python3", None, "bash"],
        "const": ["const ", "", "let"],
        "callableRE": [callableJS, callablePY],
        "nameRE": [nameJS, namePY],
        "functionRE": [functionJS, functionPY],
        "functionBodyRE": [functionBodyJS, functionBodyPY],
        "commentRE": [commentJS, commentPY],
        "superComment": ["//// ", "#### "],
        "//": ['//', '#'],
        "variableRE": [variableJS, variablePY],
        "cleanupRE": [cleanupJS, cleanupPY],
        "codeRE": [codeJS, codePY],
        "linebreak": [linebreakJS, linebreakPY],
        "comment": [commentJS, commentPY],
    }

    value = ref[key][indexes.index(lang)]
    return value

def prepend(file, content):
    write(file, content + "\n\n" + read(file))

def getFunctionName(s):
    rA = "^(?:@.+\n)*(?:(?:async )?function|def|class|const|var|let) ([\w\$]+)"
    rB = "^([\w\$]+) ="
    return search(rA, s) or search(rB, s)

def getFunctionNames(s):
    r = "^(?:(?:async )?function|class|def) ([\w\$]+)"
    return unique(re.findall(r, textgetter(s), flags=re.M))

def textgetter(x):
    if len(x) > 100:
        return x
    if isUrl(x):
        return request(x)
    if isfile(normDirPath(x)):
        return normRead(x)
    return x

def functiongetter(x, lang=None):
    regex = jspy(lang or x, "functionRE")
    matches = re.findall(regex, textgetter(x))
    return {getFunctionName(item): item for item in matches}

def isLibraryFile(f):
    name = tail(f)
    return name in env.js_libraries or ".min" in name

def reduce(items, fn):
    store = {}

    if isObject(items):
        for k, v in items.items():
            value = fn(k, v)

            if not value:
                continue
            elif isArray(value) and len(value) == 2:
                store[value[0]] = value[1]
            else:
                store[k] = value

    else:
        for item in list(items):
            value = fn(item)

            if not value:
                continue
            elif isArray(value) and len(value) == 2:
                store[value[0]] = value[1]
            else:
                store[item] = value

    return store

def hasLookAround(s):
    return test("\(\?\<", s)

def btest(r, s):
    return test("\\b" + r + "\\b", s, flags=re.I)

def curpath():
    print(abspath(os.getcwd()))

def filegetter(s):
    if s.endswith("files.txt"):
        try:
            data = read(s)
            files = split(data, "\n+")
            number(files)
            return files
        except Exception as e:
            return []






class RequestLimiter:
    def __init__(self, limit=10, sleep=60, maximum=100_000):
        self.count = 0
        self.cycles = 0
        self.maximum = maximum
        self.limit = limit
        self.sleep = sleep
        import time

    def get(self, *args, **kwargs):
        if self.count > self.maximum:
            return

        if self.count == self.limit:
            self.count = 0
            self.cycles += 1
            time.sleep(self.sleep)
            print(self.cycles, "cycles")
        else:
            self.count += 1

        return request(*args, **kwargs)

def srequest(url):
    if isRecent("request.temp.txt", minutes=20):
        print("returning recent file")
        return read("request.temp.txt")

    s = request(url)
    write("request.temp.txt", s, open=1)
    return s

def finder(url, term):
    s = srequest(url)
    templates = [
        "(?:b)>$1</(?:b)",
        "(?:name|value) *= *[\"']$1[\"']",
    ]

    for template in templates:
        r1 = templater(template, term)
        a1 = search(r1, s)
        if a1:
            r = r1.replace(term, "([\w-.]+)")
            m = rf(r, s)
            write("found.json", m, open=1)
            return m

def hasNewline(s):
    return "\n" in s

def regexjoin(*args):
    return "|".join(list(args))

def findall(r, text):
    def parser(s):
        if isArray(s):
            s = smallify(filter(s))
        return s

    m = re.findall(r, text)
    return [parser(x) for x in m]

def smallify(items):
    return items[0] if len(items) == 1 else items

RegexLib = {
    "caps": "[A-Z_]{3,}+\d*",
}

def getPureHtml(s):
    import bs4
    return bs4.BeautifulSoup(s, "html.parser").get_text()

def regexdiv(
    tag, attrs=0, content="[\w\W]+?", after="", before=""
):
    content = parens(content)
    attrs = " " + attrs + ".*?" if attrs else "[\w\W]*?"
    return f"<{tag}{attrs}>{before}{content}{after}</{tag}>"

def parens(s):
    return f"({s})"

def shellescape(s):
    dict = reverse(env.shellescapedict)
    regex = reWrap(dict)
    def parser(x):
        value = (
            dict.get(x.group(1))
            if x.groups()
            else dict.get(x.group(0))
        )
        if not value: prompt(x=x, error='shellescape')
        return 'zz' + value

    return re.sub(regex, parser, s)


def shellunescape(s):
    if not isString(s):
        return s
    if 'zz' not in s:
        return s
    s = dreplace(s, shellescapedict, template="zz($1)")
    return parseJSON(s)

def isMovie(s):
    return s.endswith("MOV")


def partitionByDate(files):
    files = sort(files, mdate, reverse=1)
    lastDate = timestamp()
    for file in files:
        date = mdate(file)

def toRoot(s):
    return rootdir + tail(s)

def itest(r, s):
    return test(r, s, flags=re.I)

def newlineIndent(x):
    s = join(x)
    return "\n" + re.sub("^", "    ", s, flags=re.M) + "\n"

def toCallable(f, *args):
    if not f:
        return ""
    if test("^\w+\(", f):
        return f
    payload = ", ".join(map(filter(args), toStringArgument))
    return f + parens(payload)

def toStringArgument(s):
    if isString(s):
        return quote(s)
    return json.dumps(s)

def dumpJson(payload):
    if isString(payload):
        return payload
    return json.dumps(payload)



def mimeTypeFromFile(file):
    return env.mimetypes[getExtension(file)]

def upcomingDate(day, mode=0, strife="/", next=0):
    day = capitalize(day)
    today = datetime.now()

    def increment():
        nonlocal today
        today = today + timedelta(days=1)

    while 1:
        weekday = env.weekdays[today.weekday()]
        if weekday == day:
            if next:
                today = today + timedelta(weeks=next)
            if mode == list:
                return [today.month, today.day, today.year]
            if mode == datetime:
                return today
            return datestamp(today, strife=strife)
        else:
            increment()

def dirFromFile(f):
    if f.startswith("/"):
        return head(f)
    e = getExtension(f)
    if e == 'py': return pydir
    return dir2023
    #return dirdict.get(e, pubdir)

def dirFromFile2(f):
    e = getExtension(f)
    if e == 'py': return pydir
    return dir2023

def removeDateStamp(s):
    datestampRE = "\d+[-/]\d+[-/]\d+"
    return re.sub("-?" + datestampRE, "", s)

def isRecentFile(f, days=1, **kwargs):
    return isfile(f) and isRecent(f, days=days, **kwargs)



def noDots(x):
    def runner(x):
        return re.sub("(?<=/)\.(?=[^/]+$)", "", x)

    if isString(x):
        return runner(x)
    return map(x, runner)

def deleteFiles(files, save=0, title=0):
    map(files, mfile, trashdir)
    if save:

        def infoRunner(f):
            return [tail(f), datestamp(f)]

        info = map(files, infoRunner)
        payload = prettyTable(info, title=title)
        happend(save, payload)
        print("Finished deleting files")






def changeFileName(file, newName=0, dir=0):

    if not newName: newName = prompt(file, "new name?")
    head, tail = os.path.split(file)
    if dir: head = dir

    if isFunction(newName):
        newName = newName(removeExtension(tail))

    newName = addExtension(newName, getExtension(tail))
    return os.path.join(head, newName)


def isUtf(file):
    return getExtension(file) in utfe

def isImage(file):
    return getExtension(file) in imge

def isPrivateFile(f):
    return tail(f).startswith(".")

def alwaysDelete(f):
    deleteList = [".clip.js", "passwords.csv"]
    keepList = ['scratchpad.txt', 'notes.txt']
    deleteRE = 'view-source|released-items|\\bboo\\b|debug|dela|foo|\(|^-?\d+$'
    deleteExtensions = ["log", "aux", "mhtml", "tex", "zip"]
    name = tail(f)
    if isPrivateFile(f):
        return False
    if name in keepList:
        return False
    if name in deleteList:
        return True
    if test(deleteRE, name, flags=re.I):
        return True 
    if fsize(f) < 20:
        return True
    if getExtension(f) in deleteExtensionsList:
        return True

deleteExtensionsList = [
    "gif",
    "wav",
    "ts",
    "ggb",
    "zip",
    "matchcha",
    "m4a",
]


def currentFile():
    return sys.argv[0]

def isRemovablePdfFile(f):
    name = tail(f)[0:-4]
    if len(name) < 4 or test("sdf|asd|\(\d", name):
        return 1

def isWebsite(url):
    from requests import get

    return get(url).status_code == 200

#webbrowser.open(googleSearchQuery(s))

def rnl():  # name: renameLastFile
    f = glf()
    print(f)
    s = input("new name: ")
    mfile(f, changeFileName(f, s))

#pprint(read(glf()))


def mget(r, s, flags=0, mode=dict):
    store = []

    def parser(x):
        if x.groups():
            store.append(
                x.group(1)
                if len(x.groups()) == 1
                else x.groups()
            )
        else:
            store.append(x.group(0))

        return ""

    s = re.sub(r, parser, s, flags=flags).strip()

    if mode == list:
        return [s.strip(), store]
    if mode == str:
        if not store:
            config = ""
        else:
            config = store[0]
        return [s, config]

    if not store:
        config = {}
    elif isNestedArray(store):
        config = {k: v for k, v in store}
    else:
        config = {k: True for k in store}

    return s, config

def isNestedArray(x):
    return isArray(x) and exists(x[0]) and isArray(x[0])

def smartRead(file):
    dirs = unique(list(dirdict.values()))
    for dir in dirs:
        f = os.path.join(dir, file)
        if isfile(f):
            return pprint(read(f))


def delta(a, b):
    return abs(a - b)

def getFilesByTimeStamp():
    files = mostRecent(dldir, 10, js=1, css=1)
    files.reverse()

    last = 0
    store = []

    for file in files:
        date = mdate(file)
        if last == 0 or delta(date, last) < ONE_MINUTE:
            store.append(file)
            last = date
        else:
            return store

def moveFilesByTimeStamp():
    return map(getFilesByTimeStamp(), mfile, jsdir)

def filePicker(dir, key="open"):
    items = (
        dir
        if isArray(dir)
        else sorted(absdir(dirdict.get(dir)), key=mdate)
    )
    files = choose(items)

    if key == "open":
        map(files, ofile)
    elif key == "rename":
        for file in files:
            mfile(
                file,
                changeFileName(
                    file, input(file + "\nnew name? ")
                ),
            )

    else:
        print(files[0])
        return files[0]

def h(data=0):
    hfile = normpath(jsondir, "temp.json")
    if data:
        write(hfile, data, open=1)
    else:
        return read(hfile)

def unzip(file, to):
    import zipfile

    with zipfile.ZipFile(file, "r") as z:
        z.extractall(to)

class DrivePrep:
    def __init__(self, files, debug=0):
        self.files = map(
            files, lambda f: normpath(dldir, f)
        )
        self.dir = outdir
        self.debug = debug

    def __enter__(self):
        if self.debug:
            return
        map(self.files, cfile, self.dir)

    def __exit__(self, *args):
        if self.debug:
            return

        print("done exiting")
        printdir(self.dir)
        emptydir(self.dir)
        printdir(self.dir)

def ranger(a):
    return list(range(a[0], a[1] + 1))


def prompt2(x):
    os.system("clear")
    number(x)
    a = input("choose 1 based indexes or regex\n\n")
    return a

def findFile(f):
    dirs = unique(dirdict.values())
    store = []
    for dir in dirs:
        file = npath(dir, f)
        if isfile(file):
            size = fsize(file)
            if size > 10:
                print('valid')
                print(size)
                print(file)
                return file


def shell(cmd):
    os.system(cmd)


def normDirPath(file):
    dir = dirFromFile(file)
    return npath(dir, file)

def normFactory(fn):
    def lambdaNorm(file, *args, **kwargs):
        return fn(normDirPath(file), *args, **kwargs)

    return lambdaNorm

normOpen = normFactory(openBrowser)
normWrite = normFactory(write)
normRead = normFactory(read)
normAppend = normFactory(append)

def moveToAppropiateDir(name=0):
    file = glf()
    name = changeFileName(file, name)
    path = normpath(dirFromFile(file), name)
    mfile(file, path)


htmlRE = "(?:[\"']|&quot;)(https.*?)(?:\"|&quot;|')"
urlRE = "http.+"

def plf():
    write(".foooooo", glf(), open=1)


def extracter(r):
    store = []
    for item in h():
        name = search(r, item)
        if name:
            store.append(name.strip())
    clip(store)

localfiledict = {}
localfiledict["t2"] = "test2.html"
localfiledict["tt"] = "temp.html"
urldict = {}

urldict[
    "cle"
] = "https://newyork.craigslist.org/search/edu#search=1~list~0~0"

urldict[
    "cwt"
] = "https://docs.google.com/spreadsheets/d/1Y3KRa7m3Nc8Z9ZGnKDFflGl5mldGBcosY1XIBYMF_Uo/edit#gid=1470853595"

urldict[
    "wea"
] = "https://www.google.com/search?q=weather&rlz=1CACCBQ_enUS943US943&oq=weather&aqs=chrome.0.69i59j35i39j46i131i199i433i465i512j0i131i433i512j0i67i131i433i457j0i402l2j69i61.541j1j7&sourceid=chrome&ie=UTF-8"

urldict["r"] = "reddit"
urldict["mc"] = "https://www.mathcha.io/editor"
urldict["gmail"] = "gmail.com"
urldict["red"] = "reddit"

def vimFileOpener(arg=0, cf=0):
    file = cf
    if arg in urldict:
        file = fixUrl(urldict[arg])
    elif arg in localfiledict:
        file = toLocalFile(arg)
    elif arg in list(localfiledict.values()):
        file = toLocalFile(arg)
    elif isUrl(arg) or getExtension(arg):
        file = arg
    elif arg:
        file = googleSearchQuery(arg)
    openBrowser(file)

def isPdf(s):
    return isString(s) and getExtension(s) == "pdf"

def googleSearchQuery(s):
    s = s.replace(" ", "+")
    return f"https://google.com/search?q={s}"

def revertFile(name=None):
    dir = localbackupdir
    print("getting file from dir:", dir)
    file = os.path.join(dir, name) if name else  mostRecent(dir)
    todir = dirFromFile(tail(file))
    newName = prompt(fileInfo(file, r=1), dir=dir, todir=todir)
    if newName:
        todir = npath(todir, addExtension(newName, getExtension(file)))
        prompt(outpath=todir)
    cfile(file, todir)

    return 
    print("getting file from budir", budir)
    file = mostRecent(budir)
    dir = dirFromFile(tail(file))
    prompt(fileInfo(file, r=1), dir)
    cfile(file, dir)

def writeBuffer(name, data):
    with open(name, "wb") as f:
        f.write(data)
    print("writing name", name)

def parseGoogleDate(s):
    return s[5:10] + "-" + s[0:4]


def unescapeHtml(s):
    import html

    return html.unescape(s)


def javascript(file, *args):
    file = npath(jsdir, addExtension(file, "js"))
    response = SystemCommand("node", file, *args)
    if response.error:
        return -1

def isJson(f):
    return getExtension(f) == "json"


def changeLastJsonFileToJavascriptAsset():
    name = glf()
    assert isJson(name)
    data = json.dumps(read(name))
    name = camelCase(tail(name))
    s = "var " + name + " = " + data
    normAppend("json.js", s)


def linegetter(s, trim=1, fn=0, filter=0, u=0):
    s = splitOnWord(s, "breaker")
    s = re.sub('^ *#.+\n+', '', s, flags=re.M)
    lines = re.split("\n+", smartDedent(textgetter(s)))
    if trim:
        lines = map(lines, lambda x: x.strip())
    if filter:
        lines = [x for x in lines if filter(x)]
    if fn:
        lines = map(lines, fn)
    if u:
        lines = unique(lines)
    return lines

def smartDedent(s):
    s = re.sub("^ *\n*|\n *$", "", s)
    if test("^\S", s):
        return s
    spaces = search("^ *(?=\S)", s, flags=re.M)
    secondLineSpaces = search("\n *(?=\S)", s)
    if (
        not spaces
        and secondLineSpaces
        and len(secondLineSpaces) > 4
    ):
        return re.sub(
            "^" + secondLineSpaces[5:], "", s, flags=re.M
        ).trim()

    return re.sub("^" + spaces, "", s, flags=re.M).strip()


def lowerCase(s):
    return s.lower()

def filterTwice(items, ref):
    a = []
    b = []
    for item in items:
        if item in ref:
            a.append(item)
        else:
            b.append(item)
    return [a, b]

def addWordsToDictionaryf(s, corpus=None):
    known = normRead("known.json") or []
    s = textgetter(s)
    words = unique(
        map(re.findall("\\b[a-zA-Z]{2,}\\b", s), lowerCase)
    )
    words = filter(words, known)
    if not corpus:
        corpus = normRead("corpus.json")

    knownWords, unknownWords = filterTwice(words, corpus)

    determined = {}
    undetermined = []

    for word in unknownWords:
        a = prompt(word)
        if a:
            determined[word] = a
        else:
            undetermined.append(word)

    appendjson(normDirPath("known.json"), knownWords)
    appendjson(normDirPath("words.json"), determined)
    appendjson(
        normDirPath("undetermined.json"), undetermined
    )


def push(store, data=0):
    if not data:
        return 
    elif isArray(data):
        store.extend(data)
    else:
        store.append(data)

def appendjson(file, data, mode=0):
    if not data:
        return
    placeholder = [] if mode == list else {}
    store = readjson(file, placeholder)

    if mode == list and not isArray(store):
        store = [store]

    if isArray(store):
        push(store, data)
    elif isObject(store):
        store.update(data)

    #return pprint(stringify(store)) #debugAppendJson
    write(file, store, open=1)

def readjson(file, placeholder={}):
    if isfile(file):
        with open(file) as f:
            return json.load(f)
    else:
        return placeholder


def rangeFromString(s, offset=1):
    if isArray(s):
        return s

    def f(s):
        if "-" in s:
            a, b = split(s, " *- *")
            store = []
            for i in range(int(a), int(b) + 1):
                store.append(i - offset)
            return store
        elif s == "x":
            return None
        else:
            return [int(s) - offset]

    return flat(map(split(s, ", *| +(?=\w)"), f, filter=0))

def zulustamp(date):
    return date.strftime("%Y-%m-%dT%H:%M:%SZ")

def hms():
    return datetime.now().strftime("%c")
    return datetime.now().strftime("%H:%M:%S")

def flatdir(dir):
    files = getfiles(dir, recursive=1, mode=list)
    map(files, mfile, dldir)
    rmdir(dir)
    return map(files, lambda x: npath(dldir, x))

def dread(name):
    return read(dldir + addExtension(name, "json"))

def dwrite(name, data):
    write(dldir + addExtension(name, "json"), data, open=1)

def getPokemonData():
    store = []
    for i in range(1, 151):
        url = "https://pokeapi.co/api/v2/pokemon/" + str(i)
        data = request(url)
        types = [
            el.get("type").get("name")
            for el in data.get("types")
        ]
        name = data.get("name")
        store.append(
            {
                "name": name,
                "types": types,
            }
        )
        print("okay", i)

    print(len(store))
    dwrite("pokemon", store)

def toVariable(a, b):
    return a + " = " + dumpJson(b)
    prefix = "var"
    return prefix + " " + a + " = " + dumpJson(b)

def createPokemonTemplateComponents(amount=1):
    data = dread("pokemon")
    store = []

    def g(x):
        # local attrs
        attr, value = x.groups(1)
        attrs[attr] = {"default": value}
        return ":" + attr + '="' + attr + '"'

    def f(x):
        # local name
        styleString = (
            ' class="'
            + "pokemon"
            + "-icon\" :style=\"{'width': size + 'px', 'height': size + 'px'}\""
        )
        s = x.group(0)
        s = re.sub(
            ' *(xml).*?".*?"', styleString, s, count=1
        )
        s = re.sub(' *(ver).*?".*?"', "", s, count=1)
        # s = re.sub('(width|height|viewbox).*?"(.*?)"', g, s, count=3, flags=re.I)
        return s

    for n in range(1, amount + 1):

        name = data[n - 1].get("name")
        name = camelCase(name)
        attrs = {
            #'name': {'default': name},
            "size": {"default": "100"},
        }
        s = decode(
            read("pokemon-svg/svg/" + str(n) + ".svg")
        )
        # s = re.sub('[\w\W]+?(?=<g)', '', s, count=1)
        s = re.sub("[\w\W]+?(?=<svg)", "", s, count=1)
        s = re.sub("[\w\W]+?>", f, s, count=1)
        # s = re.sub('</svg>\s*$', '', s, count=1)
        #'template': '<template>' + s + '</template>',
        payload = {
            #'name': name,
            "props": attrs,
            "template": s,
        }
        # s = toVariable(name, payload)
        store.append(payload)

    clip(join(store))


def renameClipFile():
    f = input("rename clip file as?")
    mfile(
        normDirPath(clipfile),
        normDirPath(addExtension(f, "js")),
    )

def downloadPdfsFromUrl(url=None):
    if not url:
        url = input("url? ")
    s = request(url)
    domain = getDomainName(url)
    r = "href=['\"]?(\S+?(?:\.pdf|view))"
    m = unique(re.findall(r, s))
    for file in m:
        name = tail(file)
        if isfile(examdir + name):
            continue
        try:
            data = request(domain + file)
            if len(data) < 10000:
                print("is small", file)
                continue
            write(examdir + name, data)
        except Exception as e:
            print("error", name)
            pass

dpdf = downloadPdfsFromUrl

def googleId(s):
    return search("d/(.*?)/", s) or s


def upcomingDateObject(s):
    date = upcomingDate(s, datetime)
    string = datestamp(date, "/")
    array = [date.month, date.day, date.year]
    dueDateObject = date + timedelta(days=8)
    dueDate = {
        "month": dueDateObject.month,
        "day": dueDateObject.day,
        "year": dueDateObject.year,
    }

    dueTime = {
        "hours": 1,  # 9PM
        "minutes": 0,
        "seconds": 0,
    }

    scheduledDate = date.replace(
        hour=9, minute=0, second=0, day=date.day + 0
    )
    currentDate = datetime.now()

    if scheduledDate.day == currentDate.day:
        scheduledTime = None
    else:
        scheduledTime = zulustamp(scheduledDate)

    return {
        "array": array,
        "string": string,
        "dueDate": dueDate,
        "dueTime": dueTime,
        "scheduledTime": scheduledTime,
    }

def cleanupFileName(fileName, date=0, prepend=0):
    if prepend:
        fileName = prependFilePath(tail(fileName), prepend)
    fileName = appendFileName(fileName, date)
    return removeExtension(fileName)

def appendFileName(file, payload=""):
    if not payload:
        return file
    if test("^\.", payload):
        space = ""
    else:
        space = " "
    if test("\.\w+$", file):
        s = re.sub(
            "(?=\.\w+$)", space + payload, file, count=1
        )
    else:
        s = file + space + payload
    return s

def prependFilePath(file, payload):
    if payload:
        payload = capitalize(payload + " ")
    else:
        return file
    head, name = os.path.split(file)
    r = "(?<=(^(?:[a-zA-Z]+ *\d+ +)))"
    if test(r, name):
        return re.sub(r, payload, name)
    return os.path.join(head, payload + name)


def nodemon():
    chdir(servedir)
    s = nodedir + "nodemon/bin/nodemon.js"
    runjs(s + " " + "server.js")


path = "/home/kdog3682/CWF/public/notes.txt"

def hrefRE(s, e=0):
    if e:
        s += "\." + e
    r = "href=['\"]?" + parens(s)
    return r

def foo():
    chdir(dldir)
    url = "view-source:https://commons.wikimedia.org/wiki/Category:SVG_chess_pieces"
    r = hrefRE("[/\w:_]+", "svg")
    domain = getDomainName(url)
    m = unique(re.findall(r, request(url)))
    links = map(m, lambda x: domain + x)
    prompt(links)
    for link in links:
        name = tail(link)
        try:
            write(name, request(link))
        except Exception as e:
            print("error", name)


class NewYear:
    def __init__(self):
        print("Running Python New Year")
        self.run()

    def run(self):
        self.doDirectories()
        self.doCleanup()

    def doDirectories(self):
        year = datetime.now().year
        for dir in dirs:
            renamedir(dir, appendFileName(dir, "." + year))
            mkdir(dir)

def rnc(s):
    month = datetime.now().strftime("%B").lower()
    s = addExtension(s, "json")
    s = appendFileName(s, "." + month)
    s = clipdir + tail(s)
    cfile(clipfile, s)
    ofile(s)

def clips():
    files = ff(dir=jsondir, name="\.clip")
    chooseAndOpen(files)

def chooseAndOpen(files):
    files = choose(files)
    ofile(files)


files = [
    "Grade 4 Homework",
    "Grade 4 Midterm Exam",
    "Grade 5 Homework",
    "Grade 5 Midterm Exam",
]

def activityLog(name=0, oncePerDay=0):
    data = normRead("activities.log")
    date = datestamp()

def toFactory(lang):
    def runner(x):
        return addExtension(x, lang)

    return runner

toPdf = toFactory("pdf")

class SystemCommand:
    def __init__(self, *args, dir=dir2023, **kwargs):
        chdir(dir)

        def fix(s):
            if "\n" in s and not ';' in s:
                return join(linegetter(s), delimiter="; ")
            return s

        if test('^(node|python)', args[0]):
            a = " ".join(map(args, dumpJson))
            a, b = mget('^(?:node|python) \S+ \S+ ', a, mode=str)
            if not b:
                b = a
                a = ''
            #prompt(b=b, a=a)
            command = b + shellescape(a)
            #prompt(command=command)
            command += ' ' + shellescape(dumpJson(kwargs))
            #dprint(a, b, command)
            #pprint('ccc')
            #return
        else:
            command = " ".join(map(map(args, dumpJson), fix))

        from subprocess import Popen, PIPE

        process = Popen(
            command, stdout=PIPE, stderr=PIPE, shell=True
        )

        data = process.communicate()
        success, error = [decode(d) for d in data]

        clean = lambda x: re.sub(
            "\.$", "", re.sub("^[eE]rror: ", "", x.strip())
        )
        if error:
            error = clean(error)

        self.error = error
        self.success = success.strip()

        pprint(
            {
                "getCaller": "SystemCommand",
                "command": command,
                "error": error,
                "success": success,
            }
        )

def gitCloner(url):
    chdir(jsdir)
    name = tail(url)
    response = SystemCommand("git clone", url)
    if response.error:
        return

    dir = normpath(jsdir, name)


def temp(s):
    write("temp.js", s, open=1)

def inferKeyFromText(s):
    ref = {
        "pre": 5,
        "li": 50,
    }

    for k, v in ref.items():
        c = len(re.findall("<" + k + "\\b", s))
        if c > v:
            return k

    raise Exception("no key found")

class TextAnalysis:
    def __init__(self, s, key=0):

        self.s = textgetter(s)
        if not key:
            key = inferKeyFromText(self.s)
        self.key = key
        self.get(key)

    def get(self, key):
        ref = env.scrapeRef

        parsers = {
            "li": liParser,
            "tr": liParser,
            "pre": liParser,
            "html": liParser,
        }

        names = {
            "li": "scrape.txt",
            "p": "scrape.txt",
            "pre": "scrape.txt",
            "tr": "scrape.txt",
        }
        postparsers = {
            "pre": prePostParser,
        }

        r = ref.get(key)
        value = unique(re.findall(r, self.s))

        if not value:
            print("didnt get a value", key)
            return
            clip(self.s)
            print("no value")
            return

        if parsers.get(key):
            value = map(value, parsers.get(key))

        if postparsers.get(key):
            return postparsers.get(key)(value)

        if names.get(key):
            return normWrite(
                names.get(key), join(value), open=1
            )

        # pprint(value, key)
        clip(sorted(value))
        return value

def htmlBodyParser(s):
    import bs4
    import html

    body = bs4.BeautifulSoup(s, "html.parser").body
    s = []
    for item in body.find_all(recursive=False):
        text = item.get_text()
        s.append(text)
    return s

def liParser(s):
    import bs4
    import html

    s = bs4.BeautifulSoup(s, "html.parser").get_text()
    s = html.unescape(s)
    s = s.replace(r"\r", "")
    return s

def getFirstWord(s):
    return search("[a-zA-Z]+", s)


def foo(s):
    return map(
        s,
        lambda x: [getFirstWord(tail(x)), x]
        if getExtension(x)
        else None,
    )


def foo(s):
    return ref


def olf():
    ofile(glf())


def findInDir(dir, key):
    files = printdir(dir)
    return find(files, testf(key))

def xsplit(s, r=" "):
    return split(s, r) if isString(s) else s

def objectf(s):
    keys = xsplit(s)

    def runner(o):
        return {k: v for k, v in o.items() if k in keys}

    return runner

def doYesterday():
    files = unique(xsplit(textgetter(filelogfile), "\n+"))

def evaljs(s):
    file = "temp.js.txt"
    write(file, s)
    response = SystemCommand("node", file)

    s = """
    console.log(2)
    console.log(3)
    console.log({a:1})
    console.log(JSON.stringify([{a:2}], null, 4))


    """

    s = """
    var x = require("@lezer/html/dist/index.cjs")
    t=`<body><p>hi</p></body>`
    console.log(x.parser.parse(t))

    """
    # evaljs(s)
    # the response is not easy to manage
    # creating a grammar file

def ff(
    dir=dir2023,
    mode=0,
    once=0,
    sort=0,
    reverse=0,
    recursive=0,
    **kwargs,
):

    if isString(dir) and getExtension(dir):
        return findFile(dir)

    if mode == "smallclean":
        kwargs["smallerThan"] = 2
        kwargs["zip"] = 1
        kwargs[
            "include"
        ] = """
            doo.js
            foo.js
            a.js
            b.js
            test.pdf
        """

        kwargs[
            "ignore"
        ] = """
            scratchpad.js

        """

    elif mode == "print":
        sort = True

    if isArray(dir):
        rawFiles = dir
    elif recursive:
        rawFiles = getFilesRecursive(dirgetter(dir))
    else:
        rawFiles = absdir(dirgetter(dir)) 

    checkpoint = checkpointf(**kwargs)
    if once:
        return find(rawFiles, checkpoint)
    files = filter(rawFiles, checkpoint)
    print("num files", len(files))

    if not files:
        return

    if reverse:
        sort = 1
    if sort:
        if isString(sort):
            if sort == 'size':
                sort = fsize

            elif sort == 'date':
                sort = mdate

        files.sort(
            key=mdate if sort == 1 else sort,
            reverse=reverse,
        )

    if mode == "smallclean":
        prompt(files, "remove?")
        rfiles(files)
        printdir(dir)
    elif mode == "filetable":
        return write('file-table.txt', tabular(map(sorted(files, key=mdate), nameAndDate)))

    elif mode == "rename":
        map(files, promptRenameFile)

    elif mode == "save":
        return appendVariable(files)

    elif mode == "print":
        map(files, fileInfo)
    elif mode == "delete":
        prompt(map(files, tail), 'delete?')
        map(files, rfile)
    elif mode == "cleanup":
        cleanfiles(files)
    elif mode == "open" or mode == "o":
        map(files, openBrowser)
    elif mode == "info":
        os.system('clear')
        pprint(map(files, fileInfo))
        pprint(len(files))
    elif mode == "clipinfo":
        files.sort(key=mdate, reverse=1)
        f = lambda x: join(map(x, str), delimiter="  ")
        return clip(tabular(map(files, fileInfo, delete=1)))
    elif mode == "delete" or mode == "d":
        prompt(map(files, fileInfo), "delete these files?")
        map(files, rfile)
    elif mode == "backup":
        map(files, cfile, budir)
    elif mode == "label":
        files = choose(files)
        label = prompt("label as?")
        appendVariable(files)
    elif mode == "moveToWorkSpace":
        files = choose(files)
        for file in files:
            dest = changeFileName2(file)
            cfile(file, dest)
    elif mode == "review":
        reviewfiles(files)
    else:
        pprint(files)
        print(len(files))
        return files

def openOrPrint(x, dir=0, r="index.cjs"):
    with CD(dir):
        if isfile(x):
            ofile(x)
        elif isdir(x):
            files = os.listdir(x)
            target = find(files, r)
            if target:
                ofile(os.path.join(x, target))
            else:
                pprint(files)

def makeEmojis():
    items = read(dldir + "emoji.json").get("emojis")
    store = {}
    # for k,v in items.items():
    # store[k] = v.get('skins')[0].get('native')
    # normWrite('emoji.json', store)
    # https://api.github.com/emojis # has all of the emojis as png files which is different from utf...
    # The above is to parse them out.
    ################################################33

    ################################################
    url = "https://openmoji.org/library"
    ta = TextAnalysis(url, "imgsrc")
    normWrite("svg-emoji.json", ta.results)
    # build the links perhaps
    ################################################

def changeFileName2(file, dir=0, newName=0):
    if not newName: newName = prompt(file, "new name?")
    if not dir: dir = head(file)
    return npath(dir, addExtension(newName, getExtension(file)))

def gfn():
    def dateSearch(s):
        return search("^______+ = " + date, s, flags=re.M)

    return getFunctionNames(
        dateSearch(normRead("class.js"))
    )

def abrev(s):
    r = "\W|(\d)"
    items = filter(re.split(r, s))
    return "".join(map(items, lambda x: x[0])).lower()

def appendVariable(x, name="temp", outpath=0, str=0):
    if isString(x) and isfile(x):
        name = camelCase(removeExtension(x))
        x = read(x)
        outpath = dir2023 + "variables.js"

    s = createVariable(name, x)
    if str:
        s = join(s)

    append(outpath or currentFile(), s)

def mostRecentDirectoryFiles(key, e="pdf", amount=10):
    v = ff(dirgetter(key), sort=1, e=e)[-amount:]
    os.system("clear")
    pprint(v)
    return v

def openLastGoogleDoc():
    return openBrowser(read("google-doc-file.txt").strip())

def editMathcha(f="", fn=0):
    text = fn(byteRead(f))
    byteWrite(f, text)

def byteRead(file):
    with open(file, "rb") as f:
        return f.read()

def byteWrite(file, value):
    with open(file, "wb") as f:
        f.write(value)
        print("successfully wrote byte file!", file)

def mathchaReplace(s):
    prompt(s)
    dict = {
        #'ab': 'AB',
        #'123': 'ONETWOTHREE',
        #'sdf': 'SDF',
        #'12': 'ONETWO',
        #'abc': 'ABC',
        "QRKQRK": "booper"
    }
    return byteReplace(s, dict, "b")

def byteReplace(s, dict, template="b", flags=0):
    regex = str.encode(ncg(template, dict))
    print(regex)

    def parser(x):
        return str.encode(
            dict.get(x.group(1).decode())
            if x.groups()
            else dict.get(x.group(0).decode())
        )

    return re.sub(regex, parser, s, flags=flags)


def depfindFile(root, name):
    def runner(dir):
        files = absdir(dir)
        for f in files:
            if isIgnoredFile(f):
                continue
            if isdir(f):
                if test(name, tail(f), flags=re.I):
                    print("found")
                    print(f)
                    return f
                else:
                    print(f)
                    runner(f)

    return runner(root)

def depfindDir(root, name):
    def runner(dir):
        files = absdir(dir)
        for f in files:
            if isIgnoredFile(f):
                continue
            if isdir(f):
                if test(name, tail(f), flags=re.I):
                    print("found")
                    print(f)
                    return f
                else:
                    print(f)
                    runner(f)

    return runner(root)

def isVeryRecentFile(f):
    return isRecentFile(f, minutes=4000)

def printIt(fn):
    def decorator(*args, **kwargs):
        printIt = kwargs.pop("printIt", None)
        if printIt and isVeryRecentFile(clipfile):
            print("returning very recent file")
            return read(clipfile)
        value = fn(*args, **kwargs)
        if printIt:
            clip(value)
        return value

    return decorator


def mdir(f, t):
    assert isdir(f)
    a, b = re.sub("/ *$", "", f).rsplit("/", maxsplit=1)
    dest = os.path.join(a, t)
    prompt("moving", "from", f, "to", dest)
    shutil.move(f, dest)

def getLastPdf(name=""):
    file = glf(name=name, e="pdf")
    return file


def scrapeOrdering():
    def f(s):
        if s == "x" or not s or s == 0:
            return 0
        return int(s)

    s = map(
        split(
            prompt("fix:order = G9, V2, V1, M2, M1"), " "
        ),
        f,
    )
    return list(reversed(s))

def choosefiles(dir=dldir, key="", groups=3):
    files = choose(
        map(
            sorted(absdir(dir), key=mdate, reverse=True),
            tail,
        )
    )
    pprint(files)
    return files


def arrayToObject(a, f):
    return {f(x): x for x in a}

def mergeFirstPageOfEachFile(files):
    f = lambda x: x.pages[0:1]
    return pdfCreate(files, f)

def getFilesRecursive(dir):
    store = []
    def runner(dir):
        files = absdir(dir)
        for file in files:
            if isIgnoredFile(tail(file)):
                continue
            elif isdir(file):
                runner(file)
            else:
                if len(store) > 100:
                    raise Exception('not allowed to many')
                store.append(file)
    runner(dir)
    return store
        
def is_empty_dir(dir):
    def runner(dir):
        for file in absdir(dir):
            if isfile(file):
                return False
            elif not runner(file):
                return False

        return True

    return runner(dir)

def printDirRecursive(dir, **kwargs):

    checkpoint = checkpointf(**kwargs)

    def runner(dir):
        store = {}
        children = []
        store["dir"] = dir
        store["children"] = children

        files = absdir(dir)
        for file in files:
            name = tail(file)

            if isIgnoredFile(name):
                continue

            elif isfile(file):
                if checkpoint(file):
                    children.append({"file": name})
            elif isdir(file):
                if is_empty_dir(file):
                    print('is empty dir remove it?')
                    rmdir(file)
                else:
                    children.append(runner(file))
        return store

    return runner(dir)

def getLastNumber(s):
    n = search("(\d+) *(?:\.\w+)?$", s)
    return int(n)

def pdfIt(f):
    name = changeExtension(f, "pdf")
    mfile(f, name)

cantfind = "Acing the New SAT Math PDF Book.pdf.json"

def recentFileCache(fn):
    def decorator(file, *args, **kwargs):
        reset = kwargs.pop("reset", None)
        value = fn(file, *args, **kwargs)
        recentfile = file + ".recent"
        if not reset and isRecentFile(recentfile, hours=2):
            print("returning recent file")
            return parseJSON(read(recentfile))
        else:
            write(recentfile, value, open=1)
            return value

    return decorator

def choosePDFS():
    files = choose(mostRecentDirectoryFiles(dldir))
    return files

def oncef():
    go = True

    def lamb(arg):
        nonlocal go
        if go and arg:
            go = False
            return True

    return lamb

def infof(f):
    def lamb(file, *args):
        value = f(file, *args)
        return {"file": tail(file), "value": value}

    return lamb

def mapdir(files, dir):
    return map(files, lambda x: normpath(dir, x))


def objectClassName(x):
    s = str(type(x))
    return search("<\w+ '(?:__main__\.|base\.)?(\w+)", s)


class PageStorage:
    def __init__(self):
        self.store = []

    def reset(self, key, value=None):
        self.current = [value] if value != None else []
        self.store.append([key, self.current])

    def add(self, item):
        self.current.append(item)

    def __len__(self):
        return len(self.store)

def toJSON(x):
    name = objectClassName(x)
    if test("Storage$", name):
        return x.store

def getTime():
    return int(datetime.timestamp(datetime.now()))

def getFileName(file):
    return removeExtension(tail(file))

def mostRecentFileGroups(dir=dldir, minutes=3, reverse=True):
    ignore = ['Grade Reports', 'g4q', 'g5q']

    #storage = PageStorage()
    files = ff(dir, sort=1, reverse=reverse)
    store = []

    ignoreRE = "(Class|home)work|^g[45]"
    lastDate = 0

    for i, file in enumerate(files):
        if getFileName(file) in ignore:
            continue
        date = mdate(file)
        name = tail(file)
        if test(ignoreRE, name):
            continue
        d = delta(date, lastDate)
        limit = toSeconds(minutes=minutes)
        passes = d < limit or lastDate == 0
        dprint(name, d, limit, passes)
        if passes:
            store.append(file)
        else:
            return store

        lastDate = date

def promptOutpath(s=0, fallback="", fn=0):
    out = s or prompt("outpath?") or fallback
    if fn:
        out = fn(out)
    return npath(dldir, out)


def getNodeFile(name):
    files = [
        f"{nodedir}{name}/dist/{name}.js",
        f"{nodedir}{name}/dist/index.js",
    ]
    file = find(files, isfile)
    if file:
        return file
    else:
        prompt(printDirRecursive(nodedir + name))


def versionControl(f, revert=0):
    f = normDirPath(f)
    if not isfile(f):
        return

    original = f
    got = 0

    def increment(f, n=1):
        nonlocal got
        v = f + ".version" + str(n)
        if isfile(v):
            if revert:
                got = v
                return
            return increment(f, n + 1)
        else:
            return v

    newFile = increment(npath(budir, original))
    if got:
        prompt(f"revert {got} to {original} original?")
        backup(original)
        shutil.copy(got, original)
        print("successful reversion!")
    else:
        prompt(f"copy original to {newFile}?")
        shutil.copy(original, newFile)
        print("successful control to budir!")


def pickFiles(dir="dldir"):
    a = prompt(f"choose files. directory = {dir}")
    dir = dirdict.get(dir, None)
    assert dir
    return mapdir(xsplit(a), dir)

def STOP():
    raise Exception("STOP!!!")

def findCssFile():
    files = ff(dldir, css=1, text="mult")


def splitOnWord(s, word):
    if test("\\b" + word + "\\b", s):
        s = getLast(re.split(word + ".*", s))
    return s


def tabular(data):
    store = []
    n = 25
    s = (f"{{: >{n}}}" * len(data[0])).strip()
    for row in data:
        store.append(s.format(*row))
    return join(store)


def foo():
    store = {}
    for a, b, c in partition(re.findall("\S+", clip()), 3):
        store[a] = [b, c]
    clip(oneLine(s))

def oneLine(s):
    s = json.dumps(s, indent=4)
    s = re.sub(r'": \[\s+', '": [', s)
    s = re.sub(r'",\s+', '", ', s)
    s = re.sub(r'"\s+\]', '"]', s)
    return s


def finfo(file):
    text = read(file)
    return {
        "file": tail(file),
        "lines": lineCount(text),
        "size": len(text),
    }

def trackProgress():
    # let text = search(r, lastQuarter(read(file)))
    # let data = getBindingNames(text)
    # let stamp = datestamp(date1) + ' - ' + datestamp(date2)
    # let s = join(stamp, data)
    # console.log(s)
    normAppend("daily-code-progress.log", s)

def moveFilesToDriveTodoDir(dir):
    s = mostRecentFileGroups(dldir, minutes=5)[0][1]
    prompt(s, "move these files?")
    dir = prompt("todo sub directory name?").upper()
    dir = tododir + dir
    mkdir(dir)
    map(s, mfile, dir)

def imageToText(img):
    # sudo apt install tesseract-ocr
    # sudo apt install libtesseract-dev
    # sudo apt install libleptonica-dev pkg-config
    from PIL import Image
    import pytesseract

    return pytesseract.image_to_string(Image.open(img))

    # OR

    # sudo apt install tesseract-ocr
    # sudo apt install libtesseract-dev
    # sudo apt install tesseract-ocr-ita

    # pip install pytesseract
    # pip install opencv

    import cv2
    import argparse
    import os
    import pytesseract
    from PIL import Image

    def extract_text(image):
        im = cv2.imread(image)
        imgray = cv2.cvtColor(im, cv2.COLOR_BGR2GRAY)
        ret, thresh1 = cv2.threshold(
            imgray, 180, 255, cv2.THRESH_BINARY
        )
        filename = "{}.png".format(os.getpid())
        cv2.imwrite(filename, thresh1)
        img = Image.open(filename)
        text = pytesseract.image_to_string(img)
        return text

def cleanup(dir, r):
    with CD(dir):
        for f in os.listdir(dir):
            if test(r, f, flags=re.I):
                rfile(f)


def getWords(s):
    return re.findall("[a-zA-Z]{3,}", s)

def getLastWord(s):
    return getWords(s)[-1]

def strType(x):
    return getLastWord(str(type(x)))


def download(url, name=0):
    if not name:
        name = addExtension(
            prompt(url, "outpath name"), "pdf"
        )
    write(dldir + name, request(url))

def stringInfo(*args):
    items = partition(args)
    s = ""
    for a, b in items:
        s += a + ": " + str(b) + "\n"
    return s.strip()

def backup1206(*files):
    date = datestamp()
    name = "CURRENT"
    dir = budir + name
    files = list(files)
    files.append("/home/kdog3682/VIM/functions.vim")
    files.append("/home/kdog3682/VIM/variables.vim")
    files.append("/home/kdog3682/.vimrc")
    files = unique(files)
    cfiles(files, dir)

    info = stringInfo(
        "date",
        date,
        "directory",
        dir,
        "numFiles",
        len(files),
    )
    payload = join(info, files, linebreak)
    normAppend("files.log", payload)

def scrapeHTML(url):
    s = join(
        map(
            re.findall(
                env.scrapeRef.get("pre"), request(url)
            ),
            liParser,
        )
    )
    normWrite("scrape.html", s)

def scrape(url, key=0):
    prompt(url, key)
    TextAnalysis(url, key)

def prePostParser(items):
    s = filter(items, "^\s*<")
    if len(s):
        return normWrite(
            "scrape.html", chooseIndex(s), open=1
        )
    else:
        print(s)
        print("not done yet")

def chooseIndex(items):
    i = len(items)
    if i == 1:
        return items[0]
    a = prompt(
        f"There are {i} items. Choose 1-based indexes."
    )
    return smallify([items[int(i) - 1] for i in a])

def dirName(s):
    return os.path.split(re.sub("/*$", "", s))[1]

def zipToDir(dir):
    # clip(getfiles(dir, recursive=1))
    # return

    name = dirName(dir)
    r = re.sub("\W", ".*?", name)
    file = glf()

    assert itest(r, file)
    assert getExtension(file) == "zip"

    mkdir(dir)
    unzip(file, dir)

    childDir = absdir(dir)[0]
    files = absdir(childDir)
    for file in files:
        mfile(file, dir)
    rmdir(childDir)
    pprint(os.listdir(dir))


def rpw(file, f):
    normWrite(file, f(normRead(file)))


def foo():
    dir = swiftdir
    for item in filter(absdir(dir), isdir):
        files = absdir(item)
        for file in files:
            mfile(file, swiftdir)


def craig():
    from craigslist import CraigslistJobs

    # from craigslist import CraigslistServices
    # print(dir(CraigslistServices))
    # return

    x = CraigslistJobs.show_categories()
    print(x)
    return

    kwargs = {
        "site": "newyork",
    }

    jobs = CraigslistJobs(**kwargs)
    for result in jobs.get_results():
        print(result)

def rfiles(files):
    map(files, rfile)


temp = [
    "/home/kdog3682/TEACHING/SAT Grammar Test 4.pdf",
    "/home/kdog3682/TEACHING/SAT Grammar Test 1.pdf",
    "/home/kdog3682/TEACHING/SAT Grammar Test 2.pdf",
    "/home/kdog3682/TEACHING/SAT Grammar Test 3.pdf",
    "/home/kdog3682/TEACHING/SAT Grammar Test 4.json",
    "/home/kdog3682/TEACHING/SAT Grammar Test 3.json",
    "/home/kdog3682/TEACHING/SAT Grammar Test 2.json",
    "/home/kdog3682/TEACHING/SAT Grammar Test 1.json",
]

cwdfolderinfo = [
    "/home/kdog3682/CWD/tempest.json",
    "/home/kdog3682/CWD/animations.js",
    "/home/kdog3682/CWD/service.json",
    "/home/kdog3682/CWD/info.json",
    "/home/kdog3682/CWD/vue-messy.js",
    "/home/kdog3682/CWD/functioninfo.json",
    "/home/kdog3682/CWD/stdlib.css",
    "/home/kdog3682/CWD/h.js",
    "/home/kdog3682/CWD/finderror.js",
    "/home/kdog3682/CWD/html3.js",
    "/home/kdog3682/CWD/node.js",
    "/home/kdog3682/CWD/nerdsolver.js",
    "/home/kdog3682/CWD/tempest.js",
    "/home/kdog3682/CWD/katex-question.js",
    "/home/kdog3682/CWD/v3.js",
    "/home/kdog3682/CWD/index.html",
    "/home/kdog3682/CWD/testfile2.js",
    "/home/kdog3682/CWD/generate_multiple_choice.js",
    "/home/kdog3682/CWD/0.js",
    "/home/kdog3682/CWD/apptest.js",
    "/home/kdog3682/CWD/zola",
    "/home/kdog3682/CWD/pdfo.js",
    "/home/kdog3682/CWD/fshelpers.js",
    "/home/kdog3682/CWD/scratchpad.js",
    "/home/kdog3682/CWD/mathstory.txt",
    "/home/kdog3682/CWD/xcnv.js",
    "/home/kdog3682/CWD/normalize.css",
    "/home/kdog3682/CWD/testfile3.js",
    "/home/kdog3682/CWD/slim.py",
    "/home/kdog3682/CWD/apps.js",
    "/home/kdog3682/CWD/template.html",
    "/home/kdog3682/CWD/tuesday.js",
    "/home/kdog3682/CWD/a4.pdf",
    "/home/kdog3682/CWD/graphcalc.js",
    "/home/kdog3682/CWD/html-parser.js",
    "/home/kdog3682/CWD/am8.txt",
    "/home/kdog3682/CWD/gapp.js",
    "/home/kdog3682/CWD/google-emails.json",
    "/home/kdog3682/CWD/zq.json",
    "/home/kdog3682/CWD/ad.txt",
    "/home/kdog3682/CWD/pdfgen-simulate.js",
    "/home/kdog3682/CWD/html.js",
    "/home/kdog3682/CWD/jsc.js",
    "/home/kdog3682/CWD/tempest.txt",
    "/home/kdog3682/CWD/index.js2",
    "/home/kdog3682/CWD/pdfgen.js",
    "/home/kdog3682/CWD/makepdf.js",
    "/home/kdog3682/CWD/runjspdf.js",
    "/home/kdog3682/CWD/fastmath.js",
    "/home/kdog3682/CWD/app-fastmath.js",
    "/home/kdog3682/CWD/LineEdit.js",
    "/home/kdog3682/CWD/package-lock.json",
    "/home/kdog3682/CWD/r2",
    "/home/kdog3682/CWD/todo.js",
    "/home/kdog3682/CWD/raw.js",
    "/home/kdog3682/CWD/gldl.js",
    "/home/kdog3682/CWD/testfile.js",
    "/home/kdog3682/CWD/node-utils.js",
    "/home/kdog3682/CWD/generate-multiple-choice.js",
    "/home/kdog3682/CWD/tempindex.html",
    "/home/kdog3682/CWD/helperfunctions.js",
    "/home/kdog3682/CWD/t5.js",
    "/home/kdog3682/CWD/nerdcheck.js",
    "/home/kdog3682/CWD/math-helpers.js",
    "/home/kdog3682/CWD/math-utils.js",
    "/home/kdog3682/CWD/puppet.js",
    "/home/kdog3682/CWD/html-helpers.js",
    "/home/kdog3682/CWD/jsa.js",
    "/home/kdog3682/CWD/s.js",
    "/home/kdog3682/CWD/jsconnector.js",
    "/home/kdog3682/CWD/pdfgen-make.js",
    "/home/kdog3682/CWD/pdfgen-run.js",
    "/home/kdog3682/CWD/helpers.js",
    "/home/kdog3682/CWD/testfile4.js",
    "/home/kdog3682/CWD/vue-transform.js",
    "/home/kdog3682/CWD/source.js",
    "/home/kdog3682/CWD/pdfgen-state.js",
    "/home/kdog3682/CWD/nodehelpers.js",
]

DELETED = [
    "/home/kdog3682/stockfish_14.1_linux_x64",
    "/home/kdog3682/pmwb.json",
    "/home/kdog3682/appscript.temp.json",
    "/home/kdog3682/CWF.files.json",
    "/home/kdog3682/new-files.txt",
    "/home/kdog3682/consolidate.js",
    "/home/kdog3682/consolidate.py",
    "/home/kdog3682/pip.logs.txt",
]

def undo(dir=trashdir):
    mfiles(ff(dir, minutes=10)[-8:], teachdir)

temp = [
    # "/home/kdog3682/CWF/history_data.csv",
    "/home/kdog3682/CWF/snip.vim",
    "/home/kdog3682/CWF/Session.vim",
    "/home/kdog3682/CWF/trash",
    "/home/kdog3682/CWF/run.sh",
    "/home/kdog3682/CWF/storage.py",
    "/home/kdog3682/CWF/vim-comments.vim",
    "/home/kdog3682/CWF/transfer.sh",
    "/home/kdog3682/CWF/passwords.csv",
    "/home/kdog3682/CWF/macbash.sh",
    "/home/kdog3682/CWF/vim-data.vim",
    # "/home/kdog3682/CWF/cmparser.js",
    # "/home/kdog3682/CWF/cmgen.js",
    "/home/kdog3682/CWF/setup2.sh",
    "/home/kdog3682/CWF/Symbola.otf",
    "/home/kdog3682/CWF/index.js2",
    # "/home/kdog3682/CWF/percents.html",
    "/home/kdog3682/CWF/setup.sh",
    # "/home/kdog3682/CWF/intel.py",
    # "/home/kdog3682/CWF/temp.py",
    # "/home/kdog3682/CWF/g24.py",
    "/home/kdog3682/CWF/utils.py",
    "/home/kdog3682/CWF/helpers.py",
    # "/home/kdog3682/CWF/pike.py",
    "/home/kdog3682/CWF/zipscript.py",
    "/home/kdog3682/CWF/githubscript.py",
    "/home/kdog3682/CWF/voskscript.py",
    "/home/kdog3682/CWF/ga.py",
    "/home/kdog3682/CWF/redditscript.py",
    "/home/kdog3682/CWF/env.py",
    "/home/kdog3682/CWF/iab.vim",
    "/home/kdog3682/CWF/run.py",
    "/home/kdog3682/CWF/helpers2.js",
    "/home/kdog3682/CWF/temp.js.txt",
    "/home/kdog3682/CWF/pdf.py",
    "/home/kdog3682/CWF/apps.py",
    "/home/kdog3682/CWF/pdfservice.py",
    "/home/kdog3682/CWF/.clip.js",
    "/home/kdog3682/CWF/pug.html",
    "/home/kdog3682/CWF/index.html",
    "/home/kdog3682/CWF/a.js",
    "/home/kdog3682/CWF/r7.css",
    "/home/kdog3682/CWF/a.py",
    "/home/kdog3682/CWF/variables.vim",
    "/home/kdog3682/CWF/dicts.vim",
    "/home/kdog3682/CWF/vim-dictionaries.vim",
    "/home/kdog3682/CWF/bkl.py",
    "/home/kdog3682/CWF/base.py",
]

def mover(extensions, dir):
    inpath = pydir
    c = checkpointf(
        extensions=xsplit(extensions), deleteIt=1
    )
    files = filter(absdir(inpath), c)
    dir = rootdir + dir.upper()
    mkdir(dir)
    mfiles(files, dir)

def removeCache():
    rmdir(pydir + "__pycache__", force=1)


temp = [
    # "/home/kdog3682/CWD/tempest.json",
    # "/home/kdog3682/CWD/animations.js",
    # "/home/kdog3682/CWD/service.json",
    "/home/kdog3682/CWD/info.json",
    "/home/kdog3682/CWD/vue-messy.js",
    "/home/kdog3682/CWD/functioninfo.json",
    "/home/kdog3682/CWD/stdlib.css",
    # "/home/kdog3682/CWD/h.js",
    # "/home/kdog3682/CWD/finderror.js",
    # "/home/kdog3682/CWD/html3.js",
    # "/home/kdog3682/CWD/node.js",
    "/home/kdog3682/CWD/nerdsolver.js",
    "/home/kdog3682/CWD/tempest.js",
    "/home/kdog3682/CWD/katex-question.js",
    "/home/kdog3682/CWD/v3.js",
    "/home/kdog3682/CWD/index.html",
    "/home/kdog3682/CWD/testfile2.js",
    "/home/kdog3682/CWD/generate_multiple_choice.js",
    "/home/kdog3682/CWD/0.js",
    "/home/kdog3682/CWD/apptest.js",
    "/home/kdog3682/CWD/zola",
    "/home/kdog3682/CWD/pdfo.js",
    "/home/kdog3682/CWD/fshelpers.js",
    "/home/kdog3682/CWD/scratchpad.js",
    "/home/kdog3682/CWD/mathstory.txt",
    "/home/kdog3682/CWD/xcnv.js",
    "/home/kdog3682/CWD/normalize.css",
    "/home/kdog3682/CWD/testfile3.js",
    "/home/kdog3682/CWD/slim.py",
    "/home/kdog3682/CWD/apps.js",
    "/home/kdog3682/CWD/template.html",
    "/home/kdog3682/CWD/tuesday.js",
    "/home/kdog3682/CWD/a4.pdf",
    "/home/kdog3682/CWD/graphcalc.js",
    "/home/kdog3682/CWD/html-parser.js",
    "/home/kdog3682/CWD/am8.txt",
    "/home/kdog3682/CWD/gapp.js",
    "/home/kdog3682/CWD/google-emails.json",
    "/home/kdog3682/CWD/zq.json",
    "/home/kdog3682/CWD/ad.txt",
    "/home/kdog3682/CWD/pdfgen-simulate.js",
    "/home/kdog3682/CWD/html.js",
    "/home/kdog3682/CWD/jsc.js",
    "/home/kdog3682/CWD/tempest.txt",
    "/home/kdog3682/CWD/index.js2",
    "/home/kdog3682/CWD/pdfgen.js",
    "/home/kdog3682/CWD/makepdf.js",
    "/home/kdog3682/CWD/runjspdf.js",
    "/home/kdog3682/CWD/fastmath.js",
    "/home/kdog3682/CWD/app-fastmath.js",
    "/home/kdog3682/CWD/LineEdit.js",
    "/home/kdog3682/CWD/package-lock.json",
    "/home/kdog3682/CWD/r2",
    "/home/kdog3682/CWD/todo.js",
    "/home/kdog3682/CWD/raw.js",
    "/home/kdog3682/CWD/gldl.js",
    "/home/kdog3682/CWD/testfile.js",
    "/home/kdog3682/CWD/node-utils.js",
    "/home/kdog3682/CWD/generate-multiple-choice.js",
    "/home/kdog3682/CWD/tempindex.html",
    "/home/kdog3682/CWD/helperfunctions.js",
    "/home/kdog3682/CWD/t5.js",
    "/home/kdog3682/CWD/nerdcheck.js",
    "/home/kdog3682/CWD/math-helpers.js",
    "/home/kdog3682/CWD/math-utils.js",
    "/home/kdog3682/CWD/puppet.js",
    "/home/kdog3682/CWD/html-helpers.js",
    "/home/kdog3682/CWD/jsa.js",
    "/home/kdog3682/CWD/s.js",
    "/home/kdog3682/CWD/jsconnector.js",
    "/home/kdog3682/CWD/pdfgen-make.js",
    "/home/kdog3682/CWD/pdfgen-run.js",
    "/home/kdog3682/CWD/helpers.js",
    "/home/kdog3682/CWD/testfile4.js",
    "/home/kdog3682/CWD/vue-transform.js",
    "/home/kdog3682/CWD/source.js",
    "/home/kdog3682/CWD/pdfgen-state.js",
    "/home/kdog3682/CWD/nodehelpers.js",
]

pdir = "/home/kdog3682/PYTHON/"
jdir = "/home/kdog3682/JAVASCRIPT/"

def odir(dir):
    ofile(absdir(dir))

def backupDirectories(directories):
    import shutil

    mkdir(budir + datestamp())
    for dir in toArray(directories):
        outpath = os.path.join(
            budir, datestamp(), dirName(dir)
        )
        print("making zip directory", dir)
        shutil.make_archive(outpath, "zip", dir)

def zipCheck(outpath=0, file=0):
    # outpath = budir / datestamp / SERVER.zip / myFile.js
    # pprint(zipCheck(s, file='token.json'))

    import zipfile
    import io

    with zipfile.ZipFile(outpath, "r") as z:
        if file:
            file = z.open(file)
            with io.TextIOWrapper(
                file, encoding="utf-8"
            ) as f:
                return parseJSON(f.read())
        else:
            return map(z.filelist, lambda x: x.filename)


def testsuite(items):
    return map(items, lambda x: [x, eval(x)])


def choosepdf():
    ofile(choose(mostRecent(dldir, 10, reverse=1)))

def seeRecent():
    e = prompt("extension?")
    kwargs = dict({"dir": dirdict.get(e), e: True})
    ff(**kwargs)


def n2char(n):
    return chr(n + 97)


def create_pdfdict_from_pdf_files():
    files = ff(pdfdir, name="^G\d|math")
    d = {
        n2char(i) + n2char(i): f
        for i, f in enumerate(files)
    }
    appendVariable(d, outpath="pdf.py", name="pdfdict")


def normFileToDir(file, name=0):
    if not name:
        name = prompt(file, "name?")
    e = getExtension(file)
    return dirdict.get(e) + addExtension(name, e)

def move_last_file_and_name_it():
    file = glf()
    out = normFileToDir(file)
    prompt("is this the correct outpath?", out)
    mfile(file, out)

def promptSplit(*args):
    r = "\||\.\.|\\\\|  +"
    a = prompt(*args)
    return re.split(r, a.strip())


def saveToDrive(file):
    cfile(file, tempbudir)


def emptyTrash(dir=trashdir):
    prompt(os.listdir(trashdir))
    assert isdir(dir)
    rmdir(dir, force=1)
    mkdir(dir)
    printdir(dir)

def keepOrDelete(file):
    a = prompt(file)
    if a == "d":
        rfile(file)
    elif a == "k":
        e = getExtension(file)
        if e == "zip":
            unzip(file, to=unzipdir)


def cleanupRawText(s):
    def f(x):
        n = x.group(0)
        if n == "":
            return '"'
        if n == "":
            return '"'
        if n == "":
            return "'"
        raise Exception(x)

    s = re.sub("\t| {2,}", " ", s)
    s = re.sub("[]", f, s)
    return s.strip()

def normMove(src, to):
    outpath = dirFromFile(to) + tail(to)
    mfile(src, outpath)


sentenceRE = "(?:\. \"?|\n)([A-Z]\w*(?:'\w+)?)"

def backupMostPopular():
    files = [
        "/home/kdog3682/CWF/public/class.js",
        "/home/kdog3682/PYTHON/pdf.py",
        "/home/kdog3682/VIM/functions.vim",
        "/home/kdog3682/VIM/variables.vim",
        "/home/kdog3682/CWF/public/print.js",
    ]
    cfiles(files, bucurdir)

def fixWrongPaths():
    baseFiles = map(files, lambda x: normpath(drivedir, x))
    for i, baseFile in enumerate(baseFiles):
        file = files[i]
        outpath = normpath(bucurdir, baseFile)
        cfile(baseFile, outpath)
        mfile(baseFile, file)


def writeGitIgnore(dir2023):
    s = """
        *.zip
        *.7z
        *.rar
        *.tar.gz
        *.pdf
        .DS_Store
        node_modules
        __pycache__

    """
    write(dir + ".gitignore", smartDedent(s), open=1)


def gitRemote(repo, username="kdog3682", message=0):
    chdir(rootdir + repo)
    if not isdir(".git"):
        response = SystemCommand("git init")

    # for changing from master to main
    s = "git branch -m master main"
    s = "git push -u origin main"
    s = "git push origin --delete master"
    #############################

    # s = 'git diff --name-only --cached'
    # s = 'git status'
    # s = 'git diff --names-only'
    # s = 'git diff --staged'
    # s = 'git add .'
    # response = SystemCommand(s)
    # return
    # s = 'git log'
    # s = 'git push -u origin main'
    # s = 'git remote -v'
    # s = 'ssh -vvv git@github.com'
    # it creates a prompt which may ask something

    mainCommand = f"git add .\ngit commit -a -m \"{message or 'pythonTest'}\"\ngit push"
    response = SystemCommand(mainCommand)

    if response.error == "sdfgsdfg":

        url = f"git@github.com:{username}/{repo}.git"
        s = f"git remote add origin {url}"
        response = SystemCommand(s)

        if response.error == "remote origin already exists":
            s = f"git remote set-url origin {url}"
            response = SystemCommand(s)

    elif response.error == "sdfgsdfg":
        prompt("Creating ssh key gen, press Y for Yes")
        s = 'ssh-keygen -t rsa -C "kdog3682@gmail.com"'
        response = SystemCommand(s)
        ofile(sshfile)
        prompt("copy the opened file to github")
        response = SystemCommand(mainCommand)

    return

def changelog(s=0, mode="add"):
    changelogfile = "/home/kdog3682/2023/changelog.md"
    if not s:
        s = hms()
    payload = "+ " + s
    append(changelogfile, payload)

def writeNpmInit(name):

    data = {
        "name": name,
        "version": "1.0.0",
        "type": "module",
        "description": "",
        "main": "index.js",
        "scripts": {
            "test": 'echo "Error: no test specified" && exit 1'
        },
        "repository": {
            "type": "git",
            "url": f"git+https://github.com/kdog3682/{name}.git",
        },
        "author": "Kevin Lee",
        "license": "ISC",
        "homepage": "https://github.com/kdog3682/2023#changelog",
    }
    write(outpath, data)

def gitUrl(file, repo, user="kdog3682"):
    url = "https://raw.githubusercontent.com/$1/$2/main/$3"
    url = templater(url, [user, repo, file])
    print(url)
    return url


def npmInstall(s):
    dev = test("cors|nodemon|jest|grunt|uglify", s, flags=re.I)
    SystemCommand(
        "npm i " + s + (" --save-dev" if dev else "")
    )


def text():
    return normRead("scrape.txt")

def foo():
    a = linegetter(text(), fn="(^[a-z]\w+)\(", u=1)
    b = linegetter(text(), fn="^[A-Z][a-zA-Z]+$", u=1)
    data = {
        "builtInFunctions": a,
        "builtInClasses": b,
    }

def normClear(file):
    file = normDirPath(file)
    print(file)
    clear(file)


def publishScratchpad():
    with CD(dir2023):
        outpath = addExtension(
            prompt(
                "publishing scratchpad. choose outpath file name: "
            ),
            "js",
        )
        mfile("scratchpad.js", outpath)

base = "https://www.nysedregents.org/ei"

def getLinks(folders, q):
    store = []
    for path in toArray(folders):
        matches = ff(path, name=q)
        if matches:
            store.extend(matches)

    files = choose(store)
    map(files, revert, dir=jsdir, increment=1, vim=1)

def incrementName(file):
    count = 1
    a, b = mget("(?:\.\w+)+$", file, mode=str)
    while isfile(file):
        count += 1
        file = a + str(count) + b
    return file

def appendVim(type, arg):
    b = arg
    s = removeExtension(tail(b))
    a = abrev(s)
    s = f'let g:{type}["{a}"] = "{b}"'
    append("/home/kdog3682/.vimrc", s)


def removeFileParens(s):
    return re.sub(" *\(.*?\) *", "", s)

def overrideFile():
    f = glf()
    mfile(f, removeFileParens(f))


def isEmptyDir(dir):
    return isdir(dir) and not os.listdir(dir)

def renameFiles():
    for file in ff(dldir, reverse=1):
        if isEmptyDir(file):
            rfile(file)
            continue

        a = prompt(file)
        if a == "d":
            rfile(file)
        elif a == "c":
            continue
        elif a:
            out = npath(dldir, addExtension(a, "pdf"))
            mfile(file, out)
        else:
            break


def fixUrls(source, links):
    url = fixUrl(source)
    base = url
    first = links[0]
    if not isWebsite(os.path.join(url, first)):
        url = head(url)
        if not isWebsite(os.path.join(url, first)):
            print("ERROR")
        else:
            base = url

    return map(links, lambda x: os.path.join(base, x))

def downloadPDF(url, name=0):
    if not name:
        name = addExtension(
            prompt(url, "outpath name"), "pdf"
        )
    outpath = npath(dldir, name)

    from requests import get

    r = get(url, stream=True)
    chunkSize = 10000
    with open(outpath, "wb") as fd:
        for chunk in r.iter_content(chunkSize):
            fd.write(chunk)

    ofile(outpath)
    return outpath

def scrapeLinks(source=0):
    #write('request.temp.txt', request('https://www.nysedregents.org/ei/ei-math.html'))
    #return
    source = "https://www.nysedregents.org/ei/"
    #srequest(source)
    items = filter(
        re.findall(
            env.scrapeRef.get("href"),
            read("/home/kdog3682/2023/request.temp.txt"),
        ),
        "released-items",
    )
    items = choose(items)
    items = fixUrls(source, items)

    def downloader(url):
        #m = search("g\d", url)
        #name = f"{m}cw.pdf"
        name = tail(url)
        return downloadPDF(url, name)

    return map(items, downloader)

def reverse(x):
    if isObject(x):
        return {b:a for a,b in x.items()}
    return list(reversed(x))


def to2023(*files):
    def runner(file):
        a = jsdir + file
        b = dir2023 + file
        if not isfile(a):
            a = dldir + file
        assert isfile(a)
        cfile(a, b)

    map(files, runner)


def tagdir(dir, history={}):
    items = {}
    store = {"dir": dir, "items": items}
    files = absdir(dir)
    aliases = {
        ".": "private",
        "l": "library",
        "d": "delete",
        "m": "main",
        "i": "ignore",
    }
    for file in files:
        name = tail(file)
        value = history.get(name)
        if value == None:
            a = prompt(fileInfo(file))
            value = history.get(a, a)

        items[name] = value
    appendVariable(store)

tagdirdict = {
    "dir": "/home/kdog3682/2023/",
    "date": "01-11-2023",
    "items": {
        ".git": "private",
        "changelog.md": "",
        "node_modules": "private",
        "package.json": "private",
        "javascript.master.json": "private",
        "package-lock.json": "private",
        "unit-tests.js": "?",
        "ParserConfigs.js": "?",
        "Lezer.js": "main",
        "Interactive.js": "main",
        "regex-utils.js": "not working",
        "notes.txt": "",
        "CSSObject.js": "main",
        "mathgen.js": "main",
        "DateObject.js": "main",
        "scratchpad.js": "delete",
        "request.temp.txt": "i",
        "clip.js": "i",
        "math.txt": "",
        "scratchpad.txt": "",
        "App.js": "main",
        "comments.js": "",
        "StateContext.js": "delete",
        "parser-factories.js": "main",
        "color-utils.js": "delete",
        "css-utils.js": "main",
        "OX3HTML.js": "main",
        "LineEdit.js": "main",
        "asdf.js": "delete",
        "1673385274916.png": "delete",
        ".gitignore": "private",
        "screenshot.png": "i",
        "test.pdf": "i",
        "Prettier.js": "main-done",
        "vue.esm.browser.min.js": "library",
        "CodeOrganizer.js": "main",
        "node-utils.js": "main",
        "Puppeteer.js": "main",
        "variables.js": "main",
        "server.js": "main",
        "main.js": "main-done",
        "index.html": "main",
        "browser-utils.js": "main",
        "utils.js": "main",
        "HTMLBuilder.js": "main",
        "base-components.js": "main",
        "katex.min.js": "library",
        "katex.min.css": "library",
    },
}

def npmResetNode():

    s = """
        npm install -g npm stable
        npm install -g node or npm install -g n
        node --version or node -v
    """

    SystemCommand(
        """
        npm cache clean -f
        npm install -g n
        n stable
        npm version
    """
    )

def readjs(*args):
    dir = jsdir

    def runner(s):
        file = dir + addExtension(s, "js")
        if isfile(file):
            return file

    return filter(map(args, runner))


def cleandir(dir):
    print('cleaning the dir', dir)
    files = filter(absdir(dir), alwaysDelete)
    pprint(files)
    map(files, rfile)

def renameLastFile(file = 'Extra Worksheet'):
    mfile(glf(), npath(dldir, addExtension(file, 'pdf')))

def resumeIt():
    renameLastFile('Kevin Lee Resume')
    

def uploadDirectoryToExcel(dir='dldir'):
    files = absdir(dirdict[dir])
    data = map(files, finfo)

    googleAction({
        'clear': 1,
        'type': 'gse',
        'data': data,
        'alignLeft': 1,
        'headers': 'name date size comments',
        'open': 1,
        'key': dir,
    })

def finfo(f):
    if isfile(f):
        name = tail(f)
        date = datestamp(f)
        size = fsize(f)
        return [name, date, size]
    else:
        return [name]

def downloadDirectoryFromExcel(dir):
    data = googleAction({
        'type': 'gse',
        'get': 1,
        'key': dir,
    })

def isGunk(file):
    return getExtension(file) in gunkExtensions

def makeRootDir(s):
    mkdir(rootdir + s.upper())

def antichoose(items):
    a = prompt2(items)
    indexes = [int(n) - 1 for n in a.strip().split(" ")]

    store = []
    for i, item in enumerate(items):
        if i not in indexes:
            store.append(item)

    return store

def seeVersions():
    SystemCommand("""
        npm -v
        node -v
    """)

def renameLastFile():
    f = glf()
    mfile(f, changeFileName(f, prompt(f)))

def pickFileFromDir(dir=dldir):
    ofile(choose(absdir(dir)))

pokemonJsonSample = [
  {
    "name": "bulbasaur",
    "types": [
      "grass",
      "poison"
    ]
  },
]

def sub(s, r, f, **kwargs):
    def g(x):
        if isString(f):
            return f
        if x.groups():
            return f(*x.groups())
        else:
            return f(x.group())
    return re.sub(r, g, s, **kwargs)

def memoize(fn):
  store = {}
  def wrapper(*args):
    if args in store:
      return store[args]
    else:
      value = fn(*args)
      store[args] = value
      return value
  return wrapper

def dollarPrompt(x):
    if isArray(x):
        item = choose(x, mode=1)
    elif isObject(x):
        item = choose(list(x.values()), mode=1)
    else:
        item = x

    @memoize
    def f(x):
        return prompt(item=item, fallback=x) or x

    @memoize
    def g(x):
        return prompt(item, 'input:')

    while True:
        if test('\$([a-zA-Z]\w*)', item):
            item = sub(item, r, f, count=1)
        else:
            break
        
    n = 0
    while True:
        n += 1
        r = '\$' + str(n)
        if test(r, item):
            item = sub(item, r, g)
        else:
            break

    return item


def getNameArgsKwargs(s):
    if test('^\w+$', s):
        return [s, [], {}]
    name, s = search('(\w+)\((.*?)\)', s)
    s, kwargs = mget('(\w+) *= *([^\s,]+)', s)
    args = split(s, ', *| +')
    return name, args, kwargs

def stringCall(fn, *args):
    #prompt(args)
    items = map(args, dumpJson)
    #prompt(items)
    argString = ', '.join(items)
    return f"{fn}({argString})"

def dprint(*variables, **kwargs):
    import inspect
    store = ['DPRINT:']

    for v in variables:
        vars = inspect.currentframe().f_back.f_locals.items()
        name = [v_name for v_name, v_val in vars if v_val is v][0]
        store.append([name, v])

    for a,b in kwargs.items():
        store.append([a, b])

    pprint(store)



def newdir():
    dir = dir2023 + input('new dir name:')
    assert not isdir(dir)
    mkdir(dir)




env.basepyref['rnlf'] = 'rnl'
env.basepyref['nd'] = 'newdir'

def arrToDict(a):
    return {i + 1: v for i, v in enumerate(a)}

class Partitioner2:
    def run(self):
        while True:
            done = self.partition()
            if done:
                return unique(list(self.store.values()))

    def __call__(self):
        return self.run()

    def transformRegex(self, s):
        return self.regexPrefix + s + self.regexSuffix
    
    def __init__(self, items):
        self.items = items
        self.store = {}
        self.resetRegex()

    def resetRegex(self):
        self.regexPrefix = '^'
        self.regexSuffix = ''
        self.regexFlags = 0
    
    def partition(self):
        print(numbered(map(self.items, tail)))
        pprint(self.store)
        a = input('')
        if a == '':
            return True

        if a == 'o':
            return ofile(list(self.store.values()))

        if a == 'd':
            self.store = {}
            return 

        if a == 'reset':
            return self.resetRegex()

        if a == 'pdf':
            items = ff(self.items, pdf=1)
            return self.setItems(items)

        m = search('^(\w*) *= *(.+)', a)
        if m:
            key, val = m
            if key == 'flags' or key == 'f' or key == '':
                if 'b' in val:
                    self.regexSuffix = '\\b'
                if 'B' in val:
                    self.regexSuffix = ''
                if 'S' in val:
                    self.regexPrefix = ''

                if 's' in val:
                    self.regexPrefix = '^'
                if 'i' in val:
                    self.regexFlags -= re.I
                if 'I' in val:
                    self.regexFlags += re.I

        m = search('^o *(\d+)', a)
        if m:
            return ofile(self.items[int(m[0]) - 1])

        m = search('^rn *(\d+) *(.+)', a)
        if m:
            old = self.store[int(m[0]) - 1]
            self.store[int(m[0]) - 1] = changeFileName2(old, newName=m[1])
            return 

        m = search('^d *(.+)', a)
        if m:
            indexes = rangeFromString(m)
            return self.deleteItems(indexes)

        if test('^\d', a):
            indexes = rangeFromString(a)
            self.setItems(indexes)
        else:
            r = self.transformRegex(a)
            items = filter(self.items, lambda x: test(r, tail(str(x)), flags=self.regexFlags))
            self.setItems(items)

    def setItems(self, items):
        for item in items:
            index = len(self.store) + 1
            if isNumber(item):
                item = self.items[item]
            self.store[index] = item
        

    def deleteItems(self, items):
        for item in items:
            if isNumber(item):
                self.store.pop(item + 1)
        

def getNumbers(s):
    return map(re.findall('\d+', s), int)

def getUntil(items, checkpoint):
    store = []
    for item in items:
        if checkpoint(item):
            store.append(item)
        else:
            break
    return store

def watchMovie():
    s = prompt('movie name from 123movies?').replace(' ', '+')
    f = f"https://ww1.123moviesfree.net/search-query2/?q={s}"
    ofile(f)


env.basepyref['wm'] = 'watchMovie'


def renameLocalClipFile(a=0):
    name = a or prompt('new name for clip file?')
    mfile('clip.js', addExtension(name, 'js'))
env.basepyref['rlcf'] = 'renameLocalClipFile'
def check(x):
    prompt(x)
    return x

def revertFromTrash():
    file = glf(trashdir)
    ofile(file)
    print(file)
    mfile(file, dldir)
def makeGitIgnore():
    s = """
        */*
        .*
        env.js
        env.py
        env*
    """
    write(".gitignore", smartDedent(s))


def grabGitFiles():
    files = ['codemirror.js', 'codemirror.css', 'cm.js', 'cm.css']
    base = 'https://github.com/kdog3682/codemirror/blob/main/'
    files = map(files, lambda x: npath(base, x))
    map(files, getGithubFile)

def getGithubFile(a):
    def githubUrlToUserContent(s):
        return s.replace("blob/", "").replace(
            "github.com", "raw.githubusercontent.com"
        )

    a = githubUrlToUserContent(a)
    name = tail(a)
    s = request(a)
    if not s:
        dprint(name)
    write(name, s, open=1)

def gitInit(dir=0, user=env.user):
    if not dir:
        #dir = prompt('make a dir inside of dir2023')
        dir = 'code-editor'
        if not isdir(dir):
            dir = npath(dir2023, dir)
            #mkdir(dir)
            #makeGitIgnore()

        #chdir(dir)
        #grabGitFiles()

    assert isdir(dir)
    repo = tail(dir)
    chdir(dir)
    from githubscript import Github
    Github(key=user, repo=repo)

    command = f"""
        git init
        git add .
        git commit -m "push everything"
        git remote add origin git@github.com:{user}/{repo}
        git push -u origin master 
    """

    res = SystemCommand(command, dir=dir)
    if res.success:
        ofile(f"https://github.com/{user}/{repo}")

def removeLastFile(dir=dldir):
    file = glf(dirgetter(dir))
    prompt('is this file correct?', file)
    rfile(file)
    

def removeDateString(s):
    return re.sub(' *\d+[-/]\d+[-/]\d+ *$', '', s)

env.basepyref['rlf'] = 'removeLastFile'

def dsearch(s, dict, template=''):
    r = reWrap(dict, template)
    m = search(r, s)
    return dict[m] if m else None

def resetGit():
    cmd = """
        git rm -r --cached .;
        git add .;
        git commit -m "Untracked files issue resolved to fix .gitignore";
        git push;
        # holy shit this was scary.
        # I thought it deleted everything, but it didnt.
        # Thank goodness. It merely clears everything out.
    """
    SystemCommand(md)

def readLastReversion():
    f = glf(budir)
    print(fileInfo(f))

def double(items, f):
    return [(item, f(item)) for item in items]

def isf(f):
    extensions = ['json', 'pdf']
    for e in extensions:
        name = addExtension(f, e)
        dirs = [dldir, dirFromFile(name)]
        for dir in dirs:
            path = npath(dir, name)
            if isfile(path):
                ofile(path)
                return path

env.basepyref['o'] = 'ofile'
def normMove(file):
    mfile(normDirPath(file), currentdir)
    
def mclean(file):
    r = f"^{jspy(file, '//')} *(.*)\n*"

    def runner(s):
       s, items = mget(r, s, flags=re.M, mode=list)
       if not items:
           return 

       logger(items=items, file=file)
       return s

    rpw(smart_path(file), runner)


#pprint(gitNames(pydir))



def gitUrl(dir):
    repo = tail(dir)
    return f"https://github.com/{env.githubUser}/{repo}"

def pipInstall(s):
    cmd = 'abc ' + s
    print(cmd)

def removeComments(s):
    return re.sub('^[#/].+\n*', '', s, flags=re.M)

#logger(action='test', c='ddddddddddd', e='gggg', f=1, h=alist)
#pprint(mclean('/home/kdog3682/PYTHON/utils.js'))
#mclean('/home/kdog3682/2023/utils.js')

#appendVariable(absdir(colordistdir))

#parseTime('4:57PM')
#dategetter('4:32pm')
#pprint(datestamp())
def createdir(dir, files, mode='copy'):
   name = dir
   if isdir(dir):
       name = os.path.join(dir, datestamp())
   mkdir(name) 
   if mode == 'move':
        map(files, mfile, name)
   elif mode == 'move':
        map(files, cfile, name)
   printdir(name)

#createdir(colordir, ff(dldir, after='4:55PM'), mode='move')

def renameColoringFilesInDir():
    #data = map(absdir(colordir + datestamp()), lambda x: mfile(x, re.sub(' colo.+?(?=\.pdf)', '', x, flags=re.I)))
    printdir(colordir + datestamp())

#pprint(gitNames(dir=pydir))
#pprint(ff(txtdir, name='hash'))

#pprint(glf(budir))
#moveClipToLogJson(key='gradeRef')
#s = linegetter(SystemCommand('git ls-tree --full-tree --name-only -r HEAD').success)
#pprint(s)

#ff(name='test')
#pprint(changeFileName(npath(dldir, 'test.pdf'), lambda x: 'foo' + x))
def renameFile(input, output):
    outpath = changeFileName(input, output)
    mfile(input, outpath)
    ofile(outpath)

def numbered(items, title=''):
    if title: title = '  ' + title + '\n'
    s = '\n' + title + '\n'
    for i, item in enumerate(items):
        spaces = '  ' if i < 9 else ' '
        s += '  ' + str(i + 1) + '.' + spaces + stringify(item) + '\n'
    return s

def snapshotOfDirectory(dir=dldir, amount=10):
   os.chdir(dir)
   items = sorted(os.listdir(dir), key=mdate, reverse=True)[0:amount]
   return numbered(items, title='FILES IN: ' + dir)

def dlf():
    rfile(glf())

def splitInHalf(items):
    import math
    halfPoint = math.floor(len(items) / 2)
    return items[0:halfPoint], items[halfPoint:]

#print(snapshotOfDirectory())

#pprint(findFile('Student Grade Reports.pdf'))

def deprecateFile(file):
    newFile = changeExtension(file, 'deprecated.' + getExtension(file))
    prompt(file, newFile)
    mfile(file, newFile)

def ffApp(s):
    ff(**createKwargs(s))

#pprint(isfile('data-parsers.js'))
env.basepyref['dep'] = 'deprecateFile'
#ffWrapper('name=dep')
env.basepyref['ff'] = 'ffApp'
#t = datetime.now()
#pprint(t.isoweekday())
#ff(dir=pydir, text='^\d+\.\d+.*?\n\d+\.\d+', flags=re.M | re.I)
#printdir(dir2023)

#pprint(trashdir)
#ff(listdir(trashdir), py=1)

#strife = "%A %B %d, %-I:%M:%S%p"
#t = mdate(pydir + 'base.py')
#pprint(t)
#pprint(timestamp())
#pprint(toSeconds(hours=10))
#n = timestamp()
#pprint(datetime.fromtimestamp(timestamp()).strftime('%c'))
#n =  timestamp() - toSeconds(hours=168)
#pprint(datetime.fromtimestamp(n).strftime(strife))
#pprint(isRecent(dldir + 'practice-test-math-grade-4.pdf', hours=1000))
#ff(dldir, pdf=1, weeks=8, mode='info')
#print(shellescape('/home/k/~asd'))
"App.js"
s='''
bob:

g4h 23-24
'''
#SystemCommand('node App.js pdfIni', s)
def configString(kwargs):
    s = ''
    for k, v in kwargs.items():
        s += k + ' = ' + v + ' '
    return s.strip()

def JavascriptAppCommand(key, arg='', **kwargs):
    result = SystemCommand('node', 'App.js', key, arg, **kwargs, python=True)
    if not result:
        return 
    if not result.success:
        pprint('error')
        return 

    delimiter = '::CLEARING::'
    s = re.split(delimiter, result.success, maxsplit=1)[1]
    data = parseJSON(s)
    return data

def choose2(items, display=0, anti=0):
    if isObject(items[0]) and not display:
        if items[0].get('title'): display = lambda x: x.get('title')
        elif items[0].get('foo'): display = lambda x: x.get('foo')
        elif items[0].get('subject'): display = lambda x: x.get('subject')

    if anti:
        pprint('choosing which items to keep. The rest will be deleted')
    presentation = map(items, display) if display else items
    print(numbered(presentation))
    indexes = rangeFromString(input())
    if anti:
        store = [el for i, el in enumerate(items) if i not in indexes]
    else:
        store = [el for i, el in enumerate(items) if i in indexes]
    prompt(store)
    return store
        
def deleteKey(item, key):
    if isObject(item):
        item.pop(key)
    return item

def getYearNumber():
    return datetime.now().year
#pprint(getYearNumber())

#print(map(choose2([{'subject': 1}], anti=1), lambda x: deleteKey(x, 'subject')))

def getLoggerData(key, childKeys=0, fallback=None):
    data = read(glogfile)
    f = lambda x: x.get('key') == key or x.get('action') == key
    data = filter(data, f)

    if not childKeys:
        return data
    return data
    #for childKey in childKeys:
    #for item in data:
        #f
    #if isArray(fallback):
        #storeType = list
    #for i


    return data

def hasKey(x, key):
    return isObject(x) and x.get(key)

#getLoggerData(key='gitpush')

#SystemCommand('''
#pip install pillow
#pip install pytesseract
#''')

#pprint(npath(dldir, '/home/kdog3682/PYTHON/base.py'))
#pprint(hasKey('asdf', 'a'))
#printdir(pdfdir)


#store = Partitioner2(os.listdir(dldir))()
#pprint(store)
#ff(dir2023, js=1, mode='info', text='worddict', flags=re.I)
#todo vueData textEdit advanced htmlBuilder

#ff(pubdir, js=1, name='comp', mode='open')


def readRaw(file):
    with open(file, 'r') as f:
        return f.read()

def seeClipKeys():
    s = readRaw('clip.js')
    keys = ['staticClass', 'component']
    r = reWrap(keys, '(?:$1)": "(.*?)"')
    data = unique(re.findall(r, s))
    pprint(data)
    return data
#seeClipKeys()

#Each item ... has to look a certain way.
#When you serve those whom you have a connection to, it feels different.
#All of you are smart!
#There are not really any complaints.
#For the most part, playing by the rules.
#mkdir(dldir + 'PDFS')

class StepwisePartition:

    def run(self, items):
        assert items
        self.stack = [items]
        while True:
            done = self.prompt()
            if done:
                return unique(self.last)

    @property
    def last(self):
        return getLast(self.stack)

    def prompt(self):
        print(numbered(map(self.last, tail)))
        a = input('')

        if a == '':
            return True

        if a == 'o':
            ofile(self.last)
            return 

        if a == 'd':
            self.stack.pop()
            return 

        if a == 'reset':
            self.resetRegex()
            return 

        if a == 'pdf':
            newItems = ff(self.items, pdf=1)
            self.stack.append(newItems)
            return 

        m = search('^(\w*) *= *(.+)', a)
        if m:
            key, val = m
            if key == 'flags' or key == 'f' or key == '':
                if 'b' in val:
                    self.regexSuffix = '\\b'
                if 'B' in val:
                    self.regexSuffix = ''
                if 'S' in val:
                    self.regexPrefix = ''

                if 's' in val:
                    self.regexPrefix = '^'
                if 'i' in val:
                    self.regexFlags -= re.I
                if 'I' in val:
                    self.regexFlags += re.I

                print("setting flags", self.regexFlags)
            return 

        m = search('^o *(.+)', a)
        if m:
            indexes = rangeFromString(m)
            newItems = [item for i, item in enumerate(self.last) if i in indexes]
            prompt(newItems)
            ofile(newItems)

        m = search('^d *(.+)', a)
        if m:
            indexes = rangeFromString(m)
            newItems = [item for i, item in enumerate(self.last) if i not in indexes]
            self.stack.append(newItems)
            return 

        if test('^\d', a):
            indexes = rangeFromString(a)
            newItems = [item for i, item in enumerate(self.last) if i in indexes]
            self.stack.append(newItems)
            return 

        r = self.transformRegex(a)
        f = lambda x: test(r, tail(str(x)), flags=self.regexFlags)
        newItems = filter(self.last, f)
        if newItems: self.stack.append(newItems)

    def transformRegex(self, s):
        return self.regexPrefix + s + self.regexSuffix
    
    def __init__(self):
        self.resetRegex()

    def resetRegex(self):
        self.regexPrefix = '^'
        self.regexSuffix = ''
        self.regexFlags = 0
    
def partitionMove(dir, to=0, action='move'):
    files = StepwisePartition().run(absdir(dir))
    prompt(files, action=action, message='please confirm')
    if action == 'move':
        mfiles(files, to)
    elif action == 'delete':
        map(files, rfile)


def textlog(**kwargs):
    store = []
    store.append(('date', datestamp()))
    store.append(('getCaller', getCaller()))
    for k,v in kwargs.items():
        store.append((k, v))
    
    s = ''
    for a,b in store:
        if not b:
            continue
        s += a + ': '
        if isArray(b):
            s += '\n' + indent(b) + '\n'
        else:
            s += b 

        s += '\n'

    value = s + linebreak + '\n'
    if s.strip():
        append('log.txt', value)

def WorkSummary(file):
    if getExtension(file) != 'js':
        pprint('only js for worksummary')
        return 

    textlog(
        file=file,
        work=getBindingNames(read(file))
    )

def indent(items):
    return join(map(items, lambda x: '    ' + x))


def getBindingNames(s):
    r = '^(?:class|const|var|(?:async )?function) (\w+)'
    return re.findall(r, s, flags=re.M)

def isChinese(s):
    return test('[\u4e00-\u9fa5]', s)

def isEnglish(s):
    return test('[a-zA-Z]', s)

#s = findFile('test.pdf')
#ofile(s)

#pprint(dollarPrompt('hi $1\n\nfooo()'))
#printdir(nodedir2023)
#ofile(nodedir2023 + 'pdfjs-dist/web/pdf_viewer.js')
#ofile('/home/kdog3682/2023/pdfjs/web/viewer.html')
#ofile('/home/kdog3682/2023/pdfjs/web/viewer.js')
#printdir(pubdir)
#sosdf()
#chdir(pubdir)
#ofile('sj.js')
x = [
    'magic', 'square', 'story', 'next', 'new', 'geometry'
]
s = """
magic is no 

square is some sort of thing.
"""

#ofile([el + '.js' for el in x])
#printdir(mathdir)

def saveMathFileByFolder(file, gradeLevel=4):
    date = upcomingDate('saturday', strife='-')
    dir = mathdir + date
    f = lambda x: f"G{gradeLevel} {capitalize(x)}"
    originalPath = addExtension(file, 'txt')
    path = npath(dir, changeFileName(originalPath, f))

    def getPath(path):
        if isfile(path):
            if gradeLevel == 4:
                path = path.replace('G4', 'G5')
            else:
                path = path.replace('G5', 'G4')

            if isfile(path):
                return 
            else:
                return path
        else:
            return path

    path = getPath(path)
    assert path
    message = "Do you want to move this file to the mathdir? It will delete the original file"
    prompt(read(originalPath), message=message, outpath=path)


    if not isdir(dir):
        os.makedirs(dir)

    mfile(originalPath, path)

#pprint(saveMathFileByFolder('quiz'))

#pprint(find_file('-5'))
#pprint(upcomingDate('saturday', next=2))
def promptRenameFile(file):
    t = tail(file)
    a, b = re.split(' *\| *', prompt(t), maxsplit=1)
    newFile = file.replace(t, t.replace(a, b))
    mfile(file, newFile)

#ff(mathdir, recursive=1, mode='tree')
#pprint(promptRenameFile('asdf/asdf/a.js'))
#pprint(printDirRecursive(mathdir))
#printdir(sandir)
#ff(fontdir)

def getMathDir(next=0):
    dir = mathdir + upcomingDate('saturday', strife='-', next=next)
    assert isdir(dir)
    return dir

def copydir(src, to):
    newDir = npath(to, src)
    assert not isdir(newDir) and isdir(to)
    prompt(f"copying {src} to {newDir}")
    shutil.copytree(src, newDir)
    print(f"copying directory: {newDir}")
#copydir(getMathDir(), sandir)
#printdir(sandir)
#printdir(dir2023)

def get_usb_dir():
    if isdir(usbdrivedir):
        return usbdrivedir
    elif isdir(sandir):
        return sandir
    else:
        raise Exception('no usb dir')

def usb(x=0):

    dir = get_usb_dir()

    f = glf(dir=dir2023)
    if tail(f) == 'clip.html' and isRecent(f, minutes=5):
        cfile(f, dir)
        return 

    dir = os.path.join(dir, str(getYearNumber()))
    mkdir(dir)

    files = x or ff(dir2023, hours=10, js=1)
    map(files, cfile, dir)


def saveToSandisk(x=2):
    if not isdir(sandir):
        raise Exception('')
    outdir = os.path.join(sandir, datestamp())
    if isdir(outdir):
        raise Exception('outdir already exists')
    mkdir(outdir)

    if isdir(x):
        copydir(dir, outdir)
    else:
        if isNumber(x):
            x = ff(dir2023, days=2) + ff(pydir, days=2)

        prompt(x, 'save to outdir?', outdir=outdir)
        map(x, cfile, outdir)

#pprint(upcomingDate('saturday'))
#mfiles(absdir(usbdrivedir), mkdir(os.path.join(usbdrivedir, key)))
#printdir(usbdrivedir)
#cfile('ec.js', usbdrivedir)
#usb('test.pdf as Q')

temp = [
    "/home/kdog3682/2023/positive-statements.school.txt",
    "/home/kdog3682/2023/classwork.school.txt",
    "/home/kdog3682/2023/comments.school.txt"
]
#printdir(getMathDir(-1))

#appendVariable(choose(sort(ff(dldir, days=12, pdf=1), lambda x: tail(x))))

#printdir(jchdir)
#ofile(jchdir + 'components.js')


def saturdate():
    return upcomingDate('saturday', strife='-')

def getSaturdayDir(dir):
    return os.path.join(dir, saturdate())

def swapFiles(a, b):
    a = addExtension(a, 'js')
    b = addExtension(b, 'js')
    s = read(a)
    cfile(b, a)
    write(b, s)

def sayhi(s):
    return 'Hello from ' + s + '!'

def writeFiles(*args):
    def runner(arg):
        write(addExtension(arg, 'js'), sayhi(arg))
    map(args, runner)

#writeFiles('a', 'b')
#swapFiles('a', 'b')
#swapFiles('test', 'dialogue')
#mkdir(localbackupdir)
#printdir(localbackupdir)
#appendVariable(ff(dir2023, hours=1))
#pprint(isRecentFile('base.py', after='1:00AM', days=0))

temp = [
    #"/home/kdog3682/2023/changelog.md",
    #"/home/kdog3682/2023/javascript.dependencies.json",
    #"/home/kdog3682/2023/scratchpad.js",
    #"/home/kdog3682/2023/comments.school.txt",

    "/home/kdog3682/2023/dialogue.js",
    "/home/kdog3682/2023/utils.js",
    "/home/kdog3682/2023/textEdit.js",
    "/home/kdog3682/2023/codeOrganizer.js",
    "/home/kdog3682/2023/compileRE.js",
    "/home/kdog3682/2023/consumableParse.js",
    "/home/kdog3682/2023/dialogue.txt",
    "/home/kdog3682/2023/hammyDialogue.js",
]
#usb(temp)
def nameAndDate(file):
    name = tail(file)
    date = datestamp(file)
    return [date, name]

#ff(dir2023, mode='date', js=1)
#git clone https://github.com/firebase/codelab-friendlychat-web



hammyfirebase = '''
<script type="module">
  // Import the functions you need from the SDKs you need
  import { initializeApp } from "https://www.gstatic.com/firebasejs/9.18.0/firebase-app.js";
  import { getAnalytics } from "https://www.gstatic.com/firebasejs/9.18.0/firebase-analytics.js";
  // TODO: Add SDKs for Firebase products that you want to use
  // https://firebase.google.com/docs/web/setup#available-libraries

  // Your web app's Firebase configuration
  // For Firebase JS SDK v7.20.0 and later, measurementId is optional
  const firebaseConfig = {
    apiKey: "AIzaSyCOTawJsonmn-tMczAwn9aZcZlIplwP4vo",
    authDomain: "hammy-math-class.firebaseapp.com",
    projectId: "hammy-math-class",
    storageBucket: "hammy-math-class.appspot.com",
    messagingSenderId: "37397511963",
    appId: "1:37397511963:web:8192df6cdbb76720c61dbe",
    measurementId: "G-KJZ6Z4PMJC"
  };

  // Initialize Firebase
  const app = initializeApp(firebaseConfig);
  const analytics = getAnalytics(app);
</script>

'''
#SystemCommand('npm install -g firebase-tools')


def mkfile(file, *items):
    write(file, join(items))

samplehtml = '''
<!DOCTYPE html>
<html>
<head>
	<title>Sample HTML Document</title>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
	<h1>Welcome to My Sample HTML Document</h1>
	<p>This is a paragraph of text. It's really not that interesting, but it's here anyway.</p>
	<ul>
		<li>List item 1</li>
		<li>List item 2</li>
		<li>List item 3</li>
	</ul>
	<a href="https://www.example.com">Click here to visit Example.com</a>
</body>
</html>


'''

#mkdir(publicfirebasedir)
#mkfile(hammyfirebasehtml, samplehtml, hammyfirebase)
#ff(html=1)

def fa(s, r, flags=0, fn=0):
    s = textgetter(s)
    m = re.findall(r, s, flags=flags)
    if fn:
        map(m, fn)
    else:
        pprint(m)

def file_table_cleanup():

    def filetablefn(file, notes):
        r = 'dep|del'
        if not isfile(file):
            print("'not a file'", file)
            return 
        try:
            if test(r, notes) or fsize(file) < 50:
                print('removing', tail(file))
                rfile(file)
        except Exception as e:
            print(e, file)
        

    fa('file-table.txt', '2023 +(\S+)(.*)', fn=filetablefn)


#ofile('http://localhost:8000')
#printdir(nodedir2023 + 'nerdamer/')
#ofile(nodedir2023 + 'nerdamer/index.html')

def publish(name):
    dir = publishdir
    inpath = addExtension(name, 'txt')
    outpath = npath(dir, inpath + '.' + saturdate())
    shutil.copy(inpath, outpath)
    clear(inpath)
    printdir(dir)
#usb(ff(js=1, hours=3))
#ofile(findFile('emojis.json'))
#printdir(publishdir)

def openFirstFile(dir):
    ofile(absdir(dir)[0])

#openFirstFile(publishdir)

#ff(js=1, days=5, text='./generateMultipleChoice')

    

def addfiles():
    ignoreRE = '''
        component
        scratch
        directive
        state
        config
        ask
        clip
        wrappers
        server
        chalk
        main
        puppeteer
        pretty

        serve
        type
        interactive
        ox3
        hammy
        app

    '''
    ignoreRE = '|'.join(linegetter(ignoreRE))
    return ff(js=1, days=5, sort='date', ignoreRE=ignoreRE, size=2000)

#addfiles()
#ff(localbackupdir)

def addTitles():
    def f(item):
        if test('^\w+(?: \w+){1,5} *\n', item):
            title = search('^\w.+', item)
            dprint(title)
            return item
        #if test('^\w+\n\n', item):
            #dprint(title)
            #return item

        else:
            a = prompt(item, 'write a title if you would like:  ')
            if a:
                return a + '\n\n' + item
            return item

    s = read('quiz.txt')
    items = map(split(s, '^---+', flags=re.M), f)
    clip('\n\n---------------------'.join(items))
    #clip(items)
    #s = join(items, '\n\n-------------------')
    #clip(s)

#cfile('clip.js', 'quiz.txt')
#addTitles()
#print(len(split(clip(), 'linebreak')))
#pprint(len(clip()))
#ff(js=1, name='cypher')
#ff(dir=pubdir, js=1, name='vue', mode='open')

#assert(print(sayhi('hi')))
#pprint(datestamp())
#printdir(get_usb_dir() + '/2023')
#pprint(ff(days=15, js=1, text='downloadpdf', once=1, flags=re.I, ignoreRE='hammyco|server|browser'))
#ff(mode='save', html=1)

#map(temp, rfile)
#usb(ff(pydir, days=3))
#ff(jsondir, mode='open', name='css')
#file:///media/fuse/crostini_25bd1ae3ef71bac8d459747ce670faa67d509f14_termina_penguin/JSONS/css.abrevs.json
#s =


def downloadImage(url, name, openIt=0):
    from requests import get
    r = get(url)
    if r.status_code == 200:
        with open(name,'wb') as f:
            f.write(r.content)
            if openIt:
                ofile(name)
            print('Image sucessfully Downloaded: ',name)
            return name
    else:
        print('Image Couldn\'t be retreived', name) 

#ofile('gpt.json')
#olf()
# Give lots of details.
#cleandir(pydir)


stamp = 1680605615

class AbstractState():
    def __init__(self):
        self.store = []

class BeforeAfter:

    def __enter__(self):
        return self
    def __exit__(self, etype, value, traceback):
        if etype:
            print(etype, value)
        else:
            write(self.file, self.parent, open=1)

    def __init__(self, file = 'reddit.json', key = 'mementomoriok'):
        self.file = file
        self.key = key
        self.parent = read(self.file) or {}
        if not key in self.parent:
            self.parent[key] = {}
        self.child = self.parent[key]

        if not 'history' in self.child:
            self.child['history'] = []
        self.history = self.child['history']

    def set(self, k, v):
        if isPrimitive(v):
            self.child[k] = v
        elif isArray(v):
            pass
        else:
            raise Exception('ndy')

    def get(self, k, fallback=None):
        return self.child.get(k, fallback)
    

def coerceArray(x):
    if isArray(x):
        return x
    if x == None:
        return []
    return [x]

#print([][-1])
#print(datestamp(1680614730.0, 'praw'))
#pprint(map(read('reddit.json').get('unstable_diffusion').get(datestamp()), lambda x: datestamp(x.get('timestamp'), 'praw')))
#aobj = {'a': 1}
#pprint(list(aobj))
def save(**kwargs):
    for k,v in kwargs.items():
        appendVariable(v, name=k)
        break

#save(olddirs=ff(rootdir, contains='py'))
#save(pyfiles=ff(rootdir, py=1))



#a  =  {'created_utc': stamp}
#pprint(datestamp(a))


#print(filter([None]))
#pprint(timestamp())
#printdir(nodedir + 'chroma-js')

#cfile(findFile('chroma.min.js'), dir2023)
#cfile(glf(), dir2023)


vimfiles = [
'/home/kdog3682/VIM/functions.vim',
'/home/kdog3682/.vimrc',
'/home/kdog3682/VIM/variables.vim',
'/home/kdog3682/.vim/ftplugin/javascript.vim',
]
#map(vimfiles, saveToDrive)

#print(map([{'a':1}], 'a'))
def archive(inpath=0, outpath=0):
    if not inpath: inpath = 'clip.js'
    if not outpath: 
        outpath = prompt(outpath='need an outpath', inpath=inpath)
    assert outpath

    cfile(inpath, npath(drivedir, outpath))

#s = read(drivedir + 'allGoogleDocs.json')
def checkpoint_factory(schema):

    def c2(**kwargs):
        #print(kwargs)
        def transform(a, b):
            #print(a, b)
            if b == str:
                return lambda x: test(a, x, flags=re.I)

            if b == bool:
                print(a, b)
                return lambda x: x == a

            if b == int:
                return lambda x: x > a

        store = []
        for k,v in schema.items():
            arg = kwargs.get(k)
            if arg != None:
                store.append([k, transform(arg, v)])

        def checkpoint(item):
            for k,v in store:
                arg = item.get(k)
                if arg and not v(arg):
                    return False

            return True
        return checkpoint

    return  c2
        

def obj_filter(items, **kwargs):
    schema = {
        'title': str,
        'owner': str,
        0: int,
        'delete': bool,
    }

    getter = getterf(kwargs.get('get'))
    c1 = checkpoint_factory(schema)
    f = c1(**kwargs)
    
    values = [getter(item) for item in items if f(item)]
    return values
def small(x):
    return x[0: 3]

tempGoogleDocJson = [
    {
        "id": "11PzEB137TPCDX4xr8Hcy3ysJ4FPRwm24jRMhIb7Lb6k",
        "owner": "Kevin Lee",
        "title": "Resume",
        "size": 1478,
        "elapsed": {
            "type": "months",
            "value": 2760
        },
        "date": "01-03-2023",
        "year": 2023
    },
    {
        "id": "17snn0wfBnvGzizd6Ox0ZM_QCq5wJU2ai-L2HX-wuKH4",
        "owner": "Kevin Lee",
        "title": "resume Sunny \u6253\u5370\u8bf4\u660e",
        "size": 931,
        "elapsed": {
            "type": "days",
            "value": 2
        },
        "date": "03-15-2023",
        "year": 2023
    },
    {
        "id": "1COY_z29tbRHH3ZX0pmpmNDn_6UE_KOXRxsIQRcTm1bY",
        "owner": "Kevin Lee",
        "title": "Final Letters Test",
        "size": 9934,
        "elapsed": {
            "type": "minutes",
            "value": 41
        },
        "date": "03-15-2023",
        "year": 2023
    }
]

def getterf(*args):
    args = flat(map(args, lambda x: split(x, '[, ]+') if x else []))
    if not args:
        return identity 
    def fn(item):
        store = {}
        for arg in args:
            if arg in item:
                store[arg] = item[arg]
        return store
    return fn

def googleDocsJson(debug=0):
    if debug:
        return tempGoogleDocJson
    return read(drivedir + 'allGoogleDocs.json')
#items = googleDocsJson(debug=1)
#items = obj_filter(items, title='\bcover\b|resume', owner='kevin', delete=False, get='id date title')
#appendVariable(items)



temp = [
    {
        "id": "11PzEB137TPCDX4xr8Hcy3ysJ4FPRwm24jRMhIb7Lb6k",
        "date": "01-03-2023",
        "title": "Resume"
    },
    {
        "id": "17snn0wfBnvGzizd6Ox0ZM_QCq5wJU2ai-L2HX-wuKH4",
        "date": "03-15-2023",
        "title": "resume Sunny \u6253\u5370\u8bf4\u660e"
    }
]
#makeNodePDF(temp)

def makeNodePDF(data = temp, vob_key='resume_toc'):
    fnKey = 'makePDF'
    payload = {'key': vob_key, 'value': data}
    SystemCommand('node', 'App.js', fnKey, payload)

def comment(s):
    return '# ' + s

def writejs(s):
    name = prompt('choose a file name')
    name = addExtension(name, 'js')
    if exists(s):
        write(name, s)
        append(self(), comment(abspath(name)))

#writejs(sub(sub(join(filter(read(glf()), '\n')), ';', ''), '(?: +|\n+)// .+', ''))

# /home/kdog3682/2023/routers.pdfgen.js

# /home/kdog3682/2023/routers.pdfgen.js


    


#vimFiles = ['/home/kdog3682/.vimrc', '/home/kdog3682/VIM/functions.vim', '/home/kdog3682/VIM/variables.vim']
#save = absdir(examdir) + ff(jsondir, days=10) + ff(txtdir, days=10) + ff(dir2023, files=1) + ff(pydir, days=10) + vimFiles

# also have an append.vim
#usbz(save)

def dprompt(*variables, **kwargs):
    
    import inspect

    strings = []
    caller = getCaller()
    from collections import OrderedDict
    store = OrderedDict()
    store['caller'] = caller

    for v in variables:
        try:
            vars = inspect.currentframe().f_back.f_locals.items()
            name = [v_name for v_name, v_val in vars if v_val is v][0]
            store[name] = v
        except Exception as e:
            strings.append(v)
        

    for a,b in kwargs.items():
        store[a] = b

    if strings: 
        store['strings'] = strings

    pprint(store)
    return input('')



def file_name(s):
    return removeExtension(tail(s))

def is_json(f):
    return getExtension(f) == 'json'

def rename_file():
    f = glf(dir2023)
    mfile(f, changeExtension(f, 'js'))

#rename_file()
#mlf()

#file = '
#SystemCommand(f"git log --pretty=format:%h --author-date-order --diff-filter=A --follow {file} | tail -1 > commit.txt")

#SystemCommand('git add git.js')

def printDiff(target=''):
    s = SystemCommand(f"git diff --word-diff {target}")
    if target:
        print(s.success)
    else:
        #return print(s.success)
        write('diff.txt', s.success, open=1)


def getNewGitFiles():
    s = SystemCommand('git status --short').success
    r = '^ *\?\?(.+)'
    return re.findall(r, s, flags=re.M)


def parseDiff():
    
    new = getNewGitFiles()
    rfile = '^diff --git a/(.*?) b.*\nindex (\w+)\.\.(\w+)'
    cmd = SystemCommand(f"git diff --word-diff")
    date = datestamp()
    matches = re.split(rfile, cmd.success, flags=re.M)
    items = partition(filter(matches), 4)
    def parse(x):
        a, b, c, d = x
        prefix = "[\[\{][-+]"
        regex = "^\{\+(?:(?:async )?function[!*]?|def|class|const|var) ([\w\$]+)"
        items = re.findall(regex, d, flags=re.M) or []
        if not items:
            return 

        payload = { 'date': date, 'file': a, 'from': b, 'to': c, 'items': items }
        if a in new:
            payload['new'] = True
        return payload

    items = filter([parse(x) for x in items])
    return items

#pprint(parseDiff())


def mwrite(inpath, outpath, regex, flags=0):
    text = read(inpath)
    assert text

    if test('^\^', regex) and not flags:
        flags = re.M

    a, payload = mget(regex, text, flags=flags, mode=list)
    if not payload:
        return print('no payload early return')

    cfile(inpath, 'temp.py')
    write(smart_path(inpath), text)
    return
    #outpath = addExtension(outpath, getExtension(inpath))
    #append(smart_path(outpath), payload)



def smart_path(file):
    return npath(dirFromFile(file), file)

mwrite(smart_path('base.py'), 'comments.py', '^# *.+|^\w+\(.+')
